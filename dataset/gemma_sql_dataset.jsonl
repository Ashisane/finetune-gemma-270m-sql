{"text": "<start_of_turn>user\nWhat is SQL?\n<end_of_turn>\n<start_of_turn>model\nSQL, or Structured Query Language, is a standard programming language used to manage and manipulate relational databases. It's used for tasks like querying data, inserting, updating, and deleting records, and managing database schemas.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy is SQL considered a declarative language?\n<end_of_turn>\n<start_of_turn>model\nSQL is considered declarative because you specify *what* you want to achieve, not *how* to achieve it. For example, when you write a `SELECT` query, you describe the data you want to retrieve, and the database management system (DBMS) figures out the most efficient way to get it.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are the main sub-languages of SQL?\n<end_of_turn>\n<start_of_turn>model\nThe main sub-languages are: DDL (Data Definition Language) for schema definition, DML (Data Manipulation Language) for data modification, DQL (Data Query Language) for querying data, DCL (Data Control Language) for access control, and TCL (Transaction Control Language) for managing transactions.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is DDL and what are some common commands?\n<end_of_turn>\n<start_of_turn>model\nDDL, or Data Definition Language, is used to define and manage the database structure or schema. Common commands include `CREATE` (to create tables/databases), `ALTER` (to modify the structure), and `DROP` (to delete objects).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is DML and what are its primary commands?\n<end_of_turn>\n<start_of_turn>model\nDML, or Data Manipulation Language, is used for adding, deleting, and modifying data within tables. The primary DML commands are `INSERT` (to add data), `UPDATE` (to modify existing data), and `DELETE` (to remove data).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a primary key?\n<end_of_turn>\n<start_of_turn>model\nA primary key is a constraint that uniquely identifies each record in a table. Its value must be unique for each row and cannot be NULL. A table can only have one primary key.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy is a primary key important?\n<end_of_turn>\n<start_of_turn>model\nA primary key is crucial for ensuring data integrity. It guarantees that each row is unique, prevents duplicate records, and serves as a target for foreign keys to establish relationships between tables, which is fundamental to relational database design.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a foreign key?\n<end_of_turn>\n<start_of_turn>model\nA foreign key is a key used to link two tables together. It's a field (or collection of fields) in one table that refers to the primary key in another table. It enforces referential integrity, ensuring relationships between tables remain consistent.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does a foreign key maintain referential integrity?\n<end_of_turn>\n<start_of_turn>model\nA foreign key maintains referential integrity by restricting actions that would destroy the link between tables. For example, it can prevent you from deleting a record from a parent table (the one with the primary key) if a corresponding record exists in the child table (the one with the foreign key).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a primary key and a unique key?\n<end_of_turn>\n<start_of_turn>model\nBoth enforce uniqueness. However, a table can have only one primary key, which cannot have NULL values. A table can have multiple unique keys, and they can accept one NULL value (in most database systems).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `SELECT` statement?\n<end_of_turn>\n<start_of_turn>model\nThe `SELECT` statement is the cornerstone of SQL's Data Query Language (DQL). Its primary purpose is to retrieve or fetch data from one or more database tables. You can select specific columns, all columns, and use various clauses to filter, sort, and group the results.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `WHERE` clause used for in a query?\n<end_of_turn>\n<start_of_turn>model\nThe `WHERE` clause is used to filter records. It extracts only those records that fulfill a specified condition. It is used with `SELECT`, `UPDATE`, and `DELETE` statements to specify which rows should be affected.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does the `ORDER BY` clause work?\n<end_of_turn>\n<start_of_turn>model\nThe `ORDER BY` clause is used to sort the result set of a query in either ascending (`ASC`) or descending (`DESC`) order. By default, it sorts in ascending order. You can specify one or more columns to sort by.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between `DELETE`, `TRUNCATE`, and `DROP`?\n<end_of_turn>\n<start_of_turn>model\n`DELETE` is a DML command that removes rows from a table one by one and can be rolled back. `TRUNCATE` is a DDL command that quickly removes all rows from a table and cannot be rolled back. `DROP` is a DDL command that removes the entire table, including its structure and data, and cannot be rolled back.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a `JOIN` in SQL?\n<end_of_turn>\n<start_of_turn>model\nA `JOIN` clause is used to combine rows from two or more tables based on a related column between them. It is the primary mechanism for retrieving data that is distributed across multiple tables in a relational database.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the difference between `INNER JOIN` and `LEFT JOIN`.\n<end_of_turn>\n<start_of_turn>model\nAn `INNER JOIN` returns only the rows where the join condition is met in both tables. A `LEFT JOIN` (or `LEFT OUTER JOIN`) returns all rows from the left table and the matched rows from the right table. If there is no match, the columns from the right table will have NULL values.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a self-join and why would you use it?\n<end_of_turn>\n<start_of_turn>model\nA self-join is a regular join, but the table is joined with itself. It's useful for querying hierarchical data or comparing rows within the same table. For example, finding employees who have the same manager by joining the employees table to itself on the `ManagerID` column.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are aggregate functions in SQL?\n<end_of_turn>\n<start_of_turn>model\nAggregate functions perform a calculation on a set of values and return a single, summary value. Common examples include `COUNT()` (counts rows), `SUM()` (sums values), `AVG()` (calculates average), `MAX()` (finds maximum value), and `MIN()` (finds minimum value).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `GROUP BY` clause?\n<end_of_turn>\n<start_of_turn>model\nThe `GROUP BY` clause is used with aggregate functions to group rows that have the same values in specified columns into summary rows. For example, you could use it to find the number of customers in each country.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between the `WHERE` and `HAVING` clauses?\n<end_of_turn>\n<start_of_turn>model\nThe `WHERE` clause filters rows *before* any groupings are made, operating on individual row data. The `HAVING` clause filters groups *after* the `GROUP BY` clause has been applied, operating on the results of aggregate functions.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a subquery, also known as a nested query?\n<end_of_turn>\n<start_of_turn>model\nA subquery is a query that is nested inside another SQL query, such as a `SELECT`, `INSERT`, `UPDATE`, or `DELETE` statement, or inside another subquery. It's used to return data that will be used in the main query as a condition to further restrict the data to be retrieved.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a correlated subquery?\n<end_of_turn>\n<start_of_turn>model\nA correlated subquery is a subquery that depends on the outer query for its values. It is evaluated once for each row processed by the outer query. This can be inefficient because the subquery is re-executed repeatedly.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between `UNION` and `UNION ALL`?\n<end_of_turn>\n<start_of_turn>model\n`UNION` combines the result sets of two or more `SELECT` statements and removes duplicate rows. `UNION ALL` also combines the result sets but includes all rows, including duplicates. `UNION ALL` is generally faster because it doesn't have to check for and remove duplicates.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a database index?\n<end_of_turn>\n<start_of_turn>model\nA database index is a special lookup table that the database search engine can use to speed up data retrieval. An index is a pointer to data in a table. It works like an index in the back of a book; instead of searching the whole book, you look up the topic in the index first.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy are indexes important for performance?\n<end_of_turn>\n<start_of_turn>model\nIndexes are crucial for performance because they allow the database to find data much faster. Without an index, the database would have to perform a full table scan, reading every row to find the requested data. Indexes use data structures like B-trees to locate data with significantly fewer reads.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a clustered and a non-clustered index?\n<end_of_turn>\n<start_of_turn>model\nA clustered index determines the physical order of data in a table. Because of this, a table can only have one clustered index. A non-clustered index has a separate structure from the data rows, containing pointers back to the data rows. A table can have multiple non-clustered indexes.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is normalization in the context of databases?\n<end_of_turn>\n<start_of_turn>model\nNormalization is the process of organizing columns and tables in a relational database to minimize data redundancy and improve data integrity. It involves dividing larger tables into smaller, well-structured tables and defining relationships between them.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy is normalization important?\n<end_of_turn>\n<start_of_turn>model\nNormalization is important because it reduces data redundancy, which saves storage space and prevents data anomalies (like update, insertion, and deletion anomalies). It leads to a more flexible and maintainable database design.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are the first three normal forms (1NF, 2NF, 3NF)?\n<end_of_turn>\n<start_of_turn>model\n1NF (First Normal Form) ensures that a table has no repeating groups and that each column contains atomic values. 2NF (Second Normal Form) requires the table to be in 1NF and all non-key attributes to be fully functional on the primary key. 3NF (Third Normal Form) requires the table to be in 2NF and all attributes to be dependent only on the primary key, not on other non-key attributes (no transitive dependencies).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a view in SQL?\n<end_of_turn>\n<start_of_turn>model\nA view is a virtual table based on the result-set of an SQL statement. It contains rows and columns, just like a real table, but it doesn't store the data itself. The data is generated dynamically when the view is queried.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are the advantages of using a view?\n<end_of_turn>\n<start_of_turn>model\nViews offer several advantages: they can simplify complex queries, enhance security by restricting access to certain columns or rows, and provide a consistent data structure even if the underlying source tables change.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a transaction?\n<end_of_turn>\n<start_of_turn>model\nA transaction is a sequence of operations performed as a single logical unit of work. All the operations in a transaction must succeed; otherwise, the entire transaction is rolled back, and the database is returned to its state before the transaction began.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are the ACID properties of a transaction?\n<end_of_turn>\n<start_of_turn>model\nACID properties guarantee transaction reliability. They are: Atomicity (all or nothing), Consistency (the database remains in a valid state), Isolation (concurrent transactions don't affect each other), and Durability (once a transaction is committed, its changes are permanent).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `COMMIT` and `ROLLBACK` commands?\n<end_of_turn>\n<start_of_turn>model\n`COMMIT` is used to save all the changes made during the current transaction, making them permanent. `ROLLBACK` is used to undo all the changes made in the current transaction, restoring the database to its state before the transaction started.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a stored procedure?\n<end_of_turn>\n<start_of_turn>model\nA stored procedure is a prepared SQL code that you can save, so the code can be reused over and over again. It can accept input parameters and return results. Stored procedures can improve performance, reduce network traffic, and enhance security.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between `CHAR` and `VARCHAR` data types?\n<end_of_turn>\n<start_of_turn>model\n`CHAR` is a fixed-length string data type, meaning it always reserves the specified amount of storage space, padding with spaces if needed. `VARCHAR` is a variable-length string data type, so it only uses storage space for the characters it actually holds. `VARCHAR` is generally more efficient for storing strings of varying lengths.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat does the `NULL` value represent in SQL?\n<end_of_turn>\n<start_of_turn>model\n`NULL` represents a missing or unknown value. It is not the same as a zero or an empty string. A field with a `NULL` value is one that has been left blank during record creation.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do you handle `NULL` values in calculations?\n<end_of_turn>\n<start_of_turn>model\nMost aggregate functions, like `SUM` and `AVG`, ignore `NULL` values. To handle them explicitly, you can use functions like `COALESCE` or `ISNULL` to replace `NULL` with a default value (e.g., 0) before performing the calculation.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is SQL Injection and how can it be prevented?\n<end_of_turn>\n<start_of_turn>model\nSQL Injection is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. It can be prevented primarily by using prepared statements (with parameterized queries) and by validating and sanitizing all user input.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are window functions in SQL?\n<end_of_turn>\n<start_of_turn>model\nWindow functions perform a calculation across a set of table rows that are somehow related to the current row. Unlike aggregate functions, they do not cause rows to become grouped into a single output row; the rows retain their separate identities. Examples include `ROW_NUMBER()`, `RANK()`, `LEAD()`, and `LAG()`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do window functions differ from aggregate functions?\n<end_of_turn>\n<start_of_turn>model\nThe key difference is that aggregate functions (used with `GROUP BY`) collapse multiple rows into a single summary row. Window functions operate on a 'window' of rows and return a value for *every single row* based on the calculation over that window.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a Common Table Expression (CTE)?\n<end_of_turn>\n<start_of_turn>model\nA CTE, or Common Table Expression, is a temporary, named result set that you can reference within a `SELECT`, `INSERT`, `UPDATE`, or `DELETE` statement. It is defined using the `WITH` clause and helps improve the readability and structure of complex queries.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy would you use a CTE instead of a subquery?\n<end_of_turn>\n<start_of_turn>model\nCTEs are often preferred over subqueries for readability, as they break down a complex query into logical, sequential steps. They can also be recursive, allowing you to query hierarchical data, which is not possible with standard subqueries.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `LIKE` operator?\n<end_of_turn>\n<start_of_turn>model\nThe `LIKE` operator is used in a `WHERE` clause to search for a specified pattern in a column. It uses wildcard characters: `%` represents zero or more characters, and `_` represents a single character.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between `COUNT(*)` and `COUNT(column_name)`?\n<end_of_turn>\n<start_of_turn>model\n`COUNT(*)` counts all the rows in a table, regardless of whether they contain `NULL` values. `COUNT(column_name)` counts the number of non-NULL values in that specific column.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a database schema?\n<end_of_turn>\n<start_of_turn>model\nA database schema is the blueprint or architecture of a database. It defines the tables, the fields in each table, the relationships between fields and tables, and the constraints. It is the logical structure of the entire database.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat does the `DISTINCT` keyword do?\n<end_of_turn>\n<start_of_turn>model\nThe `DISTINCT` keyword is used in a `SELECT` statement to return only unique (different) values from a specified column. It eliminates duplicate rows from the result set.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is denormalization and when is it useful?\n<end_of_turn>\n<start_of_turn>model\nDenormalization is the process of intentionally adding redundant data to a normalized database to improve query performance. It is useful in read-heavy applications, like data warehousing, where complex joins on normalized tables can be slow.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `CASE` statement used for?\n<end_of_turn>\n<start_of_turn>model\nThe `CASE` statement is used to create if-then-else logic within an SQL query. It goes through conditions and returns a value when the first condition is met. If no condition is true, it returns the value in the `ELSE` clause, or `NULL` if there is no `ELSE` part.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a constraint in SQL?\n<end_of_turn>\n<start_of_turn>model\nA constraint is a rule enforced on data columns in a table to ensure the accuracy and reliability of the data. Constraints can limit the type of data that can go into a table. Examples include `NOT NULL`, `UNIQUE`, `PRIMARY KEY`, `FOREIGN KEY`, and `CHECK`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the `CHECK` constraint.\n<end_of_turn>\n<start_of_turn>model\nThe `CHECK` constraint is used to limit the value range that can be placed in a column. If you define a `CHECK` constraint on a column, it will allow only certain values for this column, for example, ensuring that an `Age` column is always greater than 18.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do you add a comment in SQL?\n<end_of_turn>\n<start_of_turn>model\nYou can add single-line comments using two hyphens (`--`). For multi-line comments, you can use `/*` to start the comment and `*/` to end it. Comments are ignored by the SQL engine.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `AS` keyword?\n<end_of_turn>\n<start_of_turn>model\nThe `AS` keyword is used to assign an alias, or a temporary, more readable name, to a column or a table in a query result. This can make the output easier to understand and the query easier to write, especially with complex joins or calculated fields.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat does the `BETWEEN` operator do?\n<end_of_turn>\n<start_of_turn>model\nThe `BETWEEN` operator selects values within a given range. The values can be numbers, text, or dates. The `BETWEEN` operator is inclusive, meaning it includes the beginning and end values in the result.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between `IN` and `EXISTS`?\n<end_of_turn>\n<start_of_turn>model\n`IN` is used to check if a value matches any value in a provided list or subquery. `EXISTS` is used to check if a subquery returns any rows. `EXISTS` is generally more efficient when the subquery returns a large volume of data because it stops processing as soon as it finds a single matching row.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is data integrity?\n<end_of_turn>\n<start_of_turn>model\nData integrity refers to the overall accuracy, completeness, and consistency of data. In a database, data integrity is maintained through the use of constraints, transactions, and rules to ensure that the data is reliable and trustworthy.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does SQL help maintain data integrity?\n<end_of_turn>\n<start_of_turn>model\nSQL helps maintain data integrity primarily through constraints. `PRIMARY KEY` and `UNIQUE` constraints ensure entity integrity. `FOREIGN KEY` constraints ensure referential integrity. `CHECK` constraints ensure domain integrity, and `NOT NULL` ensures column completeness.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a database trigger?\n<end_of_turn>\n<start_of_turn>model\nA trigger is a special type of stored procedure that automatically runs when a specific event (like an `INSERT`, `UPDATE`, or `DELETE`) occurs in a database table. Triggers are often used to maintain data integrity or enforce complex business rules.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a function and a stored procedure?\n<end_of_turn>\n<start_of_turn>model\nA key difference is that a function must return a single value, whereas a stored procedure does not have to. Functions can be called from within a `SELECT` statement, but stored procedures cannot. Stored procedures can have both input and output parameters, while functions typically only have input parameters.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a composite primary key?\n<end_of_turn>\n<start_of_turn>model\nA composite primary key is a primary key that consists of two or more columns. It is used when a single column is not sufficient to uniquely identify a record in a table. All columns in the composite key together must be unique.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `ALTER TABLE` statement?\n<end_of_turn>\n<start_of_turn>model\nThe `ALTER TABLE` statement is a DDL command used to add, delete, or modify columns in an existing table. It can also be used to add and drop various constraints on an existing table.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a temporary table and why would you use one?\n<end_of_turn>\n<start_of_turn>model\nA temporary table is a table that is created and exists only for the duration of a database session or transaction. They are useful for storing intermediate results in a complex multi-step process, breaking down a large query into smaller, more manageable parts.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `HAVING` clause primarily used for?\n<end_of_turn>\n<start_of_turn>model\nThe `HAVING` clause is primarily used to filter the results of a query based on an aggregate function. While `WHERE` filters individual rows, `HAVING` filters entire groups of rows created by the `GROUP BY` clause.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy can't you use column aliases in a `WHERE` clause?\n<end_of_turn>\n<start_of_turn>model\nYou can't use a column alias in a `WHERE` clause because of the logical order of operations in an SQL query. The `WHERE` clause is processed before the `SELECT` clause (where the alias is defined). Therefore, the alias does not exist at the time the `WHERE` clause is evaluated.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a Cartesian product (or `CROSS JOIN`)?\n<end_of_turn>\n<start_of_turn>model\nA Cartesian product, created by a `CROSS JOIN`, is the result of joining every row from one table with every row from another table. If the first table has 'm' rows and the second has 'n' rows, the result will have 'm * n' rows. It's often an unintended result of a poorly written join without a proper `ON` condition.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `LIMIT` (or `TOP`) clause used for?\n<end_of_turn>\n<start_of_turn>model\nThe `LIMIT` (in MySQL/PostgreSQL) or `TOP` (in SQL Server) clause is used to specify the maximum number of rows to return in the result set of a query. It's often used with `ORDER BY` to get the top N records, such as the 10 most recent orders.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are DCL commands?\n<end_of_turn>\n<start_of_turn>model\nDCL, or Data Control Language, commands are used to manage permissions and control access to the database. The main DCL commands are `GRANT`, which gives users access privileges, and `REVOKE`, which withdraws them.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the `GRANT` command.\n<end_of_turn>\n<start_of_turn>model\nThe `GRANT` command is used by database administrators to give specific permissions to users or roles. For example, you can `GRANT SELECT, INSERT ON employees TO user_jane;` to allow a user named Jane to query and insert data into the employees table.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are TCL commands?\n<end_of_turn>\n<start_of_turn>model\nTCL, or Transaction Control Language, commands are used to manage transactions in the database to ensure data integrity. The core TCL commands are `COMMIT` (to save a transaction), `ROLLBACK` (to undo a transaction), and `SAVEPOINT` (to set a point within a transaction to roll back to).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `COALESCE` function used for?\n<end_of_turn>\n<start_of_turn>model\nThe `COALESCE` function is used to return the first non-NULL value in a list of expressions. It's a very useful way to substitute a default value for `NULL` values in query results. For example, `COALESCE(product_color, 'N/A')` would show 'N/A' if the color is NULL.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is casting in SQL?\n<end_of_turn>\n<start_of_turn>model\nCasting is the process of converting a value from one data type to another. The `CAST()` function is used for this purpose. For example, you might `CAST` a text string containing a date like '2025-08-25' into an actual DATE data type to perform date-based calculations.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `ALL` and `ANY` operators?\n<end_of_turn>\n<start_of_turn>model\nThe `ANY` and `ALL` operators are used with a subquery in a `WHERE` or `HAVING` clause. `ANY` returns true if any of the subquery values meet the condition. `ALL` returns true if all of the subquery values meet the condition.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a recursive CTE?\n<end_of_turn>\n<start_of_turn>model\nA recursive Common Table Expression (CTE) is a CTE that references itself. It's used for querying hierarchical data structures, like an organizational chart or a bill of materials, where you need to repeatedly process a parent-child relationship until all levels are traversed.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a table and a view?\n<end_of_turn>\n<start_of_turn>model\nA table is a physical storage structure that holds data. A view is a virtual table that does not store data itself but is defined by a query. A view's data is generated dynamically from one or more underlying tables when it is accessed.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does `DELETE` differ from `TRUNCATE` in terms of logging?\n<end_of_turn>\n<start_of_turn>model\n`DELETE` is a logged operation, meaning an entry is made in the transaction log for each deleted row. This allows it to be rolled back. `TRUNCATE` is minimally logged; it logs the deallocation of the data pages, not individual rows, which is why it's faster and cannot be rolled back.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a deadlock and how can it occur?\n<end_of_turn>\n<start_of_turn>model\nA deadlock is a situation where two or more transactions are waiting for each other to release locks, creating a circular dependency that prevents any of them from proceeding. For example, Transaction 1 locks Table A and waits for Table B, while Transaction 2 has locked Table B and is waiting for Table A.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is database concurrency?\n<end_of_turn>\n<start_of_turn>model\nConcurrency is the ability of the database management system (DBMS) to allow multiple users or processes to access and modify shared data at the same time without interfering with each other. It's managed through mechanisms like locking and transaction isolation levels.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are transaction isolation levels?\n<end_of_turn>\n<start_of_turn>model\nTransaction isolation levels are settings that control the degree to which one transaction must be isolated from the data modifications made by other concurrent transactions. Common levels, from least to most strict, are Read Uncommitted, Read Committed, Repeatable Read, and Serializable.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy would you choose `VARCHAR(max)` over `TEXT`?\n<end_of_turn>\n<start_of_turn>model\nIn modern SQL versions (like SQL Server), `VARCHAR(max)` is generally preferred over `TEXT`. `VARCHAR(max)` behaves more like regular `VARCHAR` types, allowing it to be used with standard string functions and as a variable in procedures, whereas `TEXT` has more limitations and is often deprecated.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `OFFSET` clause used for?\n<end_of_turn>\n<start_of_turn>model\nThe `OFFSET` clause is used with `ORDER BY` and `LIMIT` (or `FETCH`) to skip a specified number of rows before beginning to return rows from the query. It is essential for implementing pagination in applications, where you might want to show results 11-20, 21-30, and so on.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `EXCEPT` operator?\n<end_of_turn>\n<start_of_turn>model\nThe `EXCEPT` operator is used to combine two `SELECT` statements and returns only the rows from the first query's result set that are not present in the second query's result set. It effectively subtracts one result set from another.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `INTERSECT` operator used for?\n<end_of_turn>\n<start_of_turn>model\nThe `INTERSECT` operator combines the result sets of two `SELECT` statements and returns only the rows that appear in both result sets. It finds the common entries between the two queries.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a sequence in a database?\n<end_of_turn>\n<start_of_turn>model\nA sequence is a database object that generates a series of unique numbers. It is often used to automatically generate primary key values, providing a more flexible alternative to auto-incrementing identity columns, especially when a single sequence is needed across multiple tables.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow can you select a random row from a table?\n<end_of_turn>\n<start_of_turn>model\nThe method varies by SQL dialect. In PostgreSQL or MySQL, you can use `ORDER BY RAND()` or `ORDER BY RANDOM()` combined with `LIMIT 1`. In SQL Server, you can use `ORDER BY NEWID()` with `TOP 1`. These methods can be inefficient on large tables.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'table scan' and why is it sometimes bad for performance?\n<end_of_turn>\n<start_of_turn>model\nA table scan is when the database engine reads every single row in a table to find the data that matches the query's criteria. It's bad for performance on large tables because it's the slowest possible way to find data, analogous to reading a whole book to find one sentence instead of using the index.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow can you improve the performance of a slow SQL query?\n<end_of_turn>\n<start_of_turn>model\nSeveral methods can improve query performance: ensuring proper indexing on columns used in `WHERE` and `JOIN` clauses, rewriting the query to be more efficient, avoiding `SELECT *`, using `EXPLAIN` or a query plan analyzer to identify bottlenecks, and sometimes denormalizing data for read-heavy operations.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a query execution plan?\n<end_of_turn>\n<start_of_turn>model\nA query execution plan is the sequence of steps that the database's query optimizer generates to execute an SQL statement. It shows how the database will access tables (e.g., using an index scan vs. a full table scan) and perform joins. Analyzing the plan is key to diagnosing and fixing slow queries.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between an implicit and an explicit transaction?\n<end_of_turn>\n<start_of_turn>model\nAn explicit transaction is one that is manually started by the user with a command like `BEGIN TRANSACTION`. An implicit transaction is automatically started by the database for each individual DML statement (`INSERT`, `UPDATE`, `DELETE`) if not already inside an explicit transaction. This is often called 'autocommit' mode.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy is it a bad practice to use `SELECT *` in production code?\n<end_of_turn>\n<start_of_turn>model\nUsing `SELECT *` is bad practice for several reasons: it can retrieve more data than necessary, increasing network traffic and memory usage; it makes code less readable as the intended columns are not explicit; and it can break the application if the underlying table schema changes (e.g., a column is added or removed).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'materialized view'?\n<end_of_turn>\n<start_of_turn>model\nA materialized view is like a regular view, but it physically stores its result set as a table. Unlike a standard view, its data is not generated dynamically on each query. It must be refreshed periodically from its base tables. It is used to improve performance for very complex or frequently executed queries.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `MERGE` statement in SQL?\n<end_of_turn>\n<start_of_turn>model\nThe `MERGE` statement (also known as `UPSERT`) performs an `INSERT`, `UPDATE`, or `DELETE` operation on a target table based on the results of a join with a source table. It's a convenient way to synchronize two tables by inserting new rows, updating existing ones, and optionally deleting rows that don't match.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a candidate key?\n<end_of_turn>\n<start_of_turn>model\nA candidate key is a column, or a set of columns, in a table that can uniquely identify each row in that table. A table can have multiple candidate keys. One of these candidate keys is chosen to be the table's primary key.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is an alternate key?\n<end_of_turn>\n<start_of_turn>model\nAn alternate key is any candidate key that was not chosen to be the primary key. These keys are often given a `UNIQUE` constraint to ensure they also uniquely identify rows.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of a savepoint in a transaction?\n<end_of_turn>\n<start_of_turn>model\nA savepoint is a marker within a transaction that allows you to selectively roll back part of the transaction to that marker, rather than rolling back the entire transaction. This gives you finer control over complex, multi-step transactions.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow would you find the Nth highest value in a column?\n<end_of_turn>\n<start_of_turn>model\nA common way is to use window functions like `DENSE_RANK()`. You can partition the data if needed, order it by the desired column in descending order, and then select the row where the rank is equal to N. Another method involves using `LIMIT` and `OFFSET` on a sorted distinct list of values.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy is it important to define data types correctly for columns?\n<end_of_turn>\n<start_of_turn>model\nDefining data types correctly is crucial for data integrity and storage efficiency. It ensures that only valid data is stored (e.g., preventing text in a date column), uses the optimal amount of storage space, and allows the database to perform calculations and comparisons correctly and efficiently.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a global and a local temporary table?\n<end_of_turn>\n<start_of_turn>model\nThis concept is specific to some DBMS like SQL Server. A local temporary table (e.g., `#MyTempTable`) is visible only to the current user session that created it and is dropped automatically when the session ends. A global temporary table (e.g., `##MyGlobalTempTable`) is visible to all user sessions and is dropped when the last session referencing it disconnects.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are cascading constraints?\n<end_of_turn>\n<start_of_turn>model\nCascading constraints are rules defined on a foreign key relationship. For example, `ON DELETE CASCADE` specifies that if a row in the parent table is deleted, all corresponding rows in the child table should also be automatically deleted. This helps maintain referential integrity automatically.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `PIVOT` operator used for?\n<end_of_turn>\n<start_of_turn>model\nThe `PIVOT` operator is used to transform data from a row-level orientation to a columnar orientation. It rotates rows into columns, effectively turning unique values from one column in the expression into multiple columns in the output, and performs aggregations where required.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `UNPIVOT` operator used for?\n<end_of_turn>\n<start_of_turn>model\n`UNPIVOT` is the reverse of `PIVOT`. It transforms data from a columnar orientation back to a row-level orientation, rotating columns into rows. This is useful when you have data stored in a wide format and need to convert it to a normalized, narrow format.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'dirty read'?\n<end_of_turn>\n<start_of_turn>model\nA dirty read is a phenomenon that can occur in concurrent transactions when one transaction is allowed to read data that has been modified by another transaction but has not yet been committed. This is risky because the modifying transaction might be rolled back, leaving the first transaction with invalid, 'dirty' data. It is prevented by higher transaction isolation levels.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'phantom read'?\n<end_of_turn>\n<start_of_turn>model\nA phantom read occurs when, within the course of a single transaction, a row is read twice, and the set of rows returned by the second read is different from the first. This happens when another transaction inserts a new row that matches the `WHERE` clause of the first transaction. The `SERIALIZABLE` isolation level prevents phantom reads.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a surrogate key?\n<end_of_turn>\n<start_of_turn>model\nA surrogate key is an artificially generated key, typically an integer, with no business or real-world meaning. It is used as the primary key solely for the purpose of uniquely identifying a record. Using surrogate keys (like an `AutoIncrement` ID) is a common database design practice as they are stable and simple.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a natural key?\n<end_of_turn>\n<start_of_turn>model\nA natural key is a primary key that is formed from attributes that already exist in the real world and have a logical relationship to the entity being modeled. For example, using a country's two-letter ISO code as the primary key for a `Countries` table would be a natural key.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy might a surrogate key be preferred over a natural key?\n<end_of_turn>\n<start_of_turn>model\nSurrogate keys are often preferred because they are stable; a natural key might change (e.g., a person's name, a company's name), which would cause a cascading update nightmare if it were a primary key. Surrogate keys are also simple, usually numeric, which can lead to better join performance than wide, complex natural keys.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat does it mean for a query to be 'SARGable'?\n<end_of_turn>\n<start_of_turn>model\nA query is 'SARGable' (Search ARGument-able) if the database engine can take advantage of an index to speed up the execution of the query. Conditions in the `WHERE` clause are SARGable if they don't have a function applied to the indexed column itself, allowing the engine to seek directly to the relevant data in the index.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `LEAD()` window function used for?\n<end_of_turn>\n<start_of_turn>model\nThe `LEAD()` window function is used to access data from a subsequent row in the same result set without the need for a self-join. It is useful for calculating the difference between the current row's value and the next row's value, for example, to find the time elapsed between consecutive events.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `LAG()` window function used for?\n<end_of_turn>\n<start_of_turn>model\nThe `LAG()` window function is the opposite of `LEAD()`. It is used to access data from a previous row in the same result set. It is useful for comparing the value of the current row with the value of the previous row, for instance, to calculate period-over-period growth.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `ROW_NUMBER()` window function used for?\n<end_of_turn>\n<start_of_turn>model\nThe `ROW_NUMBER()` window function assigns a unique sequential integer to each row within a partition of a result set. The first row in each partition is assigned 1. It is commonly used for tasks like ranking, deduplication, or pagination.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between `RANK()` and `DENSE_RANK()`?\n<end_of_turn>\n<start_of_turn>model\n`RANK()` and `DENSE_RANK()` are both window functions used for ranking. If there is a tie in values, `RANK()` will assign the same rank to the tied rows and then skip the next rank(s). `DENSE_RANK()` will also assign the same rank to tied rows, but it will not skip any ranks in the sequence. For values (10, 20, 20, 30), `RANK()` would be (1, 2, 2, 4) while `DENSE_RANK()` would be (1, 2, 2, 3).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `NTILE(n)` window function used for?\n<end_of_turn>\n<start_of_turn>model\nThe `NTILE(n)` window function distributes the rows in an ordered partition into a specified number of ranked groups, or 'tiles'. For example, `NTILE(4)` would divide the data into quartiles, assigning a bucket number from 1 to 4 to each row.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does SQL handle division by zero?\n<end_of_turn>\n<start_of_turn>model\nAttempting to divide a number by zero in SQL will result in a runtime error, which will typically terminate the query. To avoid this, you should check for zero in the denominator before performing the division, often using a `CASE` statement or a `NULLIF` function, like `numerator / NULLIF(denominator, 0)`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `GROUPING SETS` clause?\n<end_of_turn>\n<start_of_turn>model\n`GROUPING SETS` is an extension of the `GROUP BY` clause that allows you to define multiple grouping sets in a single query. This is more efficient than writing multiple `GROUP BY` queries and combining them with `UNION ALL`, as it allows the database to aggregate the data in a single pass.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a heap and a clustered table?\n<end_of_turn>\n<start_of_turn>model\nA table with a clustered index is a clustered table; its rows are stored physically on disk in the order of the clustered index key. A table without a clustered index is called a heap. Its data rows are not stored in any particular order. Data is simply added to the first available space.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is index fragmentation?\n<end_of_turn>\n<start_of_turn>model\nIndex fragmentation occurs when the logical ordering of pages in an index does not match the physical ordering on the disk, or when there is a lot of empty space on the index pages. It can degrade query performance because it requires more I/O operations to read the index. Indexes often need to be rebuilt or reorganized to fix fragmentation.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `LIKE` operator's escape character used for?\n<end_of_turn>\n<start_of_turn>model\nThe escape character is used within a `LIKE` pattern to search for the wildcard characters themselves (`%` or `_`). For example, to find all items with '50%' in their name, you would write `WHERE name LIKE '%50\\%%' ESCAPE '\\'`, where `\\` is defined as the escape character.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a database collation?\n<end_of_turn>\n<start_of_turn>model\nA collation is a set of rules that determines how data is sorted and compared. It specifies properties like case sensitivity (e.g., is 'a' equal to 'A'?), accent sensitivity, and the character set to use. Collation settings can be defined at the server, database, or column level.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a full-text index?\n<end_of_turn>\n<start_of_turn>model\nA full-text index is a special type of index that provides more powerful and flexible searching capabilities for character-based data than the basic `LIKE` operator. It allows for linguistic searches, such as finding words and phrases, proximity searches, and different forms of a word (e.g., searching for 'run' finds 'ran' and 'running').\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy is it generally not recommended to perform complex calculations in the `WHERE` clause?\n<end_of_turn>\n<start_of_turn>model\nPerforming complex calculations, especially applying functions to a column (e.g., `WHERE YEAR(order_date) = 2025`), can make the query non-SARGable. This prevents the database from using an index on that column, forcing a table scan and leading to poor performance. It's better to rewrite the condition to be index-friendly (e.g., `WHERE order_date >= '2025-01-01' AND order_date < '2026-01-01'`).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `HAVING COUNT(*) > 1` clause?\n<end_of_turn>\n<start_of_turn>model\nThis clause is commonly used to find duplicate values in a table. When used after a `GROUP BY` on one or more columns, `HAVING COUNT(*) > 1` filters the results to show only those groups that contain more than one row, which indicates that the combination of values in the grouped columns is duplicated.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is an ORM (Object-Relational Mapping)?\n<end_of_turn>\n<start_of_turn>model\nAn ORM is a programming technique that converts data between incompatible type systems in object-oriented programming languages and relational databases. It generates a 'virtual object database' that can be used from within the programming language, allowing developers to write database queries using the syntax of their language (like Python or Java) instead of writing raw SQL.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are some advantages of using an ORM?\n<end_of_turn>\n<start_of_turn>model\nAdvantages include faster development time (less boilerplate SQL), database independence (easier to switch from MySQL to PostgreSQL), and taking advantage of object-oriented features like inheritance and polymorphism. It abstracts away the database, letting developers think in terms of objects.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are some disadvantages of using an ORM?\n<end_of_turn>\n<start_of_turn>model\nDisadvantages can include a steep learning curve, potential performance overhead due to the abstraction layer, and difficulty in generating highly optimized or complex SQL queries. Developers can lose touch with the underlying database and SQL, which can make debugging performance issues harder.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'many-to-many' relationship and how is it implemented?\n<end_of_turn>\n<start_of_turn>model\nA many-to-many relationship exists when one record in Table A can be linked to many records in Table B, and one record in Table B can also be linked to many records in Table A. This is implemented using a third table, called a junction or linking table, which contains foreign keys that reference the primary keys of both Table A and Table B.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `ISNULL()` or `IFNULL()` function?\n<end_of_turn>\n<start_of_turn>model\n`ISNULL()` (in SQL Server) or `IFNULL()` (in MySQL) are functions used to handle NULL values. They check if an expression is NULL and, if it is, return a specified replacement value. This is a common way to provide default values in query results.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the main purpose of the SQL `WITH` clause?\n<end_of_turn>\n<start_of_turn>model\nThe main purpose of the `WITH` clause is to define one or more Common Table Expressions (CTEs). It helps to break down complex queries into simpler, more readable logical blocks. This improves maintainability and allows for features like recursion, which are not possible with standard derived tables or subqueries.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'covering index'?\n<end_of_turn>\n<start_of_turn>model\nA covering index is an index that includes all the columns required to satisfy a particular query, including those in the `SELECT` list, `WHERE` clause, and `JOIN` conditions. When a query uses a covering index, the database can answer the query by reading the index alone, without having to access the table data itself. This is highly efficient.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do you handle character encoding issues like UTF-8 in a database?\n<end_of_turn>\n<start_of_turn>model\nCharacter encoding is handled by setting the character set and collation at the database or table/column level. For international data, it's standard practice to use a universal encoding like UTF-8 (or `NVARCHAR` data types in SQL Server) to ensure that characters from all languages can be stored and retrieved correctly without corruption.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `SOUNDEX` function used for?\n<end_of_turn>\n<start_of_turn>model\n`SOUNDEX` is a phonetic algorithm for indexing names by their sound, as pronounced in English. The `SOUNDEX` function converts a string into a four-character code that represents its phonetic sound. It's useful for finding records that sound similar but may be spelled differently, like 'Smith' and 'Smyth'.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a `FULL OUTER JOIN` and a `CROSS JOIN`?\n<end_of_turn>\n<start_of_turn>model\nA `FULL OUTER JOIN` combines the results of both `LEFT` and `RIGHT` joins. It returns all rows from both tables, matching them where possible and filling in with `NULL`s where no match exists. A `CROSS JOIN` produces a Cartesian product, combining every row from the first table with every row from the second table, without any matching condition.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is 'index selectivity'?\n<end_of_turn>\n<start_of_turn>model\nIndex selectivity refers to the ratio of unique values in an indexed column to the total number of rows in the table. An index with high selectivity (e.g., a primary key) is very effective because it can narrow down the search to a very small number of rows quickly. An index on a column with low selectivity (e.g., a gender column with only two values) is much less effective.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat does a `FOREIGN KEY` with `ON UPDATE CASCADE` do?\n<end_of_turn>\n<start_of_turn>model\nWhen a foreign key constraint is defined with `ON UPDATE CASCADE`, it means that if the primary key value of a record in the parent table is updated, the corresponding foreign key values in all matching records in the child table will be automatically updated as well to maintain referential integrity.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy would you use a `UNIQUE` constraint instead of just a non-clustered index?\n<end_of_turn>\n<start_of_turn>model\nWhile both can enforce uniqueness, a `UNIQUE` constraint is a data integrity tool that clearly states a business rule: this value must be unique. An index is a performance tool. Although a unique index is created to enforce the constraint, the primary purpose is to guarantee data correctness, not just to speed up queries.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `EXPLAIN` command and why is it useful?\n<end_of_turn>\n<start_of_turn>model\nThe `EXPLAIN` command (or similar commands like `EXPLAIN PLAN` or `SHOWPLAN`) is a tool that shows the query execution plan chosen by the database's query optimizer. It's extremely useful for performance tuning because it reveals how the database intends to execute a query, such as which tables will be scanned, which indexes will be used, and the order of joins.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `DEFAULT` constraint?\n<end_of_turn>\n<start_of_turn>model\nThe `DEFAULT` constraint is used to provide a default value for a column when no value is specified during an `INSERT` operation. This ensures that the column will always have a value, preventing it from being `NULL` if that's not desired.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCan you perform a `JOIN` on columns with different data types?\n<end_of_turn>\n<start_of_turn>model\nIt is generally not possible or highly inadvisable to join columns with incompatible data types directly. Doing so may result in an error or force the database to perform an implicit data type conversion, which can be very inefficient and prevent the use of indexes. Columns in a join condition should ideally have the same data type.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `ALL` keyword used for in a `UNION` query?\n<end_of_turn>\n<start_of_turn>model\nIn the context of `UNION`, the `ALL` keyword specifies that the result set should include all rows from all `SELECT` statements being combined, including any duplicate rows. If `ALL` is omitted, the default behavior of `UNION` is to remove all duplicate rows, which requires an extra sorting and filtering step.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow would you handle finding the median value in a column?\n<end_of_turn>\n<start_of_turn>model\nSQL does not have a standard built-in `MEDIAN()` aggregate function like it does for `AVG()` or `SUM()`. Finding the median typically requires a more complex query using window functions like `ROW_NUMBER()` and `COUNT()` to find the middle row(s) in an ordered set, or using specific functions provided by some database systems, like `PERCENTILE_CONT`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of database replication?\n<end_of_turn>\n<start_of_turn>model\nDatabase replication is the process of copying and distributing data from a primary database (master) to one or more secondary databases (replicas or slaves). Its main purposes are to improve data availability and reliability (by providing failover copies), and to scale read operations by directing queries to the replicas, thus reducing the load on the master.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is database sharding?\n<end_of_turn>\n<start_of_turn>model\nSharding is a type of database partitioning that separates a very large database into smaller, faster, more manageable parts called shards. Each shard is a separate database, often on a different physical server. Sharding is a horizontal scaling strategy used to distribute the load and storage for massive datasets that cannot be handled by a single server.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between replication and sharding?\n<end_of_turn>\n<start_of_turn>model\nReplication involves creating full copies of the entire database to improve availability and read performance. All replicas have the same data. Sharding involves splitting the data across multiple databases (shards), with each shard containing only a subset of the total data. Sharding is used to scale both read and write operations for extremely large datasets.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `MINUS` operator?\n<end_of_turn>\n<start_of_turn>model\nThe `MINUS` operator, used in some SQL dialects like Oracle, is functionally identical to the `EXCEPT` operator. It takes the distinct rows from the first `SELECT` statement and returns the rows that do not appear in the second `SELECT` statement's result set.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow can you create a new table based on the structure and data of an existing table?\n<end_of_turn>\n<start_of_turn>model\nA common way to do this is with the `CREATE TABLE ... AS SELECT ...` syntax (or `SELECT ... INTO ...` in SQL Server). For example, `CREATE TABLE new_table AS SELECT * FROM old_table;` will create `new_table` with the same columns and data as `old_table`. To copy only the structure, you can add a `WHERE` clause that is always false, like `WHERE 1=0`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the 'cardinality' of a table or column?\n<end_of_turn>\n<start_of_turn>model\nIn database terms, cardinality refers to the uniqueness of data values contained in a column. High cardinality means there are many unique values (like a primary key column). Low cardinality means a column has very few unique values (like a status column with values 'Active' and 'Inactive'). The cardinality of a table is simply the number of rows it contains.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'correlated update'?\n<end_of_turn>\n<start_of_turn>model\nA correlated update is an `UPDATE` statement that uses a subquery that refers to the table being updated. It allows you to update rows in a table based on values from other rows in the same table or from a related table. The syntax often involves referencing the outer table's columns from within a `SET` clause's subquery.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy is it important for a database to have a recovery model?\n<end_of_turn>\n<start_of_turn>model\nA recovery model is a database setting that controls how transactions are logged and what backup and restore options are available. It's crucial for disaster recovery. A full recovery model, for example, logs all transactions and allows for point-in-time recovery, ensuring minimal data loss in case of a failure.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'fill factor' for an index?\n<end_of_turn>\n<start_of_turn>model\nThe fill factor is a setting that determines the percentage of space on each leaf-level page of an index that is filled with data when the index is created or rebuilt. Leaving some free space (a fill factor less than 100%) helps reduce page splits and fragmentation when new data is inserted, which can improve write performance.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does a `FULLTEXT` search differ from using `LIKE`?\n<end_of_turn>\n<start_of_turn>model\nA `LIKE` search performs simple pattern matching, which can be slow and inflexible as it scans strings for characters. A `FULLTEXT` search uses a pre-built index and operates on words and phrases. It understands linguistics (e.g., word stems) and can perform more complex searches, like proximity and relevance ranking, making it far more powerful and efficient for searching through large blocks of text.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a NoSQL database, and how does it differ from a SQL database?\n<end_of_turn>\n<start_of_turn>model\nA NoSQL database is a database that does not use the traditional relational (table-based) model of SQL databases. They come in various types (document, key-value, column-family, graph). The main differences are that NoSQL databases are typically schema-less, favor horizontal scalability, and often have a more relaxed consistency model compared to the strict ACID properties of SQL databases.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy would you choose a NoSQL database over a SQL database?\n<end_of_turn>\n<start_of_turn>model\nYou might choose a NoSQL database for applications with very large datasets, high traffic that requires horizontal scaling, or when dealing with unstructured or semi-structured data. They offer greater flexibility in data models and are often better suited for rapid development and agile environments where schema changes are frequent.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are some common SQL anti-patterns to avoid?\n<end_of_turn>\n<start_of_turn>model\nCommon anti-patterns include: using `SELECT *`, storing comma-separated lists in a single column (violates 1NF), performing queries inside a loop (N+1 problem), using `LIKE` with a leading wildcard (`%text`) which prevents index usage, and not using transactions for multi-statement logical operations.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the N+1 query problem?\n<end_of_turn>\n<start_of_turn>model\nThe N+1 query problem is a common performance issue that occurs when an application makes one initial query to retrieve a list of items (the '1' query), and then makes an additional query for each of those items to fetch related details (the 'N' queries). This results in a large number of inefficient, round-trip database calls. It can often be solved by using a `JOIN` to fetch all the necessary data in a single query.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of SQL's `IS` operator, as in `IS NULL`?\n<end_of_turn>\n<start_of_turn>model\nThe `IS` operator is used specifically for comparisons with `NULL`. You cannot use standard comparison operators like `=` or `!=` with `NULL` because `NULL` represents an unknown value, so a comparison to it is also unknown. The correct way to check if a value is null is `column_name IS NULL`, and to check if it's not null is `column_name IS NOT NULL`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'derived table'?\n<end_of_turn>\n<start_of_turn>model\nA derived table is a result set that is generated from a subquery in the `FROM` clause of a `SELECT` statement. It acts as a virtual table that exists only for the duration of the query. You must give a derived table an alias. For example: `SELECT * FROM (SELECT column1 FROM my_table) AS derived_table;`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does the database engine process a typical `SELECT` query logically?\n<end_of_turn>\n<start_of_turn>model\nThe logical processing order of a `SELECT` query is generally: 1. `FROM` (and `JOINs`), 2. `WHERE`, 3. `GROUP BY`, 4. `HAVING`, 5. `SELECT` (including window functions), 6. `DISTINCT`, 7. `ORDER BY`, and finally 8. `LIMIT` / `TOP`. This order is important for understanding why, for example, you can't use a column alias from the `SELECT` list in the `WHERE` clause.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a query cost in the context of a query optimizer?\n<end_of_turn>\n<start_of_turn>model\nA query cost is an arbitrary number estimated by the query optimizer to represent the total resources required to execute a query plan. It's calculated based on factors like CPU usage, I/O operations, and memory. The optimizer chooses the execution plan with the lowest estimated cost.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are database statistics and why are they vital for performance?\n<end_of_turn>\n<start_of_turn>model\nDatabase statistics are metadata that describe the distribution of data within columns and indexes. They include information like histograms, density, and the number of distinct values. The query optimizer relies heavily on these statistics to accurately estimate query costs and choose the most efficient execution plan.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is parameter sniffing?\n<end_of_turn>\n<start_of_turn>model\nParameter sniffing is a behavior in some database systems (like SQL Server) where the query optimizer 'sniffs' the parameter values used during the first compilation of a stored procedure and creates an execution plan optimized for those specific values. This can cause poor performance if subsequent calls use different, less typical parameter values.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the difference between a Hash Join and a Nested Loop Join.\n<end_of_turn>\n<start_of_turn>model\nA Nested Loop Join iterates through every row of the outer table and, for each row, scans the inner table to find matches. It's efficient for small datasets. A Hash Join builds an in-memory hash table from the smaller of the two tables and then probes it with rows from the larger table. It's generally much more efficient for large, unsorted datasets.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a Merge Join and when is it most effective?\n<end_of_turn>\n<start_of_turn>model\nA Merge Join requires both input tables to be sorted on the join key. It then reads a row from each table and compares them, advancing through both tables simultaneously. It's extremely efficient when both inputs are already sorted, but can be expensive if the database has to perform explicit sort operations first.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a predicate in a SQL query?\n<end_of_turn>\n<start_of_turn>model\nA predicate is a condition in a query that evaluates to TRUE, FALSE, or UNKNOWN. Predicates are typically found in the `WHERE` clause or `ON` clause of a join. For example, in `WHERE price > 100`, the expression `price > 100` is the predicate.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is predicate pushdown?\n<end_of_turn>\n<start_of_turn>model\nPredicate pushdown is a query optimization technique where the database engine applies filtering conditions (predicates) as early as possible in the query execution plan. This reduces the amount of data that needs to be processed in later stages (like joins or aggregations), significantly improving performance.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are included columns in a non-clustered index?\n<end_of_turn>\n<start_of_turn>model\nIncluded columns are non-key columns that are stored at the leaf level of a non-clustered index. This allows you to create a 'covering index' that satisfies a query without adding the columns to the index key itself, which can be useful for wider columns that aren't used for searching but are needed in the `SELECT` list.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a filtered index and why is it useful?\n<end_of_turn>\n<start_of_turn>model\nA filtered index is a non-clustered index that includes a `WHERE` clause, meaning it only contains entries for rows that meet a specific condition. It's useful for improving performance and reducing storage costs for queries that frequently filter on a well-defined subset of data (e.g., indexing only the 'Active' users in a large user table).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does horizontal partitioning work?\n<end_of_turn>\n<start_of_turn>model\nHorizontal partitioning, or sharding, involves dividing a table into multiple smaller tables (partitions) based on a partition key. Each partition contains the same columns but a different subset of rows. For example, a sales table could be partitioned by year, with all 2024 sales in one partition and 2025 sales in another. This can improve query performance by allowing the engine to scan only relevant partitions.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is vertical partitioning?\n<end_of_turn>\n<start_of_turn>model\nVertical partitioning involves dividing a table into multiple tables, where each new table contains some of the original columns and the primary key. It's used to separate frequently accessed columns from less frequently accessed or wide columns (like BLOBs or long text), which can improve I/O performance.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a data warehouse?\n<end_of_turn>\n<start_of_turn>model\nA data warehouse is a large, centralized repository of integrated data from one or more disparate sources. It's designed specifically for querying and analysis (OLAP), rather than for transaction processing (OLTP). Data warehouses store historical data to support business intelligence activities.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between OLTP and OLAP?\n<end_of_turn>\n<start_of_turn>model\nOLTP (Online Transaction Processing) systems are designed for a large number of short, fast transactions, like inserting or updating records (e.g., an e-commerce checkout). OLAP (Online Analytical Processing) systems are designed for a low volume of complex queries that analyze large amounts of historical data (e.g., analyzing sales trends over the last five years).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a Star Schema in data warehousing?\n<end_of_turn>\n<start_of_turn>model\nA star schema is a common data modeling structure for data warehouses. It consists of a central 'fact' table containing quantitative data (the measures) surrounded by smaller 'dimension' tables containing descriptive attributes. It's called a star schema because the diagram resembles a star.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a Snowflake Schema?\n<end_of_turn>\n<start_of_turn>model\nA snowflake schema is an extension of a star schema where the dimension tables are normalized into multiple related tables. This reduces data redundancy but increases the number of joins required to answer a query, making it more complex than a star schema.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a Fact table in a data warehouse?\n<end_of_turn>\n<start_of_turn>model\nA fact table is the central table in a star schema that contains the quantitative measurements or 'facts' of a business process. It primarily consists of foreign keys to the surrounding dimension tables and numeric columns called measures (e.g., `SalesAmount`, `QuantitySold`).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are Dimension tables?\n<end_of_turn>\n<start_of_turn>model\nDimension tables are companions to a fact table in a star schema. They contain descriptive, categorical attributes (the 'dimensions') used to slice and dice the data, such as `ProductCategory`, `CustomerName`, or `StoreLocation`. They provide the context for the facts.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are Slowly Changing Dimensions (SCDs)?\n<end_of_turn>\n<start_of_turn>model\nSlowly Changing Dimensions are dimensions that contain attributes that may change over time, such as a customer's address or a product's price. There are several techniques (SCD Types) for handling these changes to maintain historical accuracy in a data warehouse.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain SCD Type 1.\n<end_of_turn>\n<start_of_turn>model\nIn SCD Type 1, the old value of an attribute is simply overwritten with the new value. No historical record of the previous value is kept. This is the simplest approach but results in a loss of historical data.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain SCD Type 2.\n<end_of_turn>\n<start_of_turn>model\nIn SCD Type 2, a new row is added to the dimension table to represent the new version of the dimension member. This new row gets a new surrogate primary key. Columns are often added to indicate the version, effective start date, and effective end date of each row. This method preserves the full history.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a columnar database and why is it fast for analytics?\n<end_of_turn>\n<start_of_turn>model\nA columnar database stores data by column rather than by row. This is extremely efficient for analytical (OLAP) queries because a query typically only needs to access a few columns from a table. The database can read just the required columns, ignoring the rest, which drastically reduces I/O. Columnar storage also allows for much better data compression.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is MVCC (Multi-Version Concurrency Control)?\n<end_of_turn>\n<start_of_turn>model\nMVCC is a concurrency control method used by databases like PostgreSQL and Oracle. Instead of using locks for read operations, MVCC maintains multiple versions of a data row. When a transaction reads data, it sees a consistent snapshot of the database at a specific point in time, allowing readers and writers to not block each other, which improves concurrency.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is Write-Ahead Logging (WAL)?\n<end_of_turn>\n<start_of_turn>model\nWrite-Ahead Logging is a standard approach to achieving atomicity and durability in databases. The principle is that all modifications are first written to a log file on stable storage *before* they are applied to the database itself. This ensures that if the system crashes, the log can be used to recover the database to a consistent state by replaying committed transactions and undoing uncommitted ones.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a lock escalation?\n<end_of_turn>\n<start_of_turn>model\nLock escalation is the process of converting many fine-grained locks (like row-level locks) into a single coarse-grained lock (like a table-level lock). This is done by the database system to reduce memory overhead, as managing thousands of individual locks can be resource-intensive. However, it can also reduce concurrency.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a shared lock and an exclusive lock?\n<end_of_turn>\n<start_of_turn>model\nA shared lock (S-lock) is used for read operations. Multiple transactions can hold a shared lock on the same resource simultaneously. An exclusive lock (X-lock) is used for write operations (`UPDATE`, `DELETE`). Only one transaction can hold an exclusive lock on a resource at a time, and it prevents any other transaction from acquiring any type of lock on it.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is dynamic SQL and what is its main risk?\n<end_of_turn>\n<start_of_turn>model\nDynamic SQL is SQL code that is generated and executed at runtime as a string. It's useful for creating flexible queries where the structure is not known in advance. Its main risk is SQL Injection, where a malicious user can inject harmful SQL code into the dynamically generated string if user input is not properly sanitized.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is Row-Level Security (RLS)?\n<end_of_turn>\n<start_of_turn>model\nRow-Level Security is a security feature that allows a database administrator to control which users can access which rows in a table. The logic is implemented through security policies, which act as a transparent `WHERE` clause applied to every query against the table, filtering rows based on user identity or role.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is data masking?\n<end_of_turn>\n<start_of_turn>model\nData masking is a technique used to obscure sensitive data by replacing it with realistic but fictional data. For example, a credit card number might be masked to show only the last four digits (`XXXX-XXXX-XXXX-1234`). It's used to protect sensitive data in non-production environments like testing or development.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `ROLLUP` operator in a `GROUP BY` clause?\n<end_of_turn>\n<start_of_turn>model\nThe `ROLLUP` operator is an extension to `GROUP BY` that produces a result set containing subtotals and grand totals. It creates a hierarchy of groupings, from the most detailed level up to a grand total. For `GROUP BY ROLLUP(A, B)`, it generates groupings for (A, B), (A), and a grand total ().\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `CUBE` operator in a `GROUP BY` clause?\n<end_of_turn>\n<start_of_turn>model\nThe `CUBE` operator is an extension to `GROUP BY` that produces a result set containing all possible combinations of subtotals for the specified columns. For `GROUP BY CUBE(A, B)`, it generates groupings for (A, B), (A), (B), and a grand total (), providing a more comprehensive summary than `ROLLUP`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a semi-join?\n<end_of_turn>\n<start_of_turn>model\nA semi-join is a type of join that returns rows from the first table where one or more matches are found in the second table, but it only returns the columns from the first table and does not duplicate rows if multiple matches are found. It's typically implemented using `EXISTS` or `IN` with a subquery.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is an anti-join?\n<end_of_turn>\n<start_of_turn>model\nAn anti-join is the opposite of a semi-join. It returns rows from the first table for which *no* matches are found in the second table. It's used to find what's missing between two sets and is typically implemented using `NOT EXISTS` or `NOT IN`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `APPLY` operator (in SQL Server)?\n<end_of_turn>\n<start_of_turn>model\nThe `APPLY` operator allows you to invoke a table-valued function for each row returned by an outer table expression. `CROSS APPLY` acts like an `INNER JOIN`, returning only rows from the outer table that produce a result from the function. `OUTER APPLY` acts like a `LEFT JOIN`, returning all rows from the outer table, even if the function returns an empty set.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a `LATERAL` join?\n<end_of_turn>\n<start_of_turn>model\nA `LATERAL` join, part of the SQL standard and used in systems like PostgreSQL, is similar to the `APPLY` operator. It allows a subquery in the `FROM` clause to reference columns from a preceding table in the same `FROM` clause. This enables complex, row-by-row subqueries that are not possible with standard derived tables.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `FIRST_VALUE` window function?\n<end_of_turn>\n<start_of_turn>model\nThe `FIRST_VALUE` window function returns the value of a specified expression with respect to the first row in the window frame. It allows you to access the first value of a partition from any row within that partition.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `LAST_VALUE` window function?\n<end_of_turn>\n<start_of_turn>model\nThe `LAST_VALUE` window function returns the value of a specified expression with respect to the last row in the window frame. To get the last value of the entire partition, you typically need to define a window frame that extends to the end, such as `ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the difference between `DECIMAL`/`NUMERIC` and `FLOAT`/`REAL` data types.\n<end_of_turn>\n<start_of_turn>model\n`DECIMAL` and `NUMERIC` are fixed-point data types that store exact numeric values, making them ideal for financial calculations where precision is critical. `FLOAT` and `REAL` are approximate-value, floating-point data types that can store a wider range of numbers but may introduce small rounding errors, making them unsuitable for exact monetary calculations.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a database audit?\n<end_of_turn>\n<start_of_turn>model\nA database audit is the process of tracking and logging specific events that occur on a database, such as logins, data modifications (`INSERT`, `UPDATE`, `DELETE`), or schema changes. Auditing is essential for security, compliance, and investigating suspicious activity.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a database snapshot?\n<end_of_turn>\n<start_of_turn>model\nA database snapshot is a read-only, static view of a source database as it existed at a specific moment in time. It's created almost instantly and uses a copy-on-write mechanism, so it initially consumes very little disk space. Snapshots are useful for reporting or for creating a safe point to revert to before a major data update.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does role-based access control (RBAC) work in a database?\n<end_of_turn>\n<start_of_turn>model\nIn RBAC, instead of granting permissions directly to individual users, permissions are granted to a 'role'. Users are then assigned to one or more roles. This simplifies security management, as you only need to modify the permissions of the role, and all users assigned to that role will automatically inherit the changes.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `TRY...CATCH` block in T-SQL?\n<end_of_turn>\n<start_of_turn>model\nThe `TRY...CATCH` block is a structured error-handling mechanism in Transact-SQL (SQL Server). You place the SQL statements you want to execute in the `TRY` block. If an error occurs within that block, control is immediately passed to the `CATCH` block, where you can handle the error, log it, or perform cleanup actions without crashing the entire script.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'deferred' constraint?\n<end_of_turn>\n<start_of_turn>model\nA deferred constraint is a constraint whose checking is postponed until the end of the transaction (`COMMIT`). This is useful for complex operations where the data might be temporarily in an invalid state mid-transaction but will be consistent by the end. For example, swapping the primary key values of two rows would violate the constraint temporarily.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat does the `ON DELETE SET NULL` foreign key action do?\n<end_of_turn>\n<start_of_turn>model\nWhen a foreign key is defined with `ON DELETE SET NULL`, if a row in the parent (referenced) table is deleted, the corresponding foreign key column(s) in the child (referencing) table will be automatically set to `NULL`. This preserves the child records while severing the link to the now-deleted parent.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between `SUBSTRING` and `SUBSTR`?\n<end_of_turn>\n<start_of_turn>model\nFunctionally, they often do the same thing: extract a part of a string. `SUBSTRING` is the standard SQL function. `SUBSTR` is a common alias or variant used in specific database systems like Oracle. The syntax and parameter order are usually identical.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does the `CHARINDEX` or `POSITION` function work?\n<end_of_turn>\n<start_of_turn>model\n`CHARINDEX` (in SQL Server) or `POSITION` (in standard SQL and PostgreSQL) are functions used to find the starting position of a substring within a larger string. They return an integer representing the starting index of the first occurrence, or 0 if the substring is not found.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between `GETDATE()` and `SYSDATETIME()` in SQL Server?\n<end_of_turn>\n<start_of_turn>model\nBoth functions return the current date and time of the database server. However, `SYSDATETIME()` returns a `datetime2(7)` value, which has a higher fractional second precision and accuracy than the older `GETDATE()` function, which returns a `datetime` value.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `EXTRACT` function in SQL?\n<end_of_turn>\n<start_of_turn>model\nThe standard SQL `EXTRACT` function is used to retrieve a specific part (like `YEAR`, `MONTH`, `DAY`, `HOUR`) from a date or timestamp value. For example, `EXTRACT(YEAR FROM order_date)` would return just the year portion of the date.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'foreign data wrapper' (FDW)?\n<end_of_turn>\n<start_of_turn>model\nA foreign data wrapper, a feature prominent in PostgreSQL, is an extension that allows you to treat a remote data source (like another database, a CSV file, or a web service) as if it were a local table. It enables you to query and join data from disparate systems using standard SQL.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy would you use a `JSONB` data type instead of a `JSON` or text type in PostgreSQL?\n<end_of_turn>\n<start_of_turn>model\n`JSONB` stores JSON data in a decomposed binary format, whereas `JSON` stores an exact text copy. `JSONB` is slightly slower to insert due to the conversion, but it is much faster to process and query because it can be indexed efficiently. `JSONB` also removes duplicate keys and whitespace, unlike `JSON`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is an 'upsert' operation, and how is it commonly implemented?\n<end_of_turn>\n<start_of_turn>model\nAn 'upsert' (a portmanteau of update and insert) is an operation that will insert a new row if it doesn't exist, or update the existing row if it does. It's commonly implemented using the `MERGE` statement in standard SQL and SQL Server, or with dialect-specific syntax like `INSERT ... ON CONFLICT` in PostgreSQL or `INSERT ... ON DUPLICATE KEY UPDATE` in MySQL.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of `sp_executesql` in SQL Server?\n<end_of_turn>\n<start_of_turn>model\n`sp_executesql` is a system stored procedure used to execute dynamically constructed Transact-SQL statements. It is generally safer and more efficient than the `EXEC` command because it allows for the parameterization of dynamic queries, which helps prevent SQL injection and promotes execution plan reuse.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a `BLOB` data type, and how does it differ from a `CLOB`?\n<end_of_turn>\n<start_of_turn>model\n`BLOB` stands for Binary Large Object and is used to store large binary data, such as images, audio, or video files. `CLOB` stands for Character Large Object and is used to store large amounts of character or text data. The key difference is that a `CLOB` has a character set associated with it, whereas a `BLOB` is just a stream of bytes.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the 'Collation' of a database column?\n<end_of_turn>\n<start_of_turn>model\nCollation defines the rules for how string data is sorted and compared. It specifies properties like case-sensitivity (`CS` vs. `CI`), accent-sensitivity (`AS` vs. `AI`), and the character set used. The wrong collation can lead to unexpected sorting orders and comparison results.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'Heap' in the context of database tables?\n<end_of_turn>\n<start_of_turn>model\nA heap is a table that does not have a clustered index. The data rows in a heap are not stored in any particular order. Data is simply added where there is space. While this can make inserts faster, reading from a heap can be slow without good non-clustered indexes, as it may require a full table scan.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between internal and external fragmentation of an index?\n<end_of_turn>\n<start_of_turn>model\nInternal fragmentation refers to the empty space on the data pages of an index, often controlled by the fill factor. External fragmentation occurs when the logical order of the index pages does not match their physical order on the disk. Both types can lead to degraded performance by requiring more I/O operations.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does `REBUILD`ing an index differ from `REORGANIZE`ing it?\n<end_of_turn>\n<start_of_turn>model\n`REBUILD`ing an index drops the existing index and creates a new, fresh one. This removes all fragmentation but is a resource-intensive operation that can lock the table. `REORGANIZE`ing an index physically reorders the leaf-level pages to match the logical order and compacts the pages. It's a less intensive, online operation but may not be as effective as a full rebuild for heavy fragmentation.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `PERCENTILE_CONT` function?\n<end_of_turn>\n<start_of_turn>model\n`PERCENTILE_CONT` is an analytic function that calculates a percentile based on a continuous distribution of the column values. It interpolates between adjacent input values to find the precise percentile value, which may or may not exist in the dataset.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between `PERCENTILE_CONT` and `PERCENTILE_DISC`?\n<end_of_turn>\n<start_of_turn>model\n`PERCENTILE_CONT` assumes a continuous distribution and interpolates to find the value, which might not be an actual value in the set. `PERCENTILE_DISC` assumes a discrete distribution and returns the first value from the set whose cumulative distribution is greater than or equal to the specified percentile. The result is always an actual value from the dataset.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `CUME_DIST` window function?\n<end_of_turn>\n<start_of_turn>model\n`CUME_DIST` (Cumulative Distribution) is a window function that calculates the relative position of a value within a set of values. It returns a value from 0 to 1 representing the percentage of rows that are less than or equal to the current row's value within its partition.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do you implement a running total in SQL?\n<end_of_turn>\n<start_of_turn>model\nA running total is most efficiently implemented using a window function. You can use `SUM(column_to_sum) OVER (PARTITION BY ... ORDER BY ...)` to calculate a cumulative sum. The `ORDER BY` clause defines the order of the accumulation, and the optional `PARTITION BY` clause resets the total for each group.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of a database 'schema' as a namespace?\n<end_of_turn>\n<start_of_turn>model\nIn many database systems, a schema is a named container for database objects like tables, views, and procedures. It acts as a namespace, allowing you to organize objects logically and avoid naming conflicts. For example, you can have `sales.customers` and `support.customers` as two distinct tables.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy is it often a bad idea to put business logic in database triggers?\n<end_of_turn>\n<start_of_turn>model\nPlacing complex business logic in triggers can make the application difficult to understand and maintain. The logic is hidden away in the database and is not visible in the application code. This 'magic' behavior can lead to unexpected side effects and make debugging very challenging.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `OUTPUT` clause (in SQL Server) or `RETURNING` clause (in PostgreSQL)?\n<end_of_turn>\n<start_of_turn>model\nThese clauses are used with DML statements (`INSERT`, `UPDATE`, `DELETE`) to return information from the rows that were affected by the operation. This is very useful for getting back values that were generated by the database, like an auto-incremented ID or a default value, without needing to run a separate `SELECT` query.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'table-valued function' (TVF)?\n<end_of_turn>\n<start_of_turn>model\nA table-valued function is a user-defined function that returns a result set in the form of a table. This result can then be used in a query just like a regular table. TVFs are powerful because they can be parameterized, allowing you to create dynamic, reusable views.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between an inline TVF and a multi-statement TVF in SQL Server?\n<end_of_turn>\n<start_of_turn>model\nAn inline TVF consists of a single `SELECT` statement and is often more performant because the optimizer can treat it much like a view. A multi-statement TVF can contain multiple T-SQL statements to build up the result set in a table variable. The optimizer treats it more like a black box, which can lead to poorer performance.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat does it mean for a function to be 'deterministic'?\n<end_of_turn>\n<start_of_turn>model\nA deterministic function is one that always returns the same result for a given set of input values and a given database state. For example, `UPPER()` is deterministic. A non-deterministic function, like `GETDATE()`, can return different results each time it's called, even with the same inputs.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'scalar' function?\n<end_of_turn>\n<start_of_turn>model\nA scalar function is a user-defined function that returns a single value, such as a number, string, or date. Scalar functions can be used in most places where a standard expression is allowed, like in the `SELECT` list or `WHERE` clause.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'spatial' data type?\n<end_of_turn>\n<start_of_turn>model\nSpatial data types, like `GEOMETRY` and `GEOGRAPHY`, are used to store and query data based on its physical location and shape. They allow you to work with points, lines, and polygons and perform geospatial queries, such as finding all stores within a certain radius of a location.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is an `XML` data type used for?\n<end_of_turn>\n<start_of_turn>model\nThe `XML` data type allows you to store XML documents and fragments directly in a database column. The database provides special methods and functions (like XQuery) to query and manipulate the XML content directly, which is more powerful and efficient than storing it as plain text.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is 'index seek' vs. 'index scan'?\n<end_of_turn>\n<start_of_turn>model\nAn Index Seek is a highly efficient operation where the database uses the B-tree structure of the index to navigate directly to the specific rows that satisfy a query. An Index Scan means the database reads through all or a large portion of the leaf pages of an index. A seek is almost always preferable to a scan for performance.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'bookmark lookup' or 'key lookup'?\n<end_of_turn>\n<start_of_turn>model\nA bookmark lookup (or key lookup) is an operation that occurs when the database finds a qualifying row using a non-clustered index but needs to retrieve additional columns that are not in that index. It must then use the key from the index (like the primary key) to 'look up' the rest of the data in the main table (the clustered index or heap). These lookups can be expensive if they happen for many rows.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow can you avoid a bookmark/key lookup?\n<end_of_turn>\n<start_of_turn>model\nYou can avoid a bookmark lookup by creating a 'covering index'. A covering index is a non-clustered index that includes all the columns needed for a specific query, either as key columns or included columns. This allows the query to be answered by reading the index alone, without having to touch the base table.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'Buffer Pool' or 'Buffer Cache'?\n<end_of_turn>\n<start_of_turn>model\nThe buffer pool is a component of the main memory (RAM) that the database server uses to cache data and index pages that have been read from disk. Accessing data from this cache is thousands of times faster than reading from disk. An efficient buffer pool is critical for database performance.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'checkpoint' process in a database?\n<end_of_turn>\n<start_of_turn>model\nA checkpoint is a background process that periodically writes all modified ('dirty') data pages from the in-memory buffer cache to the physical disk. This synchronizes the database files with the transaction log, reduces the time needed for recovery after a crash, and frees up space in the buffer cache.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy is it important to control the size of the transaction log?\n<end_of_turn>\n<start_of_turn>model\nAn unmanaged transaction log can grow to an enormous size, consuming all available disk space. In full recovery models, the log will continue to grow until it is backed up. Proper log management, including regular backups, is essential for maintaining a healthy database server.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a `WHILE` loop in SQL and a set-based operation?\n<end_of_turn>\n<start_of_turn>model\nA `WHILE` loop is a procedural, row-by-row operation (often called a cursor). A set-based operation acts on the entire result set at once. SQL is fundamentally designed for set-based operations, which are almost always more efficient and scalable than procedural loops for data manipulation.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is 'ETL' in the context of data management?\n<end_of_turn>\n<start_of_turn>model\nETL stands for Extract, Transform, and Load. It's a data integration process used to populate data warehouses. Data is *extracted* from various source systems, *transformed* into a consistent format (cleaned, aggregated, standardized), and then *loaded* into the target data warehouse.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is 'ELT' and how does it differ from 'ETL'?\n<end_of_turn>\n<start_of_turn>model\nELT stands for Extract, Load, and Transform. In this newer paradigm, raw data is first *extracted* from sources and *loaded* directly into the target system (often a powerful cloud data warehouse). The *transformation* is then performed within the target system using its processing power. This approach leverages the scalability of modern data warehouses and is more flexible for handling raw data.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'linked server' or 'database link'?\n<end_of_turn>\n<start_of_turn>model\nA linked server is a feature that allows a database instance to execute queries against other remote data sources, including other SQL database instances or even non-SQL data sources via an OLE DB provider. It enables you to write a single distributed query that can access data from multiple servers.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'sequence' object?\n<end_of_turn>\n<start_of_turn>model\nA sequence is a database object that generates a sequence of unique numbers according to specified rules (e.g., start value, increment). Unlike an auto-incrementing identity column, a sequence is an independent object and its next value can be obtained before an insert, or it can be shared across multiple tables.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow can you find the schema of a table without querying its data?\n<end_of_turn>\n<start_of_turn>model\nYou can query the database's system catalog or information schema views. The `INFORMATION_SCHEMA.COLUMNS` view, which is part of the SQL standard, can be queried to get details about all columns in a specific table, including their name, data type, and constraints, without touching the table's data.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `TRIM` function used for?\n<end_of_turn>\n<start_of_turn>model\nThe `TRIM` function is used to remove leading, trailing, or both leading and trailing characters (by default, spaces) from a string. It is a more flexible and standard alternative to the older `LTRIM` and `RTRIM` functions.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'hierarchical query'?\n<end_of_turn>\n<start_of_turn>model\nA hierarchical query is a type of query used to process data that has a parent-child relationship, such as an organizational chart or a bill of materials. It's typically implemented using recursive Common Table Expressions (CTEs) in standard SQL or with specific clauses like `CONNECT BY` in Oracle.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is 'index-organized table' (IOT)?\n<end_of_turn>\n<start_of_turn>model\nAn index-organized table, a feature in databases like Oracle, is a table where the data itself is stored within its primary key index. Unlike a regular table with a clustered index, there is no separate table structure; the index *is* the table. This provides very fast key-based access but can be less efficient for full table scans.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `WITH TIES` clause used with `TOP` or `FETCH`?\n<end_of_turn>\n<start_of_turn>model\nThe `WITH TIES` option is used to return additional rows that have the same value in the `ORDER BY` columns as the last row of the limited result set. For example, `TOP 5 WITH TIES` might return 7 rows if the 5th, 6th, and 7th rows are all tied for the 5th position.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat does the `ISJSON` function do?\n<end_of_turn>\n<start_of_turn>model\nThe `ISJSON` function, available in systems that support JSON data types, is a predicate used to test whether a given string contains valid JSON. It returns true if the string is correctly formatted JSON and false otherwise. It's useful for data validation before attempting to parse JSON content.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does `JSON_VALUE` differ from `JSON_QUERY`?\n<end_of_turn>\n<start_of_turn>model\n`JSON_VALUE` is used to extract a single scalar value (a string, number, true, false, or null) from a JSON string. `JSON_QUERY` is used to extract a complex object or an array (a JSON fragment) from a JSON string. Using the wrong one will result in an error or a `NULL` value.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a temporary table and a table variable?\n<end_of_turn>\n<start_of_turn>model\nThis is specific to systems like SQL Server. A temporary table (`#temp`) is a physical table created in the `tempdb` database that can be indexed and supports transactions. A table variable (`@table`) is a variable that holds a table structure in memory (though it can spill to `tempdb`). It has more limited scope, cannot be explicitly indexed in the same way, and does not participate in user transactions.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy is it important to have a 'clustered index key' that is narrow, static, and ever-increasing?\n<end_of_turn>\n<start_of_turn>model\nThe clustered index key is used as the lookup key in all non-clustered indexes. A *narrow* key keeps the non-clustered indexes smaller and more efficient. A *static* key avoids expensive updates to all non-clustered indexes. An *ever-increasing* key (like an identity column) helps prevent page splits and fragmentation during inserts, improving write performance.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is Boyce-Codd Normal Form (BCNF) and how does it differ from 3NF?\n<end_of_turn>\n<start_of_turn>model\nBCNF is a stricter version of Third Normal Form (3NF). A table is in BCNF if, for every non-trivial functional dependency X  Y, X is a superkey. The key difference is that 3NF allows for dependencies where Y is a prime attribute (part of a candidate key), whereas BCNF does not. BCNF eliminates certain anomalies that 3NF cannot.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a multi-valued dependency, and what problem does it address?\n<end_of_turn>\n<start_of_turn>model\nA multi-valued dependency occurs when the presence of one value in a row determines a set of values for another attribute, independent of any other attributes. For example, if an employee can have multiple skills and multiple dependents, a multi-valued dependency exists. It is addressed by Fourth Normal Form (4NF), which requires that such dependencies be moved to a separate table to prevent data redundancy.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain Fourth Normal Form (4NF).\n<end_of_turn>\n<start_of_turn>model\nA table is in Fourth Normal Form (4NF) if it is in BCNF and has no multi-valued dependencies. 4NF is designed to eliminate data redundancy in tables that represent many-to-many relationships with more than one independent attribute. It ensures that independent facts are not stored in the same table.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a join dependency and Fifth Normal Form (5NF)?\n<end_of_turn>\n<start_of_turn>model\nA join dependency exists if a table can be losslessly decomposed into multiple smaller tables and then rejoined to form the original table. Fifth Normal Form (5NF), also known as Project-Join Normal Form (PJ/NF), requires that every non-trivial join dependency in a table is implied by its candidate keys. It is the highest level of normalization and addresses very rare data redundancy cases.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are the primary trade-offs when choosing a UUID as a primary key instead of an integer?\n<end_of_turn>\n<start_of_turn>model\nUsing a UUID provides global uniqueness, which is great for distributed systems, and it doesn't expose business information. However, UUIDs are larger (16 bytes vs. 4/8 for integers), leading to bigger tables and indexes. They also cause index fragmentation in traditional B-tree indexes because they are not sequential, which can significantly degrade insert and query performance.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are temporal tables, or system-versioned tables?\n<end_of_turn>\n<start_of_turn>model\nTemporal tables are a feature in some SQL databases that automatically track the history of data changes in a table. When a row is updated or deleted, the database preserves the old version of the row in a separate history table, along with the time period for which it was valid. This allows you to query the state of your data at any point in the past.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `FILTER` clause for aggregate functions?\n<end_of_turn>\n<start_of_turn>model\nThe `FILTER` clause, part of the SQL standard, allows you to apply a `WHERE` clause to a single aggregate function within a `SELECT` statement. This is a cleaner and more efficient way to perform conditional aggregation than using a `CASE` statement inside the aggregate. For example: `COUNT(*) FILTER (WHERE status = 'active')`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'seek predicate' versus a 'residual predicate' in a query plan?\n<end_of_turn>\n<start_of_turn>model\nA 'seek predicate' is a condition that the database can use to perform an efficient index seek, directly locating the required data. A 'residual predicate' is an additional filter that the database must apply to the rows returned by the seek, because the index itself was not sufficient to fully satisfy the condition. Minimizing residual predicates is key to performance.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain what 'spilling to TempDB' means and why it harms performance.\n<end_of_turn>\n<start_of_turn>model\nSpilling to TempDB occurs when a query operation, like a sort or a hash join, requires more memory than has been allocated to it (its memory grant). The database must then 'spill' the excess data to the temporary database on disk (TempDB). This is extremely detrimental to performance because it replaces a fast in-memory operation with much slower disk I/O.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'memory grant' for a query?\n<end_of_turn>\n<start_of_turn>model\nA memory grant is the amount of memory that the query optimizer allocates for a query to use for its memory-intensive operations, such as sorting and hashing. The optimizer estimates the required memory based on table statistics. An inaccurate estimate can lead to either wasted memory (too large a grant) or spills to disk (too small a grant).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between pessimistic and optimistic locking?\n<end_of_turn>\n<start_of_turn>model\nPessimistic locking assumes that conflicts are likely and locks data as soon as it's read to prevent other transactions from modifying it (e.g., `SELECT ... FOR UPDATE`). Optimistic locking assumes conflicts are rare. It does not lock data but checks at commit time if the data has been modified by another transaction since it was read. If it has, the transaction is rolled back.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are intent locks (e.g., IX, IS) and what problem do they solve?\n<end_of_turn>\n<start_of_turn>model\nIntent locks are table-level locks that signal a transaction's *intention* to acquire a more granular lock (like a row or page lock) within that table. An Intent Shared (IS) lock signals the intent to place S-locks, and an Intent Exclusive (IX) lock signals the intent to place X-locks. They solve a performance problem by allowing the engine to quickly check for conflicting table-level locks without having to check every single row or page lock.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do auto-incrementing keys differ between MySQL (`AUTO_INCREMENT`), PostgreSQL (`SERIAL`), and SQL Server (`IDENTITY`)?\n<end_of_turn>\n<start_of_turn>model\nIn MySQL (`AUTO_INCREMENT`) and SQL Server (`IDENTITY`), it's a column property. In PostgreSQL, `SERIAL` is a shorthand that creates a sequence object and sets the column's default value to fetch from it. This makes the PostgreSQL approach more flexible, as the underlying sequence can be managed independently.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between PL/pgSQL (PostgreSQL) and T-SQL (SQL Server)?\n<end_of_turn>\n<start_of_turn>model\nBoth are procedural extensions to SQL. T-SQL is deeply integrated into SQL Server's engine and has a syntax derived from Sybase. PL/pgSQL is the default procedural language for PostgreSQL, designed to be simple and robust. One key difference is that T-SQL allows for more complex statements to be run as single units, while PL/pgSQL often structures logic within explicit function or procedure blocks.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `VACUUM` process in PostgreSQL?\n<end_of_turn>\n<start_of_turn>model\nDue to its MVCC architecture, when rows are updated or deleted in PostgreSQL, the old versions are not immediately removed. The `VACUUM` process reclaims this storage by marking these 'dead' rows as free space. It also updates statistics and prevents transaction ID wraparound, making it a critical maintenance task.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is Transparent Data Encryption (TDE)?\n<end_of_turn>\n<start_of_turn>model\nTransparent Data Encryption (TDE) is a security feature that encrypts the entire database at rest. It encrypts the physical data and log files on the disk. It's called 'transparent' because the encryption and decryption are handled automatically by the database engine, and the application does not need to be modified to support it.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'tipping point' in query optimization?\n<end_of_turn>\n<start_of_turn>model\nThe tipping point is a concept where the query optimizer decides that it's more efficient to perform a full table scan rather than using a non-clustered index with key lookups. This happens when the optimizer estimates that the query will need to retrieve a significant percentage of the rows from the table, making the cumulative cost of many individual lookups higher than one large scan.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are geospatial functions like `ST_Distance` and `ST_Intersects` used for?\n<end_of_turn>\n<start_of_turn>model\nThese are functions for querying spatial data. `ST_Distance` calculates the distance between two geometric or geographic points. `ST_Intersects` is a boolean function that returns true if two shapes (e.g., a point and a polygon) overlap or touch. They are fundamental for location-based services and geographic information systems (GIS).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow does SQL play a role in querying a data lake using tools like Presto or Trino?\n<end_of_turn>\n<start_of_turn>model\nTools like Presto and Trino are distributed SQL query engines. They provide a standard SQL interface to query data stored in various formats (like Parquet or ORC) across different data sources, including data lakes like Amazon S3 or HDFS. They act as a SQL abstraction layer, allowing analysts to use familiar SQL syntax without moving the data into a traditional database.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat does it mean for a SQL script to be 'idempotent'?\n<end_of_turn>\n<start_of_turn>model\nAn idempotent SQL script is one that can be run multiple times with the same initial conditions and will produce the same result, without causing errors or unintended side effects on subsequent runs. This is often achieved by including checks in the script, such as `IF NOT EXISTS` before creating an object or `DROP IF EXISTS` before recreating it.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the 'Query Store' feature in SQL Server?\n<end_of_turn>\n<start_of_turn>model\nThe Query Store is a feature that automatically captures a history of queries, execution plans, and runtime statistics. It provides a powerful tool for troubleshooting performance regressions by allowing you to see when a query's plan changed and to force the use of a previous, more efficient plan.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'key-range lock' and how does it relate to the `SERIALIZABLE` isolation level?\n<end_of_turn>\n<start_of_turn>model\nA key-range lock is a lock placed on a range of index values. It is used in the `SERIALIZABLE` isolation level to prevent phantom reads. By locking the range where a new row *could* be inserted, it ensures that no other transaction can add a row that would match the query's `WHERE` clause, thus guaranteeing a stable result set for the duration of the transaction.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `FORALL` statement in Oracle's PL/SQL?\n<end_of_turn>\n<start_of_turn>model\n`FORALL` is a performance optimization feature in PL/SQL used for bulk DML operations. Instead of looping through a collection and executing an `INSERT` or `UPDATE` for each item (which causes many context shifts between the PL/SQL and SQL engines), `FORALL` binds the entire collection and sends it to the SQL engine in a single call, significantly improving performance.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the 'dual' table in Oracle?\n<end_of_turn>\n<start_of_turn>model\n`dual` is a special one-row, one-column table present by default in Oracle databases. Its primary purpose is to provide a guaranteed single result for queries that don't need to reference a real table, such as selecting a constant, a sequence value (`my_seq.nextval`), or the result of a function (`SYSDATE`).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between an `EXPLAIN` and an `ANALYZE` command in PostgreSQL?\n<end_of_turn>\n<start_of_turn>model\n`EXPLAIN` shows the query optimizer's *estimated* execution plan without running the query. `EXPLAIN ANALYZE` actually *executes* the query and then shows the plan along with the *actual* runtime statistics, such as the true row counts and time spent in each node. `EXPLAIN ANALYZE` is far more accurate for diagnosing performance issues but should be used with caution on production DML statements.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'correlated DELETE' statement?\n<end_of_turn>\n<start_of_turn>model\nA correlated `DELETE` is a `DELETE` statement that uses a subquery to determine which rows to remove, and that subquery refers back to the table from which rows are being deleted. It's often used to remove duplicate rows or to delete records based on complex conditions involving other rows in the same table.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are 'log shipping' and 'database mirroring'?\n<end_of_turn>\n<start_of_turn>model\nBoth are high-availability features in SQL Server. Log shipping works by backing up the transaction log of a primary server and restoring it on one or more secondary servers. It's a warm-standby solution. Database mirroring keeps a secondary server in sync by sending active transaction log records directly over the network. It can provide a hot-standby with automatic failover, offering a higher level of availability.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhy is it important to handle time zones correctly in a database?\n<end_of_turn>\n<start_of_turn>model\nFailing to handle time zones correctly can lead to incorrect data, missed appointments, and flawed analytics. It's crucial for global applications to store timestamps in a consistent, timezone-aware format (like UTC, using `TIMESTAMP WITH TIME ZONE`) and to perform conversions to the user's local time only at the application or presentation layer.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between the `LEAD` window function and the `NTH_VALUE` function?\n<end_of_turn>\n<start_of_turn>model\n`LEAD(col, N)` is a specialized function that retrieves the value of `col` from N rows *after* the current row. `NTH_VALUE(col, N)` is a more general function that retrieves the value of `col` from the Nth row of the *current window frame*. To make `NTH_VALUE` behave like `LEAD`, you would need to define the frame appropriately.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `IGNORE NULLS` clause in some window functions?\n<end_of_turn>\n<start_of_turn>model\nThe `IGNORE NULLS` clause, available for functions like `LEAD`, `LAG`, `FIRST_VALUE`, and `LAST_VALUE`, allows the function to skip over `NULL` values when searching for a value. For example, `LAG(price, 1) IGNORE NULLS` would find the price from the most recent *non-null* preceding row, not necessarily the immediately preceding one.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'gaps and islands' problem in SQL?\n<end_of_turn>\n<start_of_turn>model\nThe 'gaps and islands' problem is a common challenge that involves identifying consecutive sequences of numbers (islands) and the missing ranges between them (gaps) in a dataset. It is typically solved using advanced SQL techniques, often involving window functions like `ROW_NUMBER()` to detect breaks in the sequence.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow can you use a recursive CTE to traverse a hierarchical data structure?\n<end_of_turn>\n<start_of_turn>model\nA recursive CTE is defined with two parts: an 'anchor member' that selects the starting point(s) of the hierarchy (e.g., the CEO), and a 'recursive member' that joins back to the CTE itself to find the next level of the hierarchy (e.g., direct reports). The `UNION ALL` operator combines the results, and the recursion stops when the recursive member returns no more rows.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `MATCH_RECOGNIZE` clause in Oracle and other modern databases?\n<end_of_turn>\n<start_of_turn>model\n`MATCH_RECOGNIZE` is a powerful feature for performing pattern matching on sequences of rows. It allows you to define complex patterns (e.g., V-shaped recovery in stock prices) using regular expression-like syntax and extract information from the rows that match the pattern, all within a single SQL query.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `information_schema`?\n<end_of_turn>\n<start_of_turn>model\nThe `information_schema` is a standardized set of read-only views available in most SQL databases. It provides a consistent way to query the database's metadata, such as information about tables, columns, constraints, and routines, regardless of the specific database system's proprietary catalog tables.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a `TRIGGER` and a `CONSTRAINT`?\n<end_of_turn>\n<start_of_turn>model\nA `CONSTRAINT` is a declarative rule that defines the properties of data in a table (e.g., uniqueness, non-nullability). It is a simple, efficient way to enforce data integrity. A `TRIGGER` is a procedural block of code that is automatically executed in response to a DML event. Triggers are more flexible and can implement complex business logic that goes beyond what constraints can do, but they are also more complex and can be a source of performance issues.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the 'Halloween Problem' in database updates?\n<end_of_turn>\n<start_of_turn>model\nThe Halloween Problem is a phenomenon where an `UPDATE` statement that modifies the columns used in its own `WHERE` clause or index can cause rows to be updated multiple times or missed entirely. Modern database systems prevent this by either creating a snapshot of the data before the update begins or by using blocking operators in the execution plan.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `AT TIME ZONE` clause used for?\n<end_of_turn>\n<start_of_turn>model\nThe `AT TIME ZONE` clause is a standard SQL feature used for timezone conversion. It allows you to interpret a timezone-unaware `datetime` as being in a specific timezone, or to convert a timezone-aware `timestamp` from its current timezone to a different one.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are common SQL patterns for data cleaning?\n<end_of_turn>\n<start_of_turn>model\nCommon patterns include using `TRIM()` and `LOWER()`/`UPPER()` for standardizing string formats, `COALESCE()` to replace `NULL`s with default values, `CASE` statements to correct or bucket data, and using `GROUP BY` with `HAVING COUNT(*) > 1` to identify and handle duplicate records.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of 'table hints' in a query (e.g., `WITH (NOLOCK)`)?\n<end_of_turn>\n<start_of_turn>model\nTable hints are directives given to the query optimizer to override its default behavior. For example, `WITH (NOLOCK)` in SQL Server instructs the engine to perform a dirty read, ignoring locks. While they can solve specific problems, using hints is generally discouraged as it can lead to brittle queries and may be a sign of a deeper underlying issue, like outdated statistics or poor indexing.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between `ANY` and `SOME` operators in SQL?\n<end_of_turn>\n<start_of_turn>model\nThere is no difference. `SOME` is a synonym for `ANY` as defined by the SQL standard. Both are used with a subquery and a comparison operator (e.g., `= ANY (...)`) to check if the comparison is true for at least one of the values returned by the subquery. `ANY` is far more commonly used.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the concept of idempotency in the context of SQL scripts and why it's a crucial practice in database deployments.\n<end_of_turn>\n<start_of_turn>model\nIdempotency in SQL means that running a script multiple times produces the same result as running it once. It's crucial for database deployments because it makes them reliable and repeatable. An idempotent script often includes checks, like `IF NOT EXISTS` before creating a table or `DROP IF EXISTS` before recreating an object. This prevents errors on subsequent runs and ensures the database schema reaches the desired state regardless of its starting state.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe the primary differences between a row-based and a column-based (columnar) database storage engine.\n<end_of_turn>\n<start_of_turn>model\nA **row-based** engine stores all data for a given row together on disk (e.g., `ID, Name, Email, Address` for one customer). This is efficient for transactional (OLTP) workloads where you often need to read or write an entire record at once. A **column-based** engine stores all values for a given column together (e.g., all `Names`, then all `Emails`). This is highly efficient for analytical (OLAP) workloads because a query typically only needs a few columns, allowing the engine to read only the required data and achieve very high compression ratios.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is Multi-Version Concurrency Control (MVCC) and how does it benefit database operations?\n<end_of_turn>\n<start_of_turn>model\nMVCC is a concurrency control method where the database maintains multiple 'versions' of a data row. When a transaction starts, it's given a snapshot of the data at that moment. If another transaction updates a row, it creates a new version instead of overwriting the old one. This benefits operations immensely because **readers don't block writers and writers don't block readers**, leading to much higher concurrency compared to traditional locking models.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the purpose and use case for the `MATCH_RECOGNIZE` clause in advanced SQL.\n<end_of_turn>\n<start_of_turn>model\n`MATCH_RECOGNIZE` is a powerful feature for pattern matching across a sequence of rows. It's used to identify business events that are defined by a specific order of actions. A great use case is analyzing stock market data to find patterns like a 'W' shape (a drop, a recovery, a second drop, and a final recovery) or identifying user behavior patterns on a website, like a 'browse-add_to_cart-abandon' sequence.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe what a 'tipping point' is in query optimization and how it influences the choice between an index seek and a table scan.\n<end_of_turn>\n<start_of_turn>model\nThe 'tipping point' is the threshold at which a query optimizer decides it's more efficient to perform a full table scan than to use a non-clustered index. Using an index for a large number of rows requires many individual key lookups back to the main table, which can be slower than one continuous scan. The tipping point is the percentage of rows where the cost of these lookups exceeds the cost of the scan. It's heavily influenced by table size and row width.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain what a filtered index is and provide two distinct use cases where it would be highly beneficial.\n<end_of_turn>\n<start_of_turn>model\nA filtered index is a non-clustered index that includes a `WHERE` clause, meaning it only stores entries for a subset of rows in a table. \n\n**Use Case 1: Soft Deletes:** On a table with an `IsActive` flag, you can create an index `ON Orders(OrderDate) WHERE IsActive = 1`. This creates a much smaller, more efficient index for queries that only care about active orders. \n\n**Use Case 2: Sparse Data:** If you have a nullable column that is mostly `NULL` but is frequently queried for its few non-null values (e.g., `ErrorTimestamp`), you can create an index `ON Logs(LogMessage) WHERE ErrorTimestamp IS NOT NULL`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDetail the differences between pessimistic and optimistic locking strategies for concurrency control.\n<end_of_turn>\n<start_of_turn>model\n**Pessimistic locking** assumes conflicts are likely. It locks resources as soon as they are accessed (e.g., `SELECT ... FOR UPDATE`) and holds the lock until the transaction completes. This prevents other transactions from modifying the data, ensuring consistency but potentially reducing concurrency. **Optimistic locking** assumes conflicts are rare. It doesn't lock resources but checks at commit time if another transaction has modified the data since it was read (often using a version number or timestamp). If a conflict is detected, the transaction is rolled back.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are Slowly Changing Dimensions (SCDs)? Describe the difference between Type 1 and Type 2.\n<end_of_turn>\n<start_of_turn>model\nSlowly Changing Dimensions (SCDs) are a data warehousing concept for managing changes in dimension attributes over time. \n\n**SCD Type 1 (Overwrite):** The simplest method. When an attribute changes (e.g., a customer moves to a new city), the old value is simply overwritten with the new one. No historical data is kept. \n\n**SCD Type 2 (Add New Row):** This method preserves full history. When an attribute changes, a new row is added to the dimension table for that customer, and the old row is marked as expired (e.g., using start/end date columns or a `IsCurrent` flag). This allows for accurate historical analysis.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the purpose of the `VACUUM` process in PostgreSQL and why it is essential.\n<end_of_turn>\n<start_of_turn>model\nDue to PostgreSQL's MVCC architecture, when rows are updated or deleted, the old row versions ('dead tuples') aren't immediately removed. The `VACUUM` process is essential maintenance that reclaims this storage space for reuse. It also updates data statistics used by the query planner and prevents transaction ID wraparound, a critical failure condition. Without regular vacuuming, database performance would degrade and it could eventually shut down.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCompare and contrast `UUID` and `SERIAL`/`IDENTITY` for use as primary keys, focusing on the trade-offs.\n<end_of_turn>\n<start_of_turn>model\n**`SERIAL`/`IDENTITY` (Integers):** \n* **Pros:** Small, fast, and naturally sequential, which is great for B-Tree index performance (prevents fragmentation). \n* **Cons:** Can expose business information (e.g., order count) and are not unique across distributed systems. \n\n**`UUID` (Universally Unique Identifiers):** \n* **Pros:** Globally unique, making them ideal for distributed systems and merging datasets. They don't expose any business logic. \n* **Cons:** Much larger (16 bytes vs. 4/8), leading to bigger tables and indexes. Random UUIDs cause severe index fragmentation, hurting write performance.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is Transparent Data Encryption (TDE) and what specific threat is it designed to mitigate?\n<end_of_turn>\n<start_of_turn>model\nTransparent Data Encryption (TDE) is a security feature that encrypts the entire database at rest. It automatically encrypts the physical data and log files on the disk. TDE is specifically designed to mitigate the threat of **offline data theft**, where an attacker physically steals the hard drives or backup tapes. It does **not** protect against threats from an authenticated SQL user or SQL injection attacks, as the data is decrypted transparently for authorized sessions.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe the 'gaps and islands' problem in SQL and outline a common technique to solve it.\n<end_of_turn>\n<start_of_turn>model\nThe 'gaps and islands' problem involves identifying consecutive ranges of data ('islands') and the breaks between them ('gaps') in a sequence. A common technique to solve this is using window functions. You can create two sequential row numbers: one over the entire dataset and another partitioned by a grouping element. The difference between these two row numbers will be constant for all rows within a single 'island', allowing you to group by this difference to identify each consecutive sequence.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `information_schema` in a relational database?\n<end_of_turn>\n<start_of_turn>model\nThe `information_schema` is a standardized set of read-only views defined by the SQL standard. Its purpose is to provide a consistent, database-agnostic way to query the database's metadata. You can use it to get information about tables, columns, constraints, views, and users without needing to know the specific system catalog tables of the RDBMS you are using.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the concept of a 'covering index' and why it is a powerful performance optimization.\n<end_of_turn>\n<start_of_turn>model\nA covering index is a non-clustered index that contains all the columns required to satisfy a query. When a query can be answered using only the data in the index, it's called an 'index-only scan'. This is a powerful optimization because the database avoids the expensive step of looking up the remaining data in the main table (a 'key lookup' or 'bookmark lookup'), leading to significantly less I/O and faster query execution.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is predicate pushdown in the context of query optimization?\n<end_of_turn>\n<start_of_turn>model\nPredicate pushdown is an optimization technique where the database engine applies filtering conditions (predicates from a `WHERE` clause) as early as possible in the query execution plan. By filtering data at the source, it dramatically reduces the number of rows that need to be processed in subsequent steps like joins, aggregations, or network transfers, leading to major performance gains.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe the difference between `UNION` and `UNION ALL`, including performance implications.\n<end_of_turn>\n<start_of_turn>model\n`UNION` combines the result sets of two or more `SELECT` statements and removes any duplicate rows. `UNION ALL` does the same but includes all rows, including duplicates. Because `UNION` must perform an extra step to identify and eliminate duplicates (usually involving a sort or hash operation), **`UNION ALL` is significantly more performant**. You should always use `UNION ALL` unless you specifically need duplicate removal.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are window functions in SQL and how do they differ from aggregate functions?\n<end_of_turn>\n<start_of_turn>model\nWindow functions perform a calculation across a set of table rows that are somehow related to the current row. The key difference from aggregate functions is that they **do not collapse the rows**; they return a value for each individual row. For example, an `AVG()` aggregate function returns one average for a whole group, while `AVG() OVER (PARTITION BY ...)` returns a group average on every single row within that group.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the ACID properties of a database transaction.\n<end_of_turn>\n<start_of_turn>model\nACID is an acronym that guarantees the reliability of database transactions: \n* **Atomicity:** The transaction is 'all or nothing.' Either all operations within it complete successfully, or none of them do; the database is not left in a partial state. \n* **Consistency:** The transaction brings the database from one valid state to another, preserving all predefined rules and constraints. \n* **Isolation:** Concurrent transactions produce the same result as if they were executed sequentially. One transaction's intermediate state is not visible to others. \n* **Durability:** Once a transaction is committed, its changes are permanent and will survive any subsequent system failure, like a crash or power outage.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'correlated subquery' and what is its main performance drawback?\n<end_of_turn>\n<start_of_turn>model\nA correlated subquery is a nested query that depends on the outer query for its values. It cannot be run independently. Its main performance drawback is that the subquery is **re-executed for every single row** processed by the outer query. This can lead to extremely poor performance on large datasets compared to an equivalent `JOIN` or a non-correlated subquery.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe the difference between the `DELETE`, `TRUNCATE`, and `DROP` commands.\n<end_of_turn>\n<start_of_turn>model\n* **`DELETE`**: A DML command that removes rows from a table one by one. It is logged, can be rolled back, and can fire triggers. It's the slowest. \n* **`TRUNCATE`**: A DDL command that removes all rows from a table by deallocating the data pages. It is minimally logged, cannot be rolled back, and does not fire triggers. It's very fast. \n* **`DROP`**: A DDL command that completely removes the table itself, including its structure, data, and indexes. It cannot be rolled back.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the purpose of the `GROUP BY` clause and its relationship with aggregate functions.\n<end_of_turn>\n<start_of_turn>model\nThe `GROUP BY` clause is used to arrange identical rows into groups. Its primary purpose is to be used with aggregate functions (`COUNT`, `SUM`, `AVG`, etc.). The aggregate function then performs a calculation on each group, returning a single summary row for each unique group combination.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the fundamental difference between the `WHERE` clause and the `HAVING` clause?\n<end_of_turn>\n<start_of_turn>model\nThe fundamental difference lies in when they are applied. The `WHERE` clause filters **individual rows** *before* any grouping or aggregation occurs. The `HAVING` clause filters **entire groups** of rows *after* the `GROUP BY` clause has been applied and aggregates have been calculated. You must use `HAVING` to filter on an aggregate function's result.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a Common Table Expression (CTE) and what are its main advantages over a subquery?\n<end_of_turn>\n<start_of_turn>model\nA CTE, defined using the `WITH` clause, is a temporary, named result set that you can reference within a `SELECT`, `INSERT`, `UPDATE`, or `DELETE` statement. Its main advantages over a subquery are: \n1.  **Readability:** It breaks down complex queries into logical, easy-to-read steps. \n2.  **Reusability:** A CTE can be referenced multiple times within the same query. \n3.  **Recursion:** CTEs can be recursive, allowing them to query hierarchical data, which is not possible with standard subqueries.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe what a database index is using an analogy.\n<end_of_turn>\n<start_of_turn>model\nA database index is like the index at the back of a book. Instead of reading the entire book from start to finish to find a specific topic (a 'table scan'), you can go to the index, find the topic alphabetically, and get the exact page number(s) to turn to. Similarly, a database index allows the query engine to quickly find the exact location of the data on disk without having to scan the entire table.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between a clustered and a non-clustered index?\n<end_of_turn>\n<start_of_turn>model\nA **clustered index** determines the physical order of data in a table. The leaf nodes of the index *are* the actual data rows. Because of this, a table can only have one clustered index. A **non-clustered index** has a separate structure from the data rows. It contains the indexed values and a pointer (a 'row locator') back to the actual data row. A table can have many non-clustered indexes.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain database normalization and its primary goal.\n<end_of_turn>\n<start_of_turn>model\nDatabase normalization is the process of organizing columns and tables in a relational database to minimize data redundancy and improve data integrity. Its primary goal is to ensure that data is stored logically and efficiently. This is achieved by dividing larger tables into smaller, well-structured tables and defining relationships between them, which helps to prevent data anomalies (insertion, update, and deletion anomalies).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a foreign key and what is its role in maintaining referential integrity?\n<end_of_turn>\n<start_of_turn>model\nA foreign key is a column (or set of columns) in one table that uniquely identifies a row of another table. Its role is to enforce **referential integrity**, which ensures that the relationship between tables remains consistent. For example, it can prevent you from creating an order for a customer that does not exist or from deleting a customer that still has active orders.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe what SQL Injection is and the single most effective way to prevent it.\n<end_of_turn>\n<start_of_turn>model\nSQL Injection is a code injection technique where an attacker can execute malicious SQL statements by inserting them into an application's input fields. This can allow them to bypass security measures, retrieve sensitive data, or even destroy the database. The single most effective way to prevent it is to **use parameterized queries (also known as prepared statements)**. This practice separates the SQL code from the user-supplied data, ensuring the data is treated as a literal value and not as executable code.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `COALESCE` function and how is it different from `ISNULL`?\n<end_of_turn>\n<start_of_turn>model\n`COALESCE` is a standard SQL function that returns the first non-NULL expression from a list of arguments. For example, `COALESCE(column1, column2, 'default')` will return `column1` if it's not null, otherwise `column2` if it's not null, otherwise 'default'. `ISNULL` is a T-SQL specific function that does a similar thing but only accepts two arguments. The key difference is that `COALESCE` is standardized and more flexible.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the purpose of the `PARTITION BY` clause in a window function.\n<end_of_turn>\n<start_of_turn>model\nThe `PARTITION BY` clause divides the rows of a result set into partitions or 'windows' to which the window function is applied. The function is calculated and reset for each partition independently. It's analogous to the `GROUP BY` clause for aggregate functions, but it doesn't collapse the rows.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a `VIEW` in SQL and what are two primary benefits of using one?\n<end_of_turn>\n<start_of_turn>model\nA `VIEW` is a virtual table based on the result-set of a stored `SELECT` statement. It doesn't store data itself. Two primary benefits are: \n1.  **Simplicity:** It can encapsulate a complex query, allowing users to interact with the data through a simple `SELECT` statement from the view. \n2.  **Security:** It can be used to restrict access to data by exposing only certain columns or rows from the underlying tables to specific users.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe the difference between `CHAR` and `VARCHAR` data types.\n<end_of_turn>\n<start_of_turn>model\n`CHAR` is a **fixed-length** string data type. If you define a column as `CHAR(10)` and store 'hi', it will use 10 bytes, padding the rest with spaces. `VARCHAR` is a **variable-length** string data type. A `VARCHAR(10)` column storing 'hi' will only use the necessary bytes for the characters plus a small overhead. `VARCHAR` is more efficient for storing data of varying lengths.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a stored procedure and what are its advantages?\n<end_of_turn>\n<start_of_turn>model\nA stored procedure is a prepared SQL code that you can save, so the code can be reused over and over again. Its advantages include: \n* **Performance:** The execution plan can be cached, making subsequent calls faster. \n* **Reduced Network Traffic:** Instead of sending long SQL statements, the application only needs to send the procedure name and parameters. \n* **Security:** You can grant users permission to execute a procedure without giving them direct access to the underlying tables. \n* **Maintainability:** Business logic is encapsulated in one place.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain what a 'self-join' is and provide a practical example of its use.\n<end_of_turn>\n<start_of_turn>model\nA self-join is a regular join, but the table is joined with itself. It's used when you want to compare rows within the same table. A practical example is an `employees` table where each employee has a `manager_id` column that points to another employee's `employee_id`. To get a list of each employee and their manager's name, you would self-join the `employees` table on `e1.manager_id = e2.employee_id`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `CASE` statement in SQL used for?\n<end_of_turn>\n<start_of_turn>model\nThe `CASE` statement provides if-then-else logic within a SQL query. It allows you to return different values based on a set of conditions. It's commonly used in the `SELECT` list to create derived columns or in the `ORDER BY` clause for conditional sorting.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the logical order of operations in a `SELECT` statement?\n<end_of_turn>\n<start_of_turn>model\nThe logical processing order of a `SELECT` statement is different from the written order. It is generally: \n1. `FROM` (and `JOIN`s) \n2. `WHERE` \n3. `GROUP BY` \n4. `HAVING` \n5. `SELECT` (and window functions) \n6. `DISTINCT` \n7. `ORDER BY` \n8. `LIMIT` / `TOP`. This order explains why you can't use a column alias from the `SELECT` list in the `WHERE` clause.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe the difference between the `RANK()` and `DENSE_RANK()` window functions.\n<end_of_turn>\n<start_of_turn>model\nBoth functions assign a rank to rows within a partition based on an `ORDER BY` clause. The difference is how they handle ties. `RANK()` will assign the same rank to tied rows and then skip the next rank(s). For example, `1, 2, 2, 4`. `DENSE_RANK()` will also assign the same rank to tied rows but will not skip any ranks in the sequence. For example, `1, 2, 2, 3`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is denormalization and when is it a justifiable strategy?\n<end_of_turn>\n<start_of_turn>model\nDenormalization is the process of intentionally adding redundant data to a database to improve query performance. It's a justifiable strategy in read-heavy environments like data warehousing or reporting databases. By adding redundant data, you can avoid costly and complex joins, which simplifies queries and speeds up data retrieval, at the expense of increased storage and more complex data modification logic.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'materialized view' and how does it differ from a standard view?\n<end_of_turn>\n<start_of_turn>model\nA standard `VIEW` is a virtual table whose results are generated dynamically every time it's queried. A `MATERIALIZED VIEW` is a database object that physically stores the result set of a query. It's a snapshot of the data at a specific point in time. It must be refreshed periodically. The key difference is that querying a materialized view is much faster because the data is pre-calculated, making it ideal for complex, slow-running queries.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the concept of 'cardinality' in the context of database indexes.\n<end_of_turn>\n<start_of_turn>model\nCardinality refers to the uniqueness of data values in a column. **High cardinality** means there are many distinct values relative to the number of rows (e.g., a `user_id` column). **Low cardinality** means there are very few distinct values (e.g., a `gender` column). Indexes on high-cardinality columns are very selective and efficient for filtering data, while indexes on low-cardinality columns are generally much less useful.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the N+1 query problem and how can it be solved?\n<end_of_turn>\n<start_of_turn>model\nThe N+1 query problem is a performance issue where an application makes one query to retrieve a list of items (the '1'), and then makes an additional query for each of those items to fetch related data (the 'N'). This results in a large number of database round-trips. It can be solved by fetching all the necessary data in a single, more efficient query, typically by using a `JOIN`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `CROSS APPLY` operator in SQL Server and how does it differ from a standard `JOIN`?\n<end_of_turn>\n<start_of_turn>model\n`CROSS APPLY` is an operator that allows you to invoke a table-valued function for each row returned by an outer table expression. It differs from a standard `JOIN` because the right side of the operator can be a function that depends on values from the left side. It's like running a correlated subquery for each row, but in a way that can return multiple columns and rows.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a database 'schema' and what is its role in organization?\n<end_of_turn>\n<start_of_turn>model\nA database schema is a named container for database objects like tables, views, and stored procedures. It serves as a namespace, allowing you to logically group related objects together. This helps in organizing a large database and managing permissions. For example, you could have `sales.orders` and `inventory.products` to keep objects from different business domains separate.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the purpose of the `PIVOT` operator.\n<end_of_turn>\n<start_of_turn>model\nThe `PIVOT` operator is used to transform data from a row-level orientation to a columnar orientation. It rotates unique values from one column into multiple new columns in the output. It's essentially used to create crosstab reports, for example, turning rows of monthly sales data into a report with columns for each month.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are 'key-range locks' and in which isolation level are they primarily used?\n<end_of_turn>\n<start_of_turn>model\nKey-range locks are a type of lock that protects a range of index values between two consecutive entries. They are primarily used in the **`SERIALIZABLE` isolation level**. Their purpose is to prevent 'phantom reads' by stopping other transactions from inserting new rows that would fall into the locked range and match the query's filter conditions.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the `OUTPUT` clause (in T-SQL) or `RETURNING` clause (in PostgreSQL) used for?\n<end_of_turn>\n<start_of_turn>model\nThese clauses are used with DML statements (`INSERT`, `UPDATE`, `DELETE`) to return information from the rows affected by the operation. This is extremely useful for retrieving database-generated values like an `IDENTITY` column or a `DEFAULT` timestamp without needing to run a subsequent `SELECT` statement.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe what a 'heap' is in the context of a database table.\n<end_of_turn>\n<start_of_turn>model\nA 'heap' is a table that does not have a clustered index. Its data pages and rows are not stored in any specific order; data is simply placed wherever there is available space. While this can make inserts marginally faster, querying a heap without a suitable non-clustered index can be very inefficient as it may require a full table scan.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the difference between a subquery and a join, and when you might prefer one over the other.\n<end_of_turn>\n<start_of_turn>model\nA `JOIN` combines columns from two or more tables into a single result set. A subquery is a query nested inside another query, used to return a single value or a list of values for filtering. You would generally prefer a `JOIN` for performance and readability when you need columns from both tables. You might prefer a subquery (especially using `IN` or `EXISTS`) when you only need to check for the existence of a matching record in another table and don't need any of its data.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `WITH TIES` clause when using `TOP` or `FETCH`?\n<end_of_turn>\n<start_of_turn>model\nThe `WITH TIES` clause is used with `TOP N` or `FETCH FIRST N ROWS` to include any additional rows that have the same value in the `ORDER BY` columns as the Nth row. For example, `SELECT TOP 5 WITH TIES ... ORDER BY score DESC` might return 7 rows if the 5th, 6th, and 7th players all have the same score.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat are temporal tables (system-versioned tables) and what problem do they solve?\n<end_of_turn>\n<start_of_turn>model\nTemporal tables are a feature that automatically tracks the history of changes to data in a table. When a row is updated or deleted, the database automatically stores the previous version of the row in a separate history table with its period of validity. They solve the problem of needing to query the state of data at a specific point in time in the past, which is crucial for auditing, trend analysis, and recovering accidentally modified data.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain what the following SQL query does. Describe the role of the window function.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  employee_name,\n  department,\n  salary,\n  AVG(salary) OVER (PARTITION BY department) AS avg_dept_salary\nFROM employees;\n```\n\nThis query retrieves a list of all employees along with their name, department, and salary. Crucially, it also calculates the **average salary for each employee's department** and displays it on every employee's row.\n\n**Role of the window function:** The `AVG(salary) OVER (PARTITION BY department)` is a window function. It calculates the average salary, but the `PARTITION BY department` clause tells it to perform this calculation independently for each department. Unlike a standard `GROUP BY`, it does not collapse the rows, allowing you to see both the individual employee's salary and their department's average in the same row.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe the purpose and logic of this query that uses a recursive CTE.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH RECURSIVE EmployeeHierarchy AS (\n  -- Anchor Member\n  SELECT employee_id, employee_name, manager_id, 0 AS level\n  FROM employees\n  WHERE manager_id IS NULL\n\n  UNION ALL\n\n  -- Recursive Member\n  SELECT e.employee_id, e.employee_name, e.manager_id, eh.level + 1\n  FROM employees e\n  JOIN EmployeeHierarchy eh ON e.manager_id = eh.employee_id\n)\nSELECT * FROM EmployeeHierarchy;\n```\n\nThis query uses a recursive Common Table Expression (CTE) to map out an entire employee organizational hierarchy and determine the level of each employee.\n\n**Logic Breakdown:**\n1.  **Anchor Member:** The first `SELECT` statement is the starting point. It selects the top-level employees (the ones with no manager, where `manager_id IS NULL`) and assigns them a `level` of 0.\n2.  **Recursive Member:** The second `SELECT` statement joins the `employees` table back to the CTE itself (`EmployeeHierarchy`). It finds all employees whose `manager_id` matches an `employee_id` already in the hierarchy. It then adds these new employees to the result set with their level incremented by 1.\n3.  **Termination:** The recursion continues, finding the next level of employees in each loop, until it reaches the lowest level of the hierarchy and the recursive member returns no more rows.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain what this query is accomplishing with `GROUP BY` and `HAVING`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  c.customer_name,\n  COUNT(o.order_id) AS total_orders\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_name\nHAVING COUNT(o.order_id) >= 10;\n```\n\nThis query identifies 'high-value' customers by finding all customers who have placed 10 or more orders.\n\n**Step-by-step:**\n1.  **`JOIN`:** It first combines the `customers` and `orders` tables based on `customer_id`.\n2.  **`GROUP BY`:** It then groups all the resulting rows by `customer_name`, so all orders for a single customer are in one group.\n3.  **`COUNT`:** The `COUNT(o.order_id)` aggregate function counts the number of orders within each customer's group.\n4.  **`HAVING`:** Finally, the `HAVING` clause filters these groups, keeping only those where the total order count is 10 or more.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAnalyze this query. What business question is it trying to answer, and how does the `FILTER` clause help?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  product_category,\n  COUNT(*) AS total_products,\n  COUNT(*) FILTER (WHERE is_discontinued = true) AS discontinued_products\nFROM products\nGROUP BY product_category;\n```\n\nThis query is trying to answer the business question: **'For each product category, what is the total number of products and how many of them have been discontinued?'**\n\n**How the `FILTER` clause helps:** The `FILTER (WHERE ...)` clause is a clean, standard SQL way to perform conditional aggregation. Instead of using a more verbose `CASE` statement like `SUM(CASE WHEN is_discontinued = true THEN 1 ELSE 0 END)`, the `FILTER` clause applies the `WHERE` condition directly to the `COUNT(*)` aggregate function. It provides a more readable and potentially more efficient way to count only the subset of rows that meet the specific criteria within each group.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the logic of the following query, which finds gaps in a sequence.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH NumberSequence AS (\n  SELECT id, ROW_NUMBER() OVER (ORDER BY id) as rn\n  FROM transactions\n)\nSELECT\n  (t1.id + 1) as gap_start,\n  (t2.id - 1) as gap_end\nFROM NumberSequence t1\nJOIN NumberSequence t2 ON t1.rn + 1 = t2.rn\nWHERE t2.id > t1.id + 1;\n```\n\nThis query is designed to find gaps in a sequence of transaction `id` numbers.\n\n**Logic Breakdown:**\n1.  **`NumberSequence` CTE:** It first assigns a dense, sequential row number (`rn`) to each transaction, ordered by the `id` itself. This creates a perfect sequence to compare against the potentially gapped `id` sequence.\n2.  **Self-Join:** It then joins the CTE to itself, matching each row (`t1`) with the very next row in the sequence (`t2`) using the condition `t1.rn + 1 = t2.rn`.\n3.  **`WHERE` Clause:** The crucial part is the `WHERE t2.id > t1.id + 1` clause. In a perfect sequence, `t2.id` would be exactly `t1.id + 1`. This condition is only true when there is a gap between two consecutive `id`s. The query then reports the start and end of that missing range.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the purpose of this `UPDATE` statement with a `FROM` clause.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE od\nSET od.unit_price = p.standard_price\nFROM order_details od\nJOIN products p ON od.product_id = p.product_id\nWHERE od.order_id IN (SELECT order_id FROM orders WHERE order_date > '2025-01-01');\n```\n\nThis query performs a **correlated update**. Its purpose is to update the `unit_price` in the `order_details` table to match the current `standard_price` from the `products` table, but only for orders placed after January 1st, 2025.\n\n**Step-by-step:**\n1.  It identifies the target table `order_details` (aliased as `od`).\n2.  The `FROM` clause joins `order_details` with the `products` table on `product_id`. This makes the `products` table's columns (like `standard_price`) available for the update.\n3.  The `SET` clause updates the `unit_price` in the `order_details` row with the value from the corresponding product's `standard_price`.\n4.  The `WHERE` clause restricts the update to only affect rows in `order_details` belonging to orders placed after the specified date.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe what this query accomplishes using the `LEAD` window function.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  user_id,\n  login_timestamp,\n  LEAD(login_timestamp, 1) OVER (PARTITION BY user_id ORDER BY login_timestamp) as next_login\nFROM user_logins;\n```\n\nThis query retrieves a history of user logins and, for each login, it also shows the timestamp of that same user's **very next login**.\n\n**How it works:**\n* `LEAD(login_timestamp, 1)`: This is a window function that 'looks ahead' one row in the result set.\n* `OVER (...)`: This defines the window.\n* `PARTITION BY user_id`: This ensures the function operates independently for each user. It will only look at other logins from the same user.\n* `ORDER BY login_timestamp`: This sorts the logins for each user chronologically, which is essential for `LEAD` to correctly find the 'next' login in time.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain this query's use of a subquery in the `WHERE` clause.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  product_name,\n  list_price\nFROM products\nWHERE product_id IN (SELECT product_id FROM order_items WHERE quantity >= 100);\n```\n\nThis query finds the name and price of all products that have ever been part of a large order.\n\n**Logic:**\n1.  **Inner Query (Subquery):** The subquery `SELECT product_id FROM order_items WHERE quantity >= 100` executes first. It creates a list of all `product_id`s that appear in the `order_items` table with a quantity of 100 or more.\n2.  **Outer Query:** The outer query then selects the name and price from the main `products` table. The `WHERE product_id IN (...)` clause filters this result, keeping only the products whose `product_id` is present in the list generated by the subquery.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAnalyze the following query. What is its objective and how does it use a derived table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  category_name,\n  AVG(product_count) as avg_products_per_brand\nFROM (\n  SELECT\n    p.category_name,\n    p.brand_name,\n    COUNT(p.product_id) as product_count\n  FROM products p\n  GROUP BY p.category_name, p.brand_name\n) AS BrandCounts\nGROUP BY category_name;\n```\n\nThe objective of this query is to calculate the **average number of products per brand, for each product category**.\n\n**How it uses a derived table:**\n1.  **Inner Query (Derived Table):** The inner query, aliased as `BrandCounts`, is a derived table. It first calculates the number of products for each unique combination of category and brand (`product_count`).\n2.  **Outer Query:** The outer query then treats the `BrandCounts` derived table as a real table. It groups the results by `category_name` and calculates the `AVG(product_count)` for each category, giving the average number of products a brand has within that category.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the purpose of this `DELETE` statement with a `JOIN`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE oi\nFROM order_items oi\nJOIN orders o ON oi.order_id = o.order_id\nWHERE o.status = 'cancelled';\n```\n\nThis query is designed to clean up data by **deleting all line items that belong to cancelled orders**.\n\n**How it works:**\n* It targets the `order_items` table (aliased as `oi`) for deletion.\n* It joins `order_items` with the `orders` table (aliased as `o`) on `order_id` to link line items to their parent order.\n* The `WHERE o.status = 'cancelled'` clause filters the joined result to find only the line items associated with orders that have been marked as 'cancelled'.\n* Finally, the `DELETE oi` command removes these filtered rows from the `order_items` table.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe what this query calculates using `SUM` as a window function.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  order_date,\n  daily_revenue,\n  SUM(daily_revenue) OVER (ORDER BY order_date) AS running_total_revenue\nFROM daily_sales_summary;\n```\n\nThis query calculates a **running total** of revenue over time.\n\n**Explanation:**\n* It selects the `order_date` and `daily_revenue` from a summary table.\n* The window function `SUM(daily_revenue) OVER (ORDER BY order_date)` calculates the cumulative sum of `daily_revenue`. The `ORDER BY order_date` clause is crucial; it tells the function to sum the current day's revenue with the sum of all previous days' revenue, proceeding chronologically. The result is a third column, `running_total_revenue`, that shows the total accumulated revenue up to that date.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the logic of this query which uses `NOT EXISTS` to find unmatched records.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT d.department_name\nFROM departments d\nWHERE NOT EXISTS (\n  SELECT 1\n  FROM employees e\n  WHERE e.department_id = d.department_id\n);\n```\n\nThis query's purpose is to find all **departments that have no employees**.\n\n**Logic:**\nThis is an example of an **anti-join**. The outer query selects department names. The `WHERE NOT EXISTS` clause checks a condition for each department. The inner subquery tries to find at least one employee (`SELECT 1` is an efficient way to check for existence) whose `department_id` matches the current department from the outer query. \n* If the subquery finds a match, `EXISTS` would be true, so `NOT EXISTS` is false, and the department is discarded.\n* If the subquery finds no matching employees, `EXISTS` is false, making `NOT EXISTS` true, and the department name is included in the final result.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is this query trying to achieve by using a `PIVOT` operator?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT StudentName, [Math], [Science], [History]\nFROM (\n  SELECT StudentName, Subject, Grade\n  FROM StudentGrades\n) AS SourceTable\nPIVOT (\n  MAX(Grade)\n  FOR Subject IN ([Math], [Science], [History])\n) AS PivotTable;\n```\n\nThis query is using the `PIVOT` operator to **transform rows of student grades into a crosstab report**.\n\n**Objective:** It takes a normalized table where each row is a student's grade in a single subject and transforms it into a denormalized view where each row represents a single student, with their grades for Math, Science, and History displayed in separate columns. This format is much easier for humans to read.\n\n**How it works:**\n1.  **Source Table:** It selects the source data.\n2.  **`PIVOT` Clause:** It tells the database to: \n    * Aggregate the `Grade` column (using `MAX` in this case, though `AVG` or `SUM` could be used if there were multiple entries).\n    * Take the unique values from the `Subject` column ('Math', 'Science', 'History') and turn them into new column headers.\n    * Populate the new columns with the aggregated grades.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the function of this query that uses `CROSS APPLY`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  c.customer_name,\n  t5.order_id,\n  t5.order_date\nFROM customers c\nCROSS APPLY (\n  SELECT TOP 5 order_id, order_date\n  FROM orders o\n  WHERE o.customer_id = c.customer_id\n  ORDER BY order_date DESC\n) AS t5;\n```\n\nThis query retrieves the **five most recent orders for each customer**.\n\n**How it works:**\nThis cannot be easily done with a standard `JOIN`. The `CROSS APPLY` operator evaluates the subquery on the right for **each row** from the table on the left (`customers`).\n1.  For each customer `c` from the `customers` table...\n2.  ...it executes the subquery `SELECT TOP 5 ...` which finds the 5 most recent orders specifically for that customer (`WHERE o.customer_id = c.customer_id`).\n3.  `CROSS APPLY` then combines the customer's information with the 5 orders found by the subquery.\nIf a customer has no orders, they will not appear in the final result, similar to an `INNER JOIN`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `GROUPING SETS` clause in this query?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  brand,\n  category,\n  SUM(sales) as total_sales\nFROM product_sales\nGROUP BY GROUPING SETS (\n  (brand, category),\n  (brand),\n  (category),\n  ()\n);\n```\n\nThe purpose of `GROUPING SETS` is to generate **multiple levels of aggregation in a single query**.\n\nThis specific query calculates:\n1.  ` (brand, category)`: The total sales for each unique combination of brand and category.\n2.  ` (brand)`: The subtotal of sales for each brand across all categories.\n3.  ` (category)`: The subtotal of sales for each category across all brands.\n4.  ` ()`: The grand total of all sales.\n\nThis is much more efficient than writing four separate queries and combining them with `UNION ALL`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain what this query does, paying close attention to the `ROW_NUMBER` function.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH NumberedDuplicates AS (\n  SELECT\n    customer_id,\n    email,\n    ROW_NUMBER() OVER(PARTITION BY email ORDER BY customer_id) as rn\n  FROM customers\n)\nDELETE FROM NumberedDuplicates WHERE rn > 1;\n```\n\nThis query is designed to **deduplicate records from the `customers` table based on the `email` column**, keeping only the record with the lowest `customer_id` for each email.\n\n**Step-by-step:**\n1.  **`NumberedDuplicates` CTE:** It uses the `ROW_NUMBER()` window function to assign a sequential number (`rn`) to rows.\n2.  **`PARTITION BY email`:** This is the key part. The row numbering restarts for each unique email address. \n3.  **`ORDER BY customer_id`:** Within each email group, the rows are ordered by `customer_id`. This means the original record (assuming lower IDs are older) for a given email will always get `rn = 1`.\n4.  **`DELETE` Statement:** The final statement deletes all rows from the CTE where the row number is greater than 1. This effectively removes all duplicate email records, preserving only the first one encountered.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe the logic of this query using the `LAG` window function.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  sale_date,\n  monthly_sales,\n  LAG(monthly_sales, 1, 0) OVER (ORDER BY sale_date) as previous_month_sales\nFROM monthly_reports;\n```\n\nThis query retrieves a list of monthly sales and, for each month, it also shows the **sales from the immediately preceding month**.\n\n**Logic:**\n* `LAG(monthly_sales, 1, 0)`: This window function 'looks back' one row (`1`) in the result set to get the `monthly_sales` value. The `0` is a default value to use if there is no preceding row (i.e., for the very first month in the dataset).\n* `OVER (ORDER BY sale_date)`: The `ORDER BY` clause is essential. It sorts the data chronologically, ensuring that the 'previous' row is indeed the previous month.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the following query which uses the `INTERSECT` operator.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT student_id, student_name FROM students_2024\nINTERSECT\nSELECT student_id, student_name FROM students_2025;\n```\n\nThis query uses the `INTERSECT` operator to find the **common records between two tables**. It will return a list of all students (`student_id` and `student_name`) who are present in **both** the `students_2024` table and the `students_2025` table. The `INTERSECT` operator also implicitly removes duplicate rows from its result set.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAnalyze this query. What does it do and why does it use a `LEFT JOIN` with a `WHERE ... IS NULL` check?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT c.customer_name\nFROM customers c\nLEFT JOIN orders o ON c.customer_id = o.customer_id\nWHERE o.order_id IS NULL;\n```\n\nThis query is designed to find all **customers who have never placed an order**.\n\n**Logic:**\nThis is a common pattern for finding unmatched records. \n1.  **`LEFT JOIN`:** It joins `customers` to `orders`. A `LEFT JOIN` ensures that **all** customers from the left table (`customers`) are included in the result, regardless of whether they have a matching order.\n2.  **`WHERE o.order_id IS NULL`:** For customers who have placed orders, the columns from the `orders` table (`o.order_id`, etc.) will be populated. For customers who have *never* placed an order, these columns will be `NULL`. The `WHERE` clause then filters the result set to keep only those rows where `o.order_id` is `NULL`, effectively isolating the customers without any orders.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the purpose of this query, which uses a `CASE` statement inside an aggregate function.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  product_category,\n  SUM(CASE WHEN country = 'USA' THEN sales_amount ELSE 0 END) AS sales_usa,\n  SUM(CASE WHEN country = 'Canada' THEN sales_amount ELSE 0 END) AS sales_canada\nFROM sales\nGROUP BY product_category;\n```\n\nThis query is performing a **conditional aggregation** to create a pivot table-like summary. Its purpose is to calculate the total sales revenue for the 'USA' and 'Canada' separately, for each product category, and display these totals in different columns.\n\n**How it works:**\n* It groups all sales records by `product_category`.\n* For the `sales_usa` column, the `CASE` statement inside the `SUM` function effectively tells the database: 'For this group, only sum the `sales_amount` for rows where the country is USA; for all other rows, add 0.'\n* It does the same thing for Canada in the `sales_canada` column.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe what this query accomplishes using `UNPIVOT`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT StudentName, Subject, Grade\nFROM (\n  SELECT StudentName, [Math], [Science], [History]\n  FROM StudentGrades_Crosstab\n) AS Crosstab\nUNPIVOT (\n  Grade FOR Subject IN ([Math], [Science], [History])\n) AS Unpivoted;\n```\n\nThis query uses the `UNPIVOT` operator to **transform columns of data back into rows**. It is the reverse of a `PIVOT` operation.\n\n**Objective:** It takes a denormalized crosstab report where each student has their grades in separate columns (`Math`, `Science`, `History`) and transforms it into a normalized table where each row represents a single grade for a specific subject. This format is much better for data storage and analysis.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the purpose of the `MERGE` statement in this query.\n<end_of_turn>\n<start_of_turn>model\n```sql\nMERGE INTO Products_Target AS T\nUSING Products_Source AS S\nON T.ProductID = S.ProductID\nWHEN MATCHED THEN\n  UPDATE SET T.Price = S.Price, T.Stock = S.Stock\nWHEN NOT MATCHED BY TARGET THEN\n  INSERT (ProductID, ProductName, Price, Stock) VALUES (S.ProductID, S.ProductName, S.Price, S.Stock)\nWHEN NOT MATCHED BY SOURCE THEN\n  DELETE;\n```\n\nThe `MERGE` statement is performing a **synchronization** operation, also known as an 'upsert'. Its purpose is to make the `Products_Target` table identical to the `Products_Source` table by performing inserts, updates, and deletes all in one atomic statement.\n\n**Logic:**\n1.  **`ON` Clause:** It matches rows between the target and source tables on `ProductID`.\n2.  **`WHEN MATCHED`:** If a product exists in both tables, it updates the price and stock in the target table.\n3.  **`WHEN NOT MATCHED BY TARGET`:** If a product exists in the source but not the target, it inserts the new product into the target table.\n4.  **`WHEN NOT MATCHED BY SOURCE`:** If a product exists in the target but has been removed from the source, it deletes that product from the target table.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAnalyze this query. What is it calculating and how does the window frame `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` affect the result?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  employee_id,\n  sale_month,\n  monthly_sales,\n  AVG(monthly_sales) OVER (\n    PARTITION BY employee_id \n    ORDER BY sale_month\n    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n  ) AS moving_avg_sales\nFROM employee_sales;\n```\n\nThis query calculates the **moving average of monthly sales for each employee** up to the current month.\n\n**How the window frame affects the result:**\n* `PARTITION BY employee_id`: The calculation is done independently for each employee.\n* `ORDER BY sale_month`: The rows for each employee are sorted chronologically.\n* **`ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`**: This is the window frame definition. It explicitly tells the `AVG` function to consider all rows from the beginning of the partition (`UNBOUNDED PRECEDING`) up to and including the current row (`CURRENT ROW`). This is how the 'moving' or 'cumulative' average is achieved. For each month, it calculates the average of that month's sales and all prior months' sales for that employee.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain what this PostgreSQL query is doing with JSON operators.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  product_id,\n  product_data ->> 'name' AS product_name,\n  (product_data -> 'details' ->> 'weight_kg')::numeric AS weight\nFROM products_json\nWHERE (product_data -> 'tags')::jsonb ? 'electronics';\n```\n\nThis PostgreSQL query is extracting structured data from a JSON column and filtering rows based on a value within a JSON array.\n\n**Explanation:**\n1.  **`->>` operator:** The `product_data ->> 'name'` part extracts the value of the 'name' key from the `product_data` JSON object and returns it as `text`.\n2.  **`->` operator:** The `product_data -> 'details'` part extracts the 'details' JSON object itself. The subsequent `->> 'weight_kg'` then extracts the 'weight_kg' value from that nested object as `text`. The `::numeric` is a cast to convert the text to a numeric type.\n3.  **`?` operator:** The `WHERE` clause filters the products. It first extracts the 'tags' array, casts it to `jsonb` for indexing benefits, and then the `?` operator checks if the array contains the top-level string 'electronics'.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the purpose of this query that uses `CROSS JOIN`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  s.size,\n  c.color\nFROM sizes s\nCROSS JOIN colors c;\n```\n\nThis query uses a `CROSS JOIN` to generate a **Cartesian product** of the two tables. Its purpose is to create a result set containing every possible combination of sizes and colors. If the `sizes` table has 3 sizes (S, M, L) and the `colors` table has 2 colors (Red, Blue), this query will produce 3 * 2 = 6 rows: (S, Red), (S, Blue), (M, Red), (M, Blue), (L, Red), (L, Blue). This is often used to generate master data for product variants.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe what the following query does, focusing on the `EXCEPT` operator.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT employee_id FROM AllEmployees\nEXCEPT\nSELECT employee_id FROM EmployeesOnLeave;\n```\n\nThis query uses the `EXCEPT` operator to find the difference between two sets of data. It will return a list of all `employee_id`s that are present in the `AllEmployees` table but are **not** present in the `EmployeesOnLeave` table. Essentially, it's getting a list of all currently active employees.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the logic of this query and the role of the `DISTINCT ON` clause in PostgreSQL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT DISTINCT ON (customer_id)\n  customer_id,\n  order_id,\n  order_date\nFROM orders\nORDER BY customer_id, order_date DESC;\n```\n\nThis PostgreSQL query is designed to find the **single most recent order for each customer**.\n\n**Role of `DISTINCT ON`:**\n`DISTINCT ON (customer_id)` is a PostgreSQL extension. It returns the first row for each unique value in the `customer_id` column. The 'first' row is determined by the `ORDER BY` clause. Since the query orders by `customer_id` first and then by `order_date DESC` (most recent first), the `DISTINCT ON` clause will pick the row with the latest `order_date` for each `customer_id`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is this query trying to achieve by using `NULLIF`?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  SUM(revenue) / NULLIF(SUM(transactions), 0) as avg_revenue_per_transaction\nFROM daily_stats;\n```\n\nThis query is calculating the average revenue per transaction, but it has been written defensively to **prevent a division-by-zero error**.\n\n**Role of `NULLIF`:**\nThe `NULLIF(expression1, expression2)` function returns `NULL` if the two expressions are equal; otherwise, it returns the first expression. Here, `NULLIF(SUM(transactions), 0)` will return the sum of transactions unless that sum is 0. If the sum is 0, it will return `NULL`. In SQL, any arithmetic operation involving `NULL` results in `NULL`, not an error. This ensures the query returns `NULL` instead of crashing if there were no transactions.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAnalyze this query. What does it do, and what is the purpose of the `WITH TIES` clause?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT TOP 5 WITH TIES\n  player_name,\n  score\nFROM player_scores\nORDER BY score DESC;\n```\n\nThis query retrieves the top 5 highest-scoring players.\n\n**Purpose of `WITH TIES`:**\nThe `WITH TIES` clause is used to handle ties in the ranking. If this query is run and the 5th and 6th players both have the same score, a normal `TOP 5` would arbitrarily pick one of them. `WITH TIES` ensures that **all rows that have the same score as the 5th player are also included** in the result. So, the query could return 5, 6, or more rows if there is a tie for 5th place.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the purpose of the `FORALL` statement in this Oracle PL/SQL block.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDECLARE\n  TYPE t_emp_ids IS TABLE OF employees.employee_id%TYPE;\n  v_emp_ids t_emp_ids := t_emp_ids(101, 102, 103);\nBEGIN\n  FORALL i IN v_emp_ids.FIRST..v_emp_ids.LAST\n    UPDATE employees\n    SET salary = salary * 1.10\n    WHERE employee_id = v_emp_ids(i);\nEND;\n```\n\nThe purpose of the `FORALL` statement in this PL/SQL block is **bulk processing** for performance optimization.\n\n**Explanation:**\nInstead of a standard `FOR` loop that would execute a separate `UPDATE` statement for each employee ID (causing repeated context switches between the PL/SQL and SQL engines), `FORALL` bundles all the `UPDATE` operations into a single call. It takes the entire collection (`v_emp_ids`) and sends it to the SQL engine at once, which then executes the `UPDATE` for each element in the collection. This significantly reduces overhead and is much faster for large DML operations.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe what this query is accomplishing using `STRING_AGG`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  p.category_name,\n  STRING_AGG(p.product_name, ', ') WITHIN GROUP (ORDER BY p.product_name ASC) AS product_list\nFROM products p\nGROUP BY p.category_name;\n```\n\nThis query is creating a **comma-separated list of all products within each category**.\n\n**How it works:**\n1.  **`GROUP BY`:** It first groups all rows by `category_name`.\n2.  **`STRING_AGG`:** This is a string aggregate function. For each category group, it concatenates the `product_name` from all rows in that group into a single string. \n3.  **Delimiter:** The `', '` specifies the delimiter to place between each product name.\n4.  **`WITHIN GROUP (ORDER BY ...)`:** This optional clause ensures that the product names within the concatenated list are sorted alphabetically.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain this query, which finds the median value of a column.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT PERCENTILE_CONT(0.5)\n  WITHIN GROUP (ORDER BY salary)\n  OVER (PARTITION BY department)\nas median_salary\nFROM employees;\n```\n\nThis query calculates the **median salary for each department**.\n\n**Explanation:**\n* `PERCENTILE_CONT(0.5)`: This is an analytic function that calculates a percentile. A percentile of 0.5 is, by definition, the median value.\n* `WITHIN GROUP (ORDER BY salary)`: This specifies that the percentile should be calculated based on the values in the `salary` column, after sorting them.\n* `OVER (PARTITION BY department)`: This makes it a window function (or analytic function). The `PARTITION BY` clause tells it to perform the median calculation independently for each department. The result is that every employee row will show the median salary for their respective department.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAnalyze this query using `CUBE`. What different levels of aggregation will it produce?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  region,\n  product_line,\n  SUM(sales) as total_sales\nFROM sales_data\nGROUP BY CUBE (region, product_line);\n```\n\nThis query uses the `CUBE` operator to generate a comprehensive set of subtotals for all possible combinations of the grouped columns.\n\nIt will produce the following levels of aggregation:\n1.  **Sales per (region, product_line):** The most detailed level.\n2.  **Sales per region:** Subtotals for each region across all product lines.\n3.  **Sales per product_line:** Subtotals for each product line across all regions.\n4.  **Grand Total:** A single row with the grand total of all sales across all regions and product lines.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the function of the `OFFSET` and `FETCH` clauses in this query?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  product_name,\n  price\nFROM products\nORDER BY price DESC\nOFFSET 20 ROWS\nFETCH NEXT 10 ROWS ONLY;\n```\n\nThe `OFFSET` and `FETCH` clauses are used together to implement **server-side pagination**.\n\n**Function:**\n* **`ORDER BY`:** First, the entire `products` table is sorted by price in descending order.\n* **`OFFSET 20 ROWS`:** This clause then tells the database to **skip** the first 20 rows of that sorted result.\n* **`FETCH NEXT 10 ROWS ONLY`:** Finally, this clause tells the database to **return** the next 10 rows after the offset.\n\nIn essence, this query retrieves the products that are ranked 21st through 30th in price.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain what this query does and the purpose of the cast to `::date`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  (created_at AT TIME ZONE 'UTC' AT TIME ZONE 'America/New_York')::date as local_date,\n  COUNT(user_id) as new_users\nFROM users\nGROUP BY local_date\nORDER BY local_date;\n```\n\nThis query calculates the **number of new users per day, adjusted for the 'America/New_York' timezone**.\n\n**Explanation:**\n1.  **`AT TIME ZONE 'UTC'`:** It first interprets the `created_at` timestamp (which is likely stored without a timezone) as being in UTC.\n2.  **`AT TIME ZONE 'America/New_York'`:** It then converts that UTC timestamp into the corresponding date and time in the New York timezone. This correctly handles conversions across midnight.\n3.  **`::date`:** The cast to `date` then truncates the time part, leaving only the local date in the New York timezone.\n4.  **`GROUP BY`:** Finally, it groups by this adjusted local date to count the number of users who signed up on each day according to that timezone.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is this query accomplishing with the `GENERATE_SERIES` function?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT calendar_date::date\nFROM GENERATE_SERIES('2025-01-01'::timestamp, '2025-12-31'::timestamp, '1 day'::interval) calendar_date;\n```\n\nThis query uses the `GENERATE_SERIES` function (common in PostgreSQL) to **create a complete calendar table for the year 2025**.\n\n**How it works:**\n`GENERATE_SERIES` is a set-returning function. It takes a start value, an end value, and a step interval. In this case, it generates a timestamp for every day starting from January 1st, 2025, up to December 31st, 2025, incrementing by '1 day' for each step. The final cast to `::date` removes the time component, resulting in a single column table containing every date in 2025.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the role of the `DISTINCT` keyword in this aggregate function.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  department,\n  COUNT(DISTINCT employee_id) as distinct_employees\nFROM sales_records\nGROUP BY department;\n```\n\nThe role of the `DISTINCT` keyword inside the `COUNT` function is to **count only the unique values** in the specified column for each group.\n\nIn this query, an employee might have multiple sales records. A simple `COUNT(employee_id)` would count every sale. However, `COUNT(DISTINCT employee_id)` ensures that each employee is only counted once per department, regardless of how many sales records they have. The query is therefore calculating the number of unique employees who made sales in each department.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `DEFAULT` constraint in this `CREATE TABLE` statement?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE orders (\n  order_id INT PRIMARY KEY,\n  order_date DATE NOT NULL,\n  status VARCHAR(20) NOT NULL DEFAULT 'Pending',\n  customer_id INT\n);\n```\n\nThe purpose of the `DEFAULT 'Pending'` constraint on the `status` column is to **automatically provide a value for that column if one is not specified** during an `INSERT` operation.\n\nIf a new row is inserted into the `orders` table without a value for the `status` column, the database will automatically set its value to 'Pending'. This is useful for ensuring data consistency and simplifying `INSERT` statements for columns that have a common initial state.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain this query, which uses `LATERAL` join.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  c.customer_name,\n  t5.order_id,\n  t5.order_date\nFROM customers c, \nLATERAL (\n  SELECT order_id, order_date\n  FROM orders o\n  WHERE o.customer_id = c.customer_id\n  ORDER BY order_date DESC\n  LIMIT 5\n) AS t5;\n```\n\nThis query uses a `LATERAL` join to retrieve the **five most recent orders for each customer**.\n\n**How it works:**\nA `LATERAL` join allows a subquery in the `FROM` clause to reference columns from a preceding table in the same `FROM` clause (in this case, `c.customer_id`).\n1.  For each row `c` from the `customers` table...\n2.  ...it executes the `LATERAL` subquery. This subquery can see the `customer_id` from the current customer and finds the 5 most recent orders specifically for them.\n3.  The results are then joined together. This is the standard SQL equivalent of the `CROSS APPLY` operator in SQL Server.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe the function of this query that uses `ARRAY_AGG` in PostgreSQL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  d.department_name,\n  ARRAY_AGG(e.employee_name ORDER BY e.hire_date) as employees\nFROM departments d\nJOIN employees e ON d.department_id = e.department_id\nGROUP BY d.department_name;\n```\n\nThis PostgreSQL query is designed to **aggregate employee names into an array for each department**.\n\n**Function:**\n* **`GROUP BY`:** It groups the rows by `department_name`.\n* **`ARRAY_AGG`:** This is an aggregate function that collects all the values from the `employee_name` column within each group and puts them into a single PostgreSQL array.\n* **`ORDER BY`:** The `ORDER BY e.hire_date` clause inside the aggregate function is optional but ensures that the names within each array are ordered by the employee's hire date.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain this query which uses `FIRST_VALUE`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  product_id,\n  sale_date,\n  FIRST_VALUE(sale_date) OVER (PARTITION BY product_id ORDER BY sale_date) as first_sale_date\nFROM product_sales;\n```\n\nThis query retrieves all product sales records and, for each record, it also shows the **date of the very first sale for that specific product**.\n\n**Explanation:**\n* `FIRST_VALUE(sale_date)`: This window function is instructed to find the first value of the `sale_date` column within its window.\n* `OVER (PARTITION BY product_id ...)`: This partitions the data by product, so the function looks for the first sale date independently for each product.\n* `ORDER BY sale_date`: This sorts the sales for each product chronologically, ensuring that the 'first' value is indeed the earliest date.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the purpose of the `CHECK` constraint in this statement?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE products (\n  product_id INT PRIMARY KEY,\n  product_name VARCHAR(100),\n  unit_price DECIMAL(10, 2) NOT NULL CHECK (unit_price > 0),\n  stock INT NOT NULL CHECK (stock >= 0)\n);\n```\n\nThe purpose of a `CHECK` constraint is to **enforce a specific business rule on the values within a column**. It ensures data integrity by limiting the range of valid data.\n\nIn this example:\n* `CHECK (unit_price > 0)` ensures that a product cannot be created or updated with a zero or negative price.\n* `CHECK (stock >= 0)` ensures that the stock level for a product can never be a negative number.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain the following `INSERT ... ON CONFLICT` statement in PostgreSQL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO customers (id, name, last_updated)\nVALUES (123, 'John Doe', NOW())\nON CONFLICT (id) DO UPDATE\nSET name = EXCLUDED.name, last_updated = EXCLUDED.last_updated;\n```\n\nThis PostgreSQL statement is performing an **'upsert'** operation.\n\n**Logic:**\n1.  **`INSERT`:** It first attempts to insert a new record for a customer with `id` 123.\n2.  **`ON CONFLICT (id)`:** If the `INSERT` fails because a customer with `id` 123 already exists (violating a unique constraint or primary key on the `id` column), it triggers the conflict clause.\n3.  **`DO UPDATE`:** Instead of throwing an error, it then executes the `UPDATE` statement. It updates the existing record's `name` and `last_updated` fields with the values that *would have been* inserted (`EXCLUDED.name`, `EXCLUDED.last_updated`).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDescribe the goal of this query, which uses a self-join on the same table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT\n  e1.employee_name as employee,\n  e2.employee_name as manager\nFROM employees e1\nLEFT JOIN employees e2 ON e1.manager_id = e2.employee_id;\n```\n\nThe goal of this query is to produce a list of **every employee and the name of their corresponding manager**.\n\n**How it works:**\nIt performs a **self-join** by joining the `employees` table to itself. \n* `e1` is an alias that represents the employee.\n* `e2` is an alias that represents the manager.\n* The join condition `e1.manager_id = e2.employee_id` links an employee's record to their manager's record.\n* A `LEFT JOIN` is used to ensure that even top-level employees with no manager (`manager_id` is NULL) are included in the list, with their manager's name showing as `NULL`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nExplain what this query does and why it might be using `UNION ALL` instead of `UNION`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT user_id, action, timestamp FROM web_logs_archive_2024\nUNION ALL\nSELECT user_id, action, timestamp FROM web_logs_current;\n```\n\nThis query combines the historical web logs from the `web_logs_archive_2024` table with the logs from the `web_logs_current` table into a single, unified result set.\n\n**Why `UNION ALL`?**\n`UNION ALL` is used instead of `UNION` for **performance**. `UNION` would perform the extra step of checking for and removing any duplicate rows between the two tables. Since these tables represent distinct time periods (archive vs. current), it's highly unlikely there are duplicates. By using `UNION ALL`, the developer avoids this unnecessary and costly duplicate check, making the query run much faster.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query is intended to find product categories where the average price is over $50, but it fails. Identify the error, explain it, and provide the corrected query.\n<end_of_turn>\n<start_of_turn>model\nThe error is **using an aggregate function (`AVG`) in the `WHERE` clause.**\n\n**Explanation:** The `WHERE` clause filters individual rows *before* aggregation. The `AVG(price)` is calculated on the groups formed by `GROUP BY`, so it cannot be used in the `WHERE` clause.\n\n**Correction:** You must use the `HAVING` clause to filter based on the result of an aggregate function.\n\n**Corrected Query:**\n```sql\nSELECT category, AVG(price)\nFROM products\nGROUP BY category\nHAVING AVG(price) > 50;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThe following query attempts to select the top 10 most expensive products, but the syntax is incorrect. Fix the query.\n<end_of_turn>\n<start_of_turn>model\nThe logical error is in the `ORDER BY` clause. To find the *most* expensive products, the sorting must be in descending order.\n\n**Explanation:** `ORDER BY price` defaults to ascending order (`ASC`), which would return the 10 *least* expensive products.\n\n**Correction:** Add the `DESC` keyword to the `ORDER BY` clause.\n\n**Corrected Query:**\n```sql\nSELECT TOP 10 product_name, price\nFROM products\nORDER BY price DESC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query tries to join `users` and `logs`, but it causes a syntax error. Find and fix the error.\n<end_of_turn>\n<start_of_turn>model\nThe error is the use of an implicit `JOIN` syntax, which is outdated and less clear. The modern explicit `JOIN` syntax is preferred. While not always a syntax error in all SQL dialects, it's poor practice. The likely error for modern systems is mixing syntaxes if other joins were present.\n\n**Explanation:** Modern SQL standards favor using the `JOIN` keyword to specify the join and the `ON` keyword to specify the join condition. This separates join logic from filtering logic (`WHERE`).\n\n**Correction:** Rewrite the query using the explicit `JOIN ... ON` syntax.\n\n**Corrected Query:**\n```sql\nSELECT u.user_name, l.log_message\nFROM users u\nJOIN logs l ON u.user_id = l.user_id;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query attempts to count employees per department but produces a 'column must appear in the GROUP BY clause or be used in an aggregate function' error. Fix it.\n<end_of_turn>\n<start_of_turn>model\nThe error is that the `department_name` column is in the `SELECT` list but not in the `GROUP BY` clause or an aggregate function.\n\n**Explanation:** When you use `GROUP BY`, any non-aggregated column in the `SELECT` list must also be in the `GROUP BY` clause. This is because the database needs to know which `department_name` to show for the grouped `department_id` count.\n\n**Correction:** Add `department_name` to the `GROUP BY` clause.\n\n**Corrected Query:**\n```sql\nSELECT department_id, department_name, COUNT(employee_id)\nFROM employees\nGROUP BY department_id, department_name;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nA developer wants all customers whose name starts with 'A'. This query is very slow on a large table. Identify the performance issue and suggest a better query.\n<end_of_turn>\n<start_of_turn>model\nThe performance issue is that the query is **not SARGable**. Applying a function (`SUBSTRING`) to the indexed column (`customer_name`) prevents the database from using an index efficiently, forcing a full table scan.\n\n**Explanation:** The database cannot seek directly to the 'A' section of the index because it has to calculate the `SUBSTRING` for every single row first.\n\n**Correction:** Use the `LIKE` operator, which is designed for pattern matching and can use an index when the wildcard is not at the beginning.\n\n**Corrected Query:**\n```sql\nSELECT customer_name FROM customers WHERE customer_name LIKE 'A%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query attempts to insert multiple rows, but the syntax is invalid for standard SQL. Correct the query.\n<end_of_turn>\n<start_of_turn>model\nThe error is the repeated use of the `VALUES` keyword.\n\n**Explanation:** For a multi-row insert, the `VALUES` keyword should only be used once, followed by a comma-separated list of row value tuples.\n\n**Correction:** Remove the second `VALUES` keyword.\n\n**Corrected Query:**\n```sql\nINSERT INTO products (product_name, price)\nVALUES\n  ('Keyboard', 75),\n  ('Mouse', 25);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query tries to find customers who live in a `NULL` city, but it returns no results. Explain the error and fix it.\n<end_of_turn>\n<start_of_turn>model\nThe error is comparing a column to `NULL` using the `=` operator.\n\n**Explanation:** In SQL, `NULL` represents an unknown value. Any comparison with `NULL` using standard operators (`=`, `<>`) results in `UNKNOWN`, not `TRUE`. Therefore, the `WHERE` clause never succeeds.\n\n**Correction:** You must use the `IS NULL` operator to check for nullity.\n\n**Corrected Query:**\n```sql\nSELECT customer_name FROM customers WHERE city IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query uses an alias in the `WHERE` clause, which causes an error. Explain why this happens and correct the query.\n<end_of_turn>\n<start_of_turn>model\nThe error occurs because you cannot reference a column alias defined in the `SELECT` list within the `WHERE` clause of the same query.\n\n**Explanation:** This is due to the logical order of operations in SQL, where the `WHERE` clause is processed *before* the `SELECT` clause. At the time the `WHERE` clause is evaluated, the alias `total_with_tax` does not yet exist.\n\n**Correction:** Repeat the calculation in the `WHERE` clause or use a derived table/CTE.\n\n**Corrected Query (simple):**\n```sql\nSELECT order_total * 1.1 AS total_with_tax\nFROM orders\nWHERE (order_total * 1.1) > 1000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query tries to find the second highest salary, but it will fail if there are ties. Correct the query to handle ties properly.\n<end_of_turn>\n<start_of_turn>model\nThe error is that this approach doesn't handle ties for the highest salary and will incorrectly return the third-highest salary if two people share the top spot. It's also inefficient.\n\n**Explanation:** A better, more robust approach is to use window functions to rank the salaries and select the second one.\n\n**Correction:** Use `DENSE_RANK` to handle ties without skipping ranks.\n\n**Corrected Query:**\n```sql\nWITH RankedSalaries AS (\n  SELECT\n    salary,\n    DENSE_RANK() OVER (ORDER BY salary DESC) as rank_num\n  FROM employees\n)\nSELECT salary FROM RankedSalaries WHERE rank_num = 2;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query attempts to delete duplicate emails, but its syntax is invalid. Fix the query.\n<end_of_turn>\n<start_of_turn>model\nThe error is a logical one in how it identifies duplicates. While this syntax might work, it's often inefficient and less readable than using a window function.\n\n**Explanation:** A more modern and often more performant way to handle this is to use a CTE with a window function like `ROW_NUMBER` to identify the duplicates and then delete them.\n\n**Correction:** Use a CTE to number the rows for each email, then delete any row that isn't the first one.\n\n**Corrected Query:**\n```sql\nWITH NumberedCustomers AS (\n  SELECT\n    customer_id,\n    ROW_NUMBER() OVER(PARTITION BY email ORDER BY customer_id) as rn\n  FROM customers\n)\nDELETE FROM NumberedCustomers WHERE rn > 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis `UPDATE` statement is dangerous because it's missing a clause. Identify the missing clause and explain the risk.\n<end_of_turn>\n<start_of_turn>model\nThe missing, and critically important, clause is the **`WHERE` clause**.\n\n**Explanation:** Without a `WHERE` clause, this `UPDATE` statement will set the `is_active` column to 0 for **every single row** in the `products` table. This is a huge risk as it would unintentionally deactivate all products. An `UPDATE` statement should almost always have a `WHERE` clause to specify which rows to modify.\n\n**Correction (Example):**\n```sql\nUPDATE products\nSET is_active = 0\nWHERE stock_quantity = 0;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query tries to combine results from two tables but has a syntax error. Correct it.\n<end_of_turn>\n<start_of_turn>model\nThe error is that the `SELECT` statements in a `UNION` operation have a different number of columns.\n\n**Explanation:** To use `UNION` or `UNION ALL`, the queries being combined must have the same number of columns in their result sets, and the corresponding columns must have compatible data types.\n\n**Correction:** Either add the missing column (or a `NULL` placeholder) to the first query, or remove the extra column from the second query, depending on the desired output.\n\n**Corrected Query (with placeholder):**\n```sql\nSELECT id, name, NULL as hire_date FROM employees\nUNION\nSELECT id, name, hire_date FROM contractors;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query attempts a full outer join, but the `ON` condition is placed incorrectly, causing a syntax error.\n<end_of_turn>\n<start_of_turn>model\nThe error is using the `WHERE` clause to specify the join condition for an `OUTER JOIN`.\n\n**Explanation:** For `OUTER JOIN`s (`LEFT`, `RIGHT`, `FULL`), the join condition must be placed in the `ON` clause. Using `WHERE` would implicitly convert the `OUTER JOIN` into an `INNER JOIN` because it would filter out the rows where the condition is not met (i.e., the `NULL`s created by the outer join).\n\n**Correction:** Replace `WHERE` with the `ON` keyword.\n\n**Corrected Query:**\n```sql\nSELECT c.customer_name, o.order_date\nFROM customers c\nFULL OUTER JOIN orders o ON c.customer_id = o.customer_id;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query produces an incorrect result because of `NULL` values in the `commission` column. Explain the issue and fix the query.\n<end_of_turn>\n<start_of_turn>model\nThe issue is that any arithmetic operation with `NULL` results in `NULL`. If an employee's `commission` is `NULL`, their entire `base_salary + commission` calculation will be `NULL` and they will be excluded from the `AVG` calculation, leading to an incorrect average.\n\n**Explanation:** The query only averages the compensation for employees who have a non-null commission.\n\n**Correction:** Use a function like `COALESCE` or `ISNULL` to treat `NULL` commissions as 0.\n\n**Corrected Query:**\n```sql\nSELECT AVG(base_salary + COALESCE(commission, 0)) as avg_total_comp FROM employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis `COUNT` query is not giving the expected result. Explain the difference between `COUNT(*)` and `COUNT(column)` and provide the likely correct query.\n<end_of_turn>\n<start_of_turn>model\nThe error is a logical one. The query is counting only the employees who have a manager, not the total number of employees.\n\n**Explanation:** `COUNT(column)` counts the number of **non-NULL** values in that specific column. `COUNT(*)` counts the total number of rows in the table, regardless of `NULL` values. Since some employees (like the CEO) may have a `NULL` `manager_id`, `COUNT(manager_id)` will give a lower number than the total employee count.\n\n**Correction (to count all employees):**\n```sql\nSELECT COUNT(*) FROM employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query attempts to use a window function but has a syntax error in the `OVER` clause. Fix it.\n<end_of_turn>\n<start_of_turn>model\nThe error is the incorrect order of clauses within the `OVER()` clause.\n\n**Explanation:** The `PARTITION BY` clause must come *before* the `ORDER BY` clause.\n\n**Correction:** Swap the order of `PARTITION BY` and `ORDER BY`.\n\n**Corrected Query:**\n```sql\nSELECT employee_name, salary, RANK() OVER (PARTITION BY department_id ORDER BY salary DESC)\nFROM employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query has a missing keyword, causing a syntax error when trying to create an alias.\n<end_of_turn>\n<start_of_turn>model\nThe error is the use of an implicit join. Modern syntax is explicit.\n\n**Explanation:** This query is using an old, implicit join syntax in the `FROM` clause. The modern, explicit `JOIN` syntax is clearer and less prone to errors, especially when mixing join types.\n\n**Correction:** Rewrite using an explicit `JOIN`.\n\n**Corrected Query:**\n```sql\nSELECT c.customer_name, o.order_date\nFROM customers AS c\nJOIN orders AS o ON c.customer_id = o.customer_id;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis query returns a Cartesian product by mistake. Identify the cause and fix it.\n<end_of_turn>\n<start_of_turn>model\nThe error is a **missing join condition**. The query is performing a `CROSS JOIN` (Cartesian product) because it hasn't been told how to relate the `customers` and `orders` tables.\n\n**Explanation:** This will join every customer with every single order, resulting in a massive and incorrect result set (customers * orders rows).\n\n**Correction:** Add a `WHERE` clause (for implicit joins) or an `ON` clause (for explicit joins) to link the tables correctly.\n\n**Corrected Query (Modern Syntax):**\n```sql\nSELECT c.customer_name, o.order_id\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis subquery with `NOT IN` returns an unexpected empty set because of `NULL`s. Explain the problem and show a better way to write the query.\n<end_of_turn>\n<start_of_turn>model\nThe problem occurs if the subquery (`SELECT id FROM table_b`) returns **any `NULL` values**. The `NOT IN` operator's logic evaluates to `UNKNOWN` when comparing against a list that contains a `NULL`, causing the entire query to return an empty set.\n\n**Explanation:** The condition `id NOT IN (1, 2, NULL)` is effectively `id <> 1 AND id <> 2 AND id <> NULL`. Since the `id <> NULL` part is always `UNKNOWN`, the whole condition fails.\n\n**Correction:** The safest and often most performant way to write this is with `NOT EXISTS`.\n\n**Corrected Query:**\n```sql\nSELECT a.name\nFROM table_a a\nWHERE NOT EXISTS (\n  SELECT 1 FROM table_b b WHERE b.id = a.id\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThis `CREATE TABLE` statement has a syntax error related to the primary key definition. Fix it.\n<end_of_turn>\n<start_of_turn>model\nThe syntax itself is generally correct for a composite primary key. The likely error is either a typo or a misunderstanding of how constraints are defined. However, assuming a simple primary key was intended, the syntax is overly complex.\n\n**Explanation:** For a single-column primary key, the constraint can be defined inline with the column definition, which is simpler and more readable.\n\n**Correction (for a single-column key):**\n```sql\nCREATE TABLE users (\n  user_id INT PRIMARY KEY,\n  username VARCHAR(50),\n  email VARCHAR(100)\n);\n```\n**Note:** If a composite key *was* intended, the original syntax is valid in most SQL dialects.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI have a new database. I need to create the `Departments` table. The columns should be `DeptID` (integer, primary key), `DeptName` (text, not null), and `Location` (text).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Departments (\n  DeptID INT PRIMARY KEY,\n  DeptName TEXT NOT NULL,\n  Location TEXT\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nNow, create the `Employees` table. It needs `EmpID` (integer, primary key), `FirstName` (text), `LastName` (text, not null), `Salary` (decimal), `HireDate` (date), `DeptID` (integer, foreign key referencing `Departments`), and `ManagerID` (integer, a self-referencing foreign key to `EmpID`).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Employees (\n  EmpID INT PRIMARY KEY,\n  FirstName TEXT,\n  LastName TEXT NOT NULL,\n  Salary DECIMAL(10, 2),\n  HireDate DATE,\n  DeptID INT,\n  ManagerID INT,\n  FOREIGN KEY (DeptID) REFERENCES Departments(DeptID),\n  FOREIGN KEY (ManagerID) REFERENCES Employees(EmpID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate the `Projects` table with `ProjectID` (integer, primary key), `ProjectName` (text, not null), `StartDate` (date), and `Budget` (decimal).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Projects (\n  ProjectID INT PRIMARY KEY,\n  ProjectName TEXT NOT NULL,\n  StartDate DATE,\n  Budget DECIMAL(12, 2)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFinally, I need a junction table `EmployeeProjects` to link employees to projects. It should have `EmpID` and `ProjectID` as a composite primary key, and `HoursWorked` (integer).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE EmployeeProjects (\n  EmpID INT,\n  ProjectID INT,\n  HoursWorked INT,\n  PRIMARY KEY (EmpID, ProjectID),\n  FOREIGN KEY (EmpID) REFERENCES Employees(EmpID),\n  FOREIGN KEY (ProjectID) REFERENCES Projects(ProjectID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUsing the `Employees` table, show me how to insert a new employee.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Employees (EmpID, FirstName, LastName, Salary, HireDate, DeptID, ManagerID)\nVALUES (101, 'Jane', 'Doe', 70000, '2023-05-15', 1, NULL);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add the 'Engineering' department (DeptID 1) in 'Building A' and the 'Sales' department (DeptID 2) in 'Building B' to the `Departments` table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Departments (DeptID, DeptName, Location)\nVALUES \n  (1, 'Engineering', 'Building A'),\n  (2, 'Sales', 'Building B');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFrom the `Employees` table, select the full name and salary of all employees.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT FirstName, LastName, Salary \nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWrite a query to find all employees who were hired after January 1, 2024.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID, FirstName, LastName, HireDate\nFROM Employees\nWHERE HireDate > '2024-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all employees with a salary between $50,000 and $70,000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID, FirstName, LastName, Salary\nFROM Employees\nWHERE Salary BETWEEN 50000 AND 70000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find all employees whose first name is 'John' or whose last name is 'Smith'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID, FirstName, LastName\nFROM Employees\nWHERE FirstName = 'John' OR LastName = 'Smith';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need to give a 10% raise to all employees in the 'Sales' department (DeptID 2). Write the query.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = Salary * 1.10\nWHERE DeptID = 2;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAn employee (EmpID 101) got married. How do I update her last name to 'Johnson'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET LastName = 'Johnson'\nWHERE EmpID = 101;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all projects that started before the year 2020?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Projects\nWHERE StartDate < '2020-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAn employee (EmpID 102) has left the company. Write the query to delete their record.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE EmpID = 102;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need a list of all employees and their department names. The `Employees` table has `DeptID` and `Departments` table has `DeptName`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.FirstName, \n  e.LastName, \n  d.DeptName\nFROM Employees e\nINNER JOIN Departments d ON e.DeptID = d.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me *all* departments and, if they have employees, list their names. Departments without employees should still be listed.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName, \n  e.FirstName, \n  e.LastName\nFROM Departments d\nLEFT JOIN Employees e ON d.DeptID = e.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWrite a query to list all employees who are their own managers.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID, FirstName, LastName\nFROM Employees\nWHERE EmpID = ManagerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need a list of each employee's name and their manager's name. Use a self-join.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e1.FirstName AS EmployeeName, \n  e2.FirstName AS ManagerName\nFROM Employees e1\nLEFT JOIN Employees e2 ON e1.ManagerID = e2.EmpID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many employees are in the `Employees` table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*) AS TotalEmployees\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the average salary of all employees?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT AVG(Salary) AS AverageSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the highest and lowest salary in the company?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  MAX(Salary) AS HighestSalary, \n  MIN(Salary) AS LowestSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the total number of employees in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  DeptID, \n  COUNT(EmpID) AS NumberOfEmployees\nFROM Employees\nGROUP BY DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need to see the average salary for each department. List the department name and the average salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName, \n  AVG(e.Salary) AS AverageSalary\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nGROUP BY d.DeptName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the total hours worked for each project. Use the `EmployeeProjects` and `Projects` tables.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProjectName, \n  SUM(ep.HoursWorked) AS TotalHours\nFROM EmployeeProjects ep\nJOIN Projects p ON ep.ProjectID = p.ProjectID\nGROUP BY p.ProjectName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWrite a query to find all departments that have an average salary greater than $65,000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName, \n  AVG(e.Salary) AS AverageSalary\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nGROUP BY d.DeptName\nHAVING AVG(e.Salary) > 65000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me projects where the total hours worked is more than 1000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProjectName, \n  SUM(ep.HoursWorked) AS TotalHours\nFROM EmployeeProjects ep\nJOIN Projects p ON ep.ProjectID = p.ProjectID\nGROUP BY p.ProjectName\nHAVING SUM(ep.HoursWorked) > 1000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the names of employees who earn more than the company's average salary. Use a subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT FirstName, LastName, Salary\nFROM Employees\nWHERE Salary > (SELECT AVG(Salary) FROM Employees);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWrite a query to find all employees who work in the 'Engineering' department. Use a subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID, FirstName, LastName\nFROM Employees\nWHERE DeptID IN (SELECT DeptID FROM Departments WHERE DeptName = 'Engineering');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who are not assigned to any projects. Use `NOT EXISTS`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT e.EmpID, e.FirstName, e.LastName\nFROM Employees e\nWHERE NOT EXISTS (\n  SELECT 1 \n  FROM EmployeeProjects ep \n  WHERE ep.EmpID = e.EmpID\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a new column `Email` (type text) to the `Employees` table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN Email TEXT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a `UNIQUE` constraint to the new `Email` column on the `Employees` table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD CONSTRAINT UQ_Employee_Email UNIQUE (Email);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI no longer need the `Location` column in the `Departments` table. How do I remove it?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Departments\nDROP COLUMN Location;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUse a Common Table Expression (CTE) to find the average salary of the 'Sales' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH SalesDept AS (\n  SELECT DeptID \n  FROM Departments \n  WHERE DeptName = 'Sales'\n)\nSELECT AVG(e.Salary) AS AvgSalesSalary\nFROM Employees e\nJOIN SalesDept sd ON e.DeptID = sd.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUse a window function to rank employees in each department by their salary, from highest to lowest.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  FirstName, \n  LastName, \n  DeptID, \n  Salary,\n  RANK() OVER (PARTITION BY DeptID ORDER BY Salary DESC) AS SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's salary and the average salary of their department on the same row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  EmpID, \n  FirstName, \n  DeptID, \n  Salary,\n  AVG(Salary) OVER (PARTITION BY DeptID) AS DeptAverageSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the salary of the employee hired immediately *before* each employee in the same department. Use `LAG`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  FirstName, \n  HireDate, \n  DeptID, \n  Salary,\n  LAG(Salary, 1, 0) OVER (PARTITION BY DeptID ORDER BY HireDate) AS PreviousHireSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCalculate a running total of the project budgets, ordered by their start date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProjectName, \n  StartDate, \n  Budget,\n  SUM(Budget) OVER (ORDER BY StartDate) AS CumulativeBudget\nFROM Projects;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWrite a query to find the department with the highest total salary expenditure.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName, \n  SUM(e.Salary) AS TotalSalary\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nGROUP BY d.DeptName\nORDER BY TotalSalary DESC\nLIMIT 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find all employees who have 'son' in their last name?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID, FirstName, LastName\nFROM Employees\nWHERE LastName LIKE '%son%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all projects that have a budget over $1,000,000 and started in 2024.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProjectID, ProjectName, Budget, StartDate\nFROM Projects\nWHERE Budget > 1000000 AND StartDate BETWEEN '2024-01-01' AND '2024-12-31';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view named `v_ProductRevenue` that shows the product name, category, and its total calculated revenue from all sales.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW v_ProductRevenue AS\nSELECT \n  p.ProductName, \n  p.Category, \n  SUM(oi.Quantity * oi.UnitPrice) AS TotalRevenue\nFROM Products p\nJOIN OrderItems oi ON p.ProductID = oi.ProductID\nGROUP BY p.ProductName, p.Category;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select all data from the `v_ProductRevenue` view I just created?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT *\nFROM v_ProductRevenue\nORDER BY TotalRevenue DESC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the top 3 best-selling products by total quantity sold.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProductName, \n  SUM(oi.Quantity) AS TotalQuantitySold\nFROM Products p\nJOIN OrderItems oi ON p.ProductID = oi.ProductID\nGROUP BY p.ProductName\nORDER BY TotalQuantitySold DESC\nLIMIT 3;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWrite a query to find all products that have *never* been sold. Use a `LEFT JOIN` and `IS NULL`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProductID, \n  p.ProductName\nFROM Products p\nLEFT JOIN OrderItems oi ON p.ProductID = oi.ProductID\nWHERE oi.OrderID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need to show the total revenue per day. Use the `Orders` and `OrderItems` tables.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  o.OrderDate, \n  SUM(oi.Quantity * oi.UnitPrice) AS DailyRevenue\nFROM Orders o\nJOIN OrderItems oi ON o.OrderID = oi.OrderID\nGROUP BY o.OrderDate\nORDER BY o.OrderDate;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWrite a query to find the 'Order Fill Rate' for products (what percentage of orders for a product are 'Shipped' vs. 'Cancelled').\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  oi.ProductID, \n  p.ProductName,\n  COUNT(o.OrderID) AS TotalOrders,\n  AVG(CASE WHEN o.Status = 'Shipped' THEN 1.0 ELSE 0.0 END) AS ShippedRate,\n  AVG(CASE WHEN o.Status = 'Cancelled' THEN 1.0 ELSE 0.0 END) AS CancelledRate\nFROM OrderItems oi\nJOIN Orders o ON oi.OrderID = o.OrderID\nJOIN Products p ON oi.ProductID = p.ProductID\nGROUP BY oi.ProductID, p.ProductName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI'm starting a new e-commerce database. First, create the `Customers` table. It needs `CustomerID` (integer, primary key), `CustomerName` (text, not null), `Email` (text, unique), and `JoinDate` (date).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Customers (\n  CustomerID INT PRIMARY KEY,\n  CustomerName TEXT NOT NULL,\n  Email TEXT UNIQUE,\n  JoinDate DATE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nNext, create the `Products` table with `ProductID` (integer, primary key), `ProductName` (text), `Category` (text), and `Price` (decimal, must be positive).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Products (\n  ProductID INT PRIMARY KEY,\n  ProductName TEXT NOT NULL,\n  Category TEXT,\n  Price DECIMAL(10, 2) CHECK (Price > 0)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nNow create the `Orders` table. It should have `OrderID` (integer, primary key), `CustomerID` (foreign key to `Customers`), `OrderDate` (date), and a `Status` (text, defaulting to 'Pending').\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Orders (\n  OrderID INT PRIMARY KEY,\n  CustomerID INT,\n  OrderDate DATE NOT NULL,\n  Status TEXT DEFAULT 'Pending',\n  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFinally, create the `OrderItems` junction table. It needs `OrderID` and `ProductID` as a composite primary key, `Quantity` (integer, positive), and `UnitPrice` (decimal).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE OrderItems (\n  OrderID INT,\n  ProductID INT,\n  Quantity INT CHECK (Quantity > 0),\n  UnitPrice DECIMAL(10, 2),\n  PRIMARY KEY (OrderID, ProductID),\n  FOREIGN KEY (OrderID) REFERENCES Orders(OrderID),\n  FOREIGN KEY (ProductID) REFERENCES Products(ProductID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me how to add two new customers to the `Customers` table in one statement.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Customers (CustomerID, CustomerName, Email, JoinDate)\nVALUES\n  (1, 'Alice Johnson', 'alice@example.com', '2023-01-10'),\n  (2, 'Bob Smith', 'bob@example.com', '2023-01-12');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I insert a new product, a 'Laptop', in the 'Electronics' category with a price of 1200.00?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Products (ProductID, ProductName, Category, Price)\nVALUES (101, 'Laptop', 'Electronics', 1200.00);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCustomer 1 (Alice) placed an order (OrderID 501) today. How do I record this in the `Orders` table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Orders (OrderID, CustomerID, OrderDate, Status)\nVALUES (501, 1, CURRENT_DATE, 'Processing');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nOrder 501 contains two items: 1 of Product 101 (Laptop) at 1200.00. How do I add this to `OrderItems`?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO OrderItems (OrderID, ProductID, Quantity, UnitPrice)\nVALUES (501, 101, 1, 1200.00);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all products from the 'Electronics' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID, ProductName, Price\nFROM Products\nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all customers who joined in 2023.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID, CustomerName, JoinDate\nFROM Customers\nWHERE JoinDate BETWEEN '2023-01-01' AND '2023-12-31';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all orders that are currently 'Pending' or 'Processing'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT OrderID, CustomerID, OrderDate, Status\nFROM Orders\nWHERE Status IN ('Pending', 'Processing');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products with a price over $100 in the 'Apparel' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID, ProductName, Price\nFROM Products\nWHERE Price > 100 AND Category = 'Apparel';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nThe price of the 'Laptop' (ProductID 101) has dropped to 1150.00. Update its price.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products\nSET Price = 1150.00\nWHERE ProductID = 101;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need to cancel all 'Pending' orders. Write a query to change their status to 'Cancelled'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders\nSET Status = 'Cancelled'\nWHERE Status = 'Pending';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all customers who joined before 2020?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Customers\nWHERE JoinDate < '2020-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need a list of customer names and the dates of all orders they placed.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  o.OrderDate\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nORDER BY c.CustomerName, o.OrderDate;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all customers and their order IDs. Include customers who have never placed an order.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  o.OrderID\nFROM Customers c\nLEFT JOIN Orders o ON c.CustomerID = o.CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWrite a query to get the customer name, product name, and quantity for every item in every order. This will require three tables.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  p.ProductName, \n  oi.Quantity\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nJOIN OrderItems oi ON o.OrderID = oi.OrderID\nJOIN Products p ON oi.ProductID = p.ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many customers are in the database?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*) AS TotalCustomers \nFROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCalculate the total revenue for OrderID 501 from the `OrderItems` table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT SUM(Quantity * UnitPrice) AS TotalRevenue\nFROM OrderItems\nWHERE OrderID = 501;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many orders has each customer placed? List customer name and order count.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  COUNT(o.OrderID) AS OrderCount\nFROM Customers c\nLEFT JOIN Orders o ON c.CustomerID = o.CustomerID\nGROUP BY c.CustomerName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the total number of products in each category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Category, \n  COUNT(ProductID) AS ProductCount\nFROM Products\nGROUP BY Category;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCalculate the total revenue for *every* order. List OrderID and the calculated total revenue.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  SUM(Quantity * UnitPrice) AS TotalRevenue\nFROM OrderItems\nGROUP BY OrderID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the average, max, and min price for products in the 'Electronics' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  AVG(Price) AS AveragePrice, \n  MAX(Price) AS MaxPrice, \n  MIN(Price) AS MinPrice\nFROM Products\nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all categories where the average product price is over $200.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Category, \n  AVG(Price) AS AveragePrice\nFROM Products\nGROUP BY Category\nHAVING AVG(Price) > 200;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all customers who have spent more than $1000 in total. (Hint: Join `Orders` and `OrderItems`).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  SUM(oi.Quantity * oi.UnitPrice) AS TotalSpent\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nJOIN OrderItems oi ON o.OrderID = oi.OrderID\nGROUP BY c.CustomerName\nHAVING SUM(oi.Quantity * oi.UnitPrice) > 1000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the names of all customers who have placed at least one order. Use a subquery with `IN`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerName\nFROM Customers\nWHERE CustomerID IN (SELECT DISTINCT CustomerID FROM Orders);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that are more expensive than the average price of all products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName, Price\nFROM Products\nWHERE Price > (SELECT AVG(Price) FROM Products);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all customers who have *never* placed an order. Use `NOT EXISTS`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT c.CustomerName\nFROM Customers c\nWHERE NOT EXISTS (\n  SELECT 1 \n  FROM Orders o \n  WHERE o.CustomerID = c.CustomerID\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUse a CTE to create a list of all 'Electronics' products, then select all products from that list with a price over $500.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH ElectronicsProducts AS (\n  SELECT ProductID, ProductName, Price\n  FROM Products\n  WHERE Category = 'Electronics'\n)\nSELECT ProductName, Price\nFROM ElectronicsProducts\nWHERE Price > 500;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUse a CTE to find the total revenue for each order, then join it with the `Orders` table to show the order date and revenue.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH OrderRevenue AS (\n  SELECT \n    OrderID, \n    SUM(Quantity * UnitPrice) AS TotalRevenue\n  FROM OrderItems\n  GROUP BY OrderID\n)\nSELECT \n  o.OrderDate, \n  o.Status, \n  r.TotalRevenue\nFROM Orders o\nJOIN OrderRevenue r ON o.OrderID = r.OrderID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need to rank all products by their price, from highest to lowest. Show the product name, price, and rank.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  RANK() OVER (ORDER BY Price DESC) AS PriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the rank of products by price *within each category*. Use `DENSE_RANK`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  DENSE_RANK() OVER (PARTITION BY Category ORDER BY Price DESC) AS CategoryPriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFor each customer, show their total number of orders, and also assign them to a 'Tier' based on their order count (e.g., using `NTILE`).\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH CustomerOrders AS (\n  SELECT\n    CustomerID,\n    COUNT(OrderID) AS OrderCount\n  FROM Orders\n  GROUP BY CustomerID\n)\nSELECT \n  c.CustomerName,\n  COALESCE(co.OrderCount, 0) AS OrderCount,\n  NTILE(4) OVER (ORDER BY COALESCE(co.OrderCount, 0) DESC) AS CustomerTier\nFROM Customers c\nLEFT JOIN CustomerOrders co ON c.CustomerID = co.CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each order's total revenue, and also the total revenue of the *previous* order (by date).\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH OrderRevenue AS (\n  SELECT \n    o.OrderDate,\n    o.OrderID,\n    SUM(oi.Quantity * oi.UnitPrice) AS TotalRevenue\n  FROM Orders o\n  JOIN OrderItems oi ON o.OrderID = oi.OrderID\n  GROUP BY o.OrderID, o.OrderDate\n)\nSELECT \n  OrderDate, \n  OrderID, \n  TotalRevenue,\n  LAG(TotalRevenue, 1, 0) OVER (ORDER BY OrderDate) AS PreviousOrderRevenue\nFROM OrderRevenue;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need to add a `PhoneNumber` column (text, can be null) to the `Customers` table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nADD COLUMN PhoneNumber TEXT NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the `JoinDate` column from the `Customers` table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nDROP COLUMN JoinDate;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a simple table named 'Students' with an 'id' and 'name'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Students (\n  id INT,\n  name VARCHAR(100)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'Users' with a 'UserID' that is the primary key.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Users (\n  UserID INT PRIMARY KEY,\n  Username VARCHAR(50),\n  Email VARCHAR(100)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Products' table where the 'SKU' must be unique.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Products (\n  ProductID INT PRIMARY KEY,\n  ProductName VARCHAR(100),\n  SKU VARCHAR(20) UNIQUE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Employees' table where the 'LastName' can never be null.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Employees (\n  EmpID INT PRIMARY KEY,\n  FirstName VARCHAR(50),\n  LastName VARCHAR(50) NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Products' table where 'Price' must be greater than 0. Use a CHECK constraint.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Products (\n  ProductID INT PRIMARY KEY,\n  ProductName VARCHAR(100),\n  Price DECIMAL(10, 2) CHECK (Price > 0)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Orders' table where the 'Status' column defaults to 'Pending' if no value is given.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Orders (\n  OrderID INT PRIMARY KEY,\n  OrderDate DATE,\n  Status VARCHAR(20) DEFAULT 'Pending'\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a 'Logs' table with an 'LogID' that automatically increments? (SQL Server syntax)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Logs (\n  LogID INT IDENTITY(1,1) PRIMARY KEY,\n  LogMessage TEXT,\n  CreatedAt DATETIME DEFAULT GETDATE()\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a 'Logs' table with an 'LogID' that automatically increments? (MySQL syntax)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Logs (\n  LogID INT AUTO_INCREMENT PRIMARY KEY,\n  LogMessage TEXT,\n  CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a 'Logs' table with an 'LogID' that automatically increments? (PostgreSQL syntax)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Logs (\n  LogID SERIAL PRIMARY KEY,\n  LogMessage TEXT,\n  CreatedAt TIMESTAMPTZ DEFAULT NOW()\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Departments' table. I'll use it as a parent table for 'Employees'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Departments (\n  DeptID INT PRIMARY KEY,\n  DeptName VARCHAR(100) NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Employees' table with a 'DeptID' that is a foreign key referencing the 'Departments' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Employees (\n  EmpID INT PRIMARY KEY,\n  Name VARCHAR(100),\n  DeptID INT,\n  FOREIGN KEY (DeptID) REFERENCES Departments(DeptID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I define a composite primary key? Use 'OrderID' and 'ProductID' in an 'OrderItems' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE OrderItems (\n  OrderID INT,\n  ProductID INT,\n  Quantity INT,\n  PRIMARY KEY (OrderID, ProductID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'AllDataTypes' to show common data types.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE AllDataTypes (\n  Col_Int INT,\n  Col_VarChar VARCHAR(255),\n  Col_Text TEXT,\n  Col_Decimal DECIMAL(10, 2),\n  Col_Date DATE,\n  Col_Timestamp TIMESTAMP,\n  Col_Boolean BOOLEAN\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'Inventory' with a 'Status' column that can only be 'In Stock', 'Out of Stock', or 'Backordered'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Inventory (\n  ItemID INT PRIMARY KEY,\n  ItemName VARCHAR(100),\n  Status VARCHAR(20) CHECK (Status IN ('In Stock', 'Out of Stock', 'Backordered'))\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a table 'Employees' and add a named foreign key constraint?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Employees (\n  EmpID INT PRIMARY KEY,\n  Name VARCHAR(100),\n  DeptID INT,\n  CONSTRAINT FK_Emp_Dept FOREIGN KEY (DeptID) REFERENCES Departments(DeptID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a table only if it does not already exist?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE IF NOT EXISTS MyTable (\n  ID INT PRIMARY KEY,\n  Description VARCHAR(100)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a new column 'Email' (VARCHAR(100)) to the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN Email VARCHAR(100);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove the 'Email' column from the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP COLUMN Email;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I change the data type of the 'Email' column in 'Employees' to TEXT? (PostgreSQL/Standard SQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nALTER COLUMN Email TYPE TEXT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I modify the 'Email' column in 'Employees' to TEXT? (MySQL syntax)\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nMODIFY COLUMN Email TEXT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I rename the 'Email' column to 'EmailAddress' in the 'Employees' table? (PostgreSQL/Standard SQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nRENAME COLUMN Email TO EmailAddress;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I rename the 'Employees' table to 'Staff'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nRENAME TO Staff;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a UNIQUE constraint to the 'Email' column in the 'Employees' table after it's been created?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD CONSTRAINT UQ_Email UNIQUE (Email);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a CHECK constraint to 'Employees' to ensure 'Salary' is always above 30000?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD CONSTRAINT CHK_Salary CHECK (Salary > 30000);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a Foreign Key constraint to 'Employees' after the table is created?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD CONSTRAINT FK_Emp_Dept FOREIGN KEY (DeptID) REFERENCES Departments(DeptID);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove a constraint? I want to drop the 'CHK_Salary' constraint from 'Employees'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP CONSTRAINT CHK_Salary;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select all columns from the 'Products' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select just the 'Name' and 'Price' from the 'Products' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, Price FROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select all employees from 'Department 5'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE DepartmentID = 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all products that cost more than $50.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Price > 50;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all employees named 'John'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE FirstName = 'John';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select all 'Electronics' products that are also over $100?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Category = 'Electronics' AND Price > 100;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select all employees who are in 'Department 1' OR 'Department 2'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE DepartmentID = 1 OR DepartmentID = 2;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I use the IN operator to select employees in 'Department 1' or 'Department 2'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE DepartmentID IN (1, 2);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select all products with a price between $50 and $100?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Price BETWEEN 50 AND 100;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find all employees whose first name starts with 'A'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE FirstName LIKE 'A%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find all employees whose last name ends with 'son'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE LastName LIKE '%son';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find all products that have 'Pro' anywhere in their name?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE ProductName LIKE '%Pro%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find employees with a 4-letter first name that starts with 'J' and ends with 'n'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE FirstName LIKE 'J__n';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find all employees who do not have a manager assigned?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE ManagerID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find all employees who DO have a manager assigned?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE ManagerID IS NOT NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select the list of all unique department IDs from the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT DISTINCT DepartmentID FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show all products, ordered by price from lowest to highest?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nORDER BY Price ASC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show all employees, ordered by salary from highest to lowest?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nORDER BY Salary DESC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I order employees by department, and then by last name alphabetically?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nORDER BY DepartmentID, LastName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select only the top 10 most expensive products? (SQL Server syntax)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT TOP 10 * FROM Products\nORDER BY Price DESC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select only the 10 most expensive products? (MySQL/PostgreSQL syntax)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nORDER BY Price DESC\nLIMIT 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select all employees and show their 'Salary' as 'MonthlyWage'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, Salary AS MonthlyWage\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me how to get the full name of employees as one column.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Standard SQL (||)\nSELECT FirstName || ' ' || LastName AS FullName\nFROM Employees;\n\n-- SQL Server (+)\n-- SELECT FirstName + ' ' + LastName AS FullName FROM Employees;\n\n-- MySQL (CONCAT)\n-- SELECT CONCAT(FirstName, ' ', LastName) AS FullName FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get the 3rd, 4th, and 5th employees when sorted by name? (Pagination)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Standard SQL\nSELECT * FROM Employees\nORDER BY Name\nOFFSET 2 ROWS\nFETCH NEXT 3 ROWS ONLY;\n\n-- MySQL\n-- SELECT * FROM Employees ORDER BY Name LIMIT 2, 3;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I insert a new employee (ID 101, Name 'John Smith') into the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Employees (EmpID, Name)\nVALUES (101, 'John Smith');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I insert multiple new products at once?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Products (ProductID, ProductName, Price)\nVALUES\n  (1, 'Keyboard', 60),\n  (2, 'Mouse', 25),\n  (3, 'Monitor', 200);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I insert all employees from 'OldEmployees' table into a new 'EmployeesArchive' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO EmployeesArchive (EmpID, Name, Salary)\nSELECT EmpID, Name, Salary\nFROM OldEmployees\nWHERE Status = 'Retired';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I give employee 101 a raise to $60,000?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = 60000\nWHERE EmpID = 101;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I give a 10% raise to everyone in 'Department 3'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = Salary * 1.10\nWHERE DepartmentID = 3;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I update employee 102's 'LastName' and 'DepartmentID' at the same time?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET LastName = 'Peterson', DepartmentID = 2\nWHERE EmpID = 102;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove employee 101 from the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE EmpID = 101;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all products that are in the 'Discontinued' category?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Category = 'Discontinued';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the query to delete ALL rows from the 'Logs' table? (DML)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- This will delete all rows. Be very careful!\nDELETE FROM Logs;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the fastest way to delete all rows from the 'Logs' table? (DDL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- This is faster as it's not logged per-row, but cannot be undone.\nTRUNCATE TABLE Logs;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I completely remove the 'Logs' table, including its structure?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP TABLE Logs;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I count all employees?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*) AS TotalEmployees\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I count how many employees have a manager assigned?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- COUNT(column) ignores NULLs\nSELECT COUNT(ManagerID) AS EmployeesWithManager\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I count the number of *unique* departments that have employees?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(DISTINCT DepartmentID) AS UniqueDepartments\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the total sum of all salaries paid?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT SUM(Salary) AS TotalSalaryPayout\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the average price of products in the 'Electronics' category?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT AVG(Price) AS AvgElectronicsPrice\nFROM Products\nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the highest salary in the company?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT MAX(Salary) AS HighestSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the cheapest product in the 'Books' category?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT MIN(Price) AS CheapestBook\nFROM Products\nWHERE Category = 'Books';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I count the number of employees in each department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT DepartmentID, COUNT(*) AS EmployeeCount\nFROM Employees\nGROUP BY DepartmentID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the average salary for each department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT DepartmentID, AVG(Salary) AS AverageSalary\nFROM Employees\nGROUP BY DepartmentID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the total number of products and total stock for each product category?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, COUNT(*) AS ProductCount, SUM(Stock) AS TotalStock\nFROM Products\nGROUP BY Category;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find only the departments that have more than 10 employees?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT DepartmentID, COUNT(*) AS EmployeeCount\nFROM Employees\nGROUP BY DepartmentID\nHAVING COUNT(*) > 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the average salary per department, but only for departments with an average salary over $50,000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT DepartmentID, AVG(Salary) AS AverageSalary\nFROM Employees\nGROUP BY DepartmentID\nHAVING AVG(Salary) > 50000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get the employee names and their department names? (Tables: Employees, Departments)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT e.Name, d.DeptName\nFROM Employees e\nINNER JOIN Departments d ON e.DeptID = d.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a simple table named 'Cars' with 'id' and 'make'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Cars (\n  id INT,\n  make VARCHAR(50)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'Employees' with an 'EmployeeID' (integer) and 'FullName' (text).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Employees (\n  EmployeeID INT,\n  FullName TEXT\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Products' table with 'ProductID' (integer) and 'Price' (decimal).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Products (\n  ProductID INT,\n  Price DECIMAL(10, 2)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'CalendarEvents' table with 'EventID', 'EventName' (varchar 100), and 'EventDate' (date).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE CalendarEvents (\n  EventID INT,\n  EventName VARCHAR(100),\n  EventDate DATE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Logs' table with 'LogID', 'Message' (text), and 'LogTime' (timestamp).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Logs (\n  LogID INT,\n  Message TEXT,\n  LogTime TIMESTAMP\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Settings' table with 'SettingID', 'SettingName', and 'IsActive' (boolean).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Settings (\n  SettingID INT,\n  SettingName VARCHAR(50),\n  IsActive BOOLEAN\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Students' table with 'StudentID' as an inline primary key.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Students (\n  StudentID INT PRIMARY KEY,\n  FirstName VARCHAR(50),\n  LastName VARCHAR(50)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Courses' table with 'CourseID' as the primary key, defined at the end of the statement.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Courses (\n  CourseID VARCHAR(10),\n  CourseName VARCHAR(100),\n  Credits INT,\n  PRIMARY KEY (CourseID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Users' table where 'UserID' is the primary key and 'Username' must be unique.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Users (\n  UserID INT PRIMARY KEY,\n  Username VARCHAR(30) UNIQUE,\n  Email VARCHAR(100)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Products' table where 'ProductName' cannot be null.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Products (\n  ProductID INT PRIMARY KEY,\n  ProductName VARCHAR(100) NOT NULL,\n  Price DECIMAL(10, 2)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Employees' table where 'EmpID' is the primary key and 'Email' must be unique and not null.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Employees (\n  EmpID INT PRIMARY KEY,\n  FullName VARCHAR(100),\n  Email VARCHAR(100) UNIQUE NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Inventory' table where 'Quantity' must be 0 or more. Use a CHECK constraint.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Inventory (\n  ItemID INT PRIMARY KEY,\n  ItemName VARCHAR(100),\n  Quantity INT CHECK (Quantity >= 0)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Orders' table where the 'Status' column has a default value of 'Pending'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Orders (\n  OrderID INT PRIMARY KEY,\n  OrderDate DATE,\n  CustomerID INT,\n  Status VARCHAR(20) DEFAULT 'Pending'\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Tasks' table where 'Priority' defaults to 3 and 'IsComplete' defaults to false.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Tasks (\n  TaskID INT PRIMARY KEY,\n  TaskName VARCHAR(255) NOT NULL,\n  Priority INT DEFAULT 3,\n  IsComplete BOOLEAN DEFAULT false\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Departments' parent table with 'DeptID' as its primary key.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Departments (\n  DeptID INT PRIMARY KEY,\n  DeptName VARCHAR(50) NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Employees' table with 'DeptID' as an inline foreign key referencing 'Departments'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Employees (\n  EmpID INT PRIMARY KEY,\n  Name VARCHAR(100),\n  DeptID INT REFERENCES Departments(DeptID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Orders' table with 'CustomerID' as a foreign key defined at the end of the statement.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Orders (\n  OrderID INT PRIMARY KEY,\n  OrderDate DATE,\n  CustomerID INT,\n  FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I define a composite primary key? Use 'OrderID' and 'ProductID' in an 'OrderItems' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE OrderItems (\n  OrderID INT,\n  ProductID INT,\n  Quantity INT,\n  PRIMARY KEY (OrderID, ProductID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Reviews' table with a 'Rating' column that must be between 1 and 5.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Reviews (\n  ReviewID INT PRIMARY KEY,\n  ProductID INT,\n  ReviewText TEXT,\n  Rating INT CHECK (Rating >= 1 AND Rating <= 5)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Students' table where 'EntryYear' must be after 2000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Students (\n  StudentID INT PRIMARY KEY,\n  Name VARCHAR(100),\n  EntryYear INT CHECK (EntryYear > 2000)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Products' table where 'Category' can only be 'Electronics', 'Books', or 'Apparel'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Products (\n  ProductID INT PRIMARY KEY,\n  ProductName VARCHAR(100),\n  Category VARCHAR(20) CHECK (Category IN ('Electronics', 'Books', 'Apparel'))\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Tasks' table where 'Status' can only be 'Todo', 'In Progress', or 'Done'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Tasks (\n  TaskID INT PRIMARY KEY,\n  Description TEXT,\n  Status VARCHAR(20) CHECK (Status IN ('Todo', 'In Progress', 'Done'))\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Employees' table with a 'Gender' column that can only be 'M', 'F', or 'O'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Employees (\n  EmpID INT PRIMARY KEY,\n  Name VARCHAR(100),\n  Gender CHAR(1) CHECK (Gender IN ('M', 'F', 'O'))\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Settings' table where 'Theme' defaults to 'Light' and can only be 'Light' or 'Dark'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Settings (\n  UserID INT PRIMARY KEY,\n  Theme VARCHAR(10) DEFAULT 'Light' CHECK (Theme IN ('Light', 'Dark'))\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table with a 'Discount' column that must be between 0 and 1.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Promotions (\n  PromoID INT PRIMARY KEY,\n  PromoName VARCHAR(50),\n  Discount DECIMAL(3, 2) CHECK (Discount >= 0.00 AND Discount <= 1.00)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'Users' with a 'CreatedAt' column that defaults to the current timestamp. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Users (\n  UserID INT PRIMARY KEY,\n  Username VARCHAR(50),\n  CreatedAt TIMESTAMPTZ DEFAULT NOW()\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'Users' with a 'CreatedAt' column that defaults to the current timestamp. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Users (\n  UserID INT PRIMARY KEY,\n  Username VARCHAR(50),\n  CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'Users' with a 'LastLogin' column that defaults to the current timestamp. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Users (\n  UserID INT PRIMARY KEY,\n  Username VARCHAR(50),\n  LastLogin DATETIME DEFAULT GETDATE()\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'Employees' where 'Salary' must be at least 25000 and 'Email' must be unique.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Employees (\n  EmpID INT PRIMARY KEY,\n  Name VARCHAR(100) NOT NULL,\n  Email VARCHAR(100) UNIQUE,\n  Salary DECIMAL(10, 2) CHECK (Salary >= 25000)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'Posts' with 'PostID' as an auto-incrementing primary key. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Posts (\n  PostID INT AUTO_INCREMENT PRIMARY KEY,\n  Title VARCHAR(255) NOT NULL,\n  Body TEXT\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'Posts' with 'PostID' as an auto-incrementing primary key. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Posts (\n  PostID SERIAL PRIMARY KEY,\n  Title VARCHAR(255) NOT NULL,\n  Body TEXT\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'Posts' with 'PostID' as an auto-incrementing primary key. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Posts (\n  PostID INT IDENTITY(1,1) PRIMARY KEY,\n  Title VARCHAR(255) NOT NULL,\n  Body TEXT\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a table 'Comments' that has a 'PostID' foreign key that references the 'Posts' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Comments (\n  CommentID INT PRIMARY KEY,\n  PostID INT,\n  CommentText TEXT,\n  FOREIGN KEY (PostID) REFERENCES Posts(PostID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Comments' table where if a 'Post' is deleted, the 'PostID' in 'Comments' becomes NULL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Comments (\n  CommentID INT PRIMARY KEY,\n  PostID INT,\n  CommentText TEXT,\n  FOREIGN KEY (PostID) REFERENCES Posts(PostID)\n  ON DELETE SET NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Comments' table where if a 'Post' is deleted, all its 'Comments' are also deleted.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Comments (\n  CommentID INT PRIMARY KEY,\n  PostID INT,\n  CommentText TEXT,\n  FOREIGN KEY (PostID) REFERENCES Posts(PostID)\n  ON DELETE CASCADE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Categories' table. 'Name' must be unique and not null.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Categories (\n  CategoryID INT PRIMARY KEY,\n  Name VARCHAR(50) UNIQUE NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Tags' table. 'TagName' must be unique.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Tags (\n  TagID INT PRIMARY KEY,\n  TagName VARCHAR(30) UNIQUE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'PostTags' junction table to link 'Posts' and 'Tags'. Use a composite primary key.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE PostTags (\n  PostID INT,\n  TagID INT,\n  PRIMARY KEY (PostID, TagID),\n  FOREIGN KEY (PostID) REFERENCES Posts(PostID) ON DELETE CASCADE,\n  FOREIGN KEY (TagID) REFERENCES Tags(TagID) ON DELETE CASCADE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Employees' table with a self-referencing foreign key for 'ManagerID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Employees (\n  EmpID INT PRIMARY KEY,\n  Name VARCHAR(100),\n  ManagerID INT,\n  FOREIGN KEY (ManagerID) REFERENCES Employees(EmpID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a table 'Students' and name the primary key constraint 'PK_Students'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Students (\n  StudentID INT NOT NULL,\n  Name VARCHAR(100),\n  CONSTRAINT PK_Students PRIMARY KEY (StudentID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a 'Products' table and name the unique constraint 'UQ_Products_SKU'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Products (\n  ProductID INT PRIMARY KEY,\n  SKU VARCHAR(50) NOT NULL,\n  CONSTRAINT UQ_Products_SKU UNIQUE (SKU)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create an 'Inventory' table and name the check constraint 'CHK_Inventory_Quantity'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Inventory (\n  ItemID INT PRIMARY KEY,\n  Quantity INT,\n  CONSTRAINT CHK_Inventory_Quantity CHECK (Quantity >= 0)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a 'Comments' table and name the foreign key constraint 'FK_Comments_Posts'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Comments (\n  CommentID INT PRIMARY KEY,\n  PostID INT,\n  CommentText TEXT,\n  CONSTRAINT FK_Comments_Posts FOREIGN KEY (PostID) REFERENCES Posts(PostID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Vehicles' table with 'VIN' (17 chars, fixed length) as the primary key.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Vehicles (\n  VIN CHAR(17) PRIMARY KEY,\n  Make VARCHAR(50),\n  Model VARCHAR(50),\n  Year INT\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Locations' table with 'Latitude' and 'Longitude' (use float or double precision).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Locations (\n  LocationID INT PRIMARY KEY,\n  LocationName VARCHAR(100),\n  Latitude DOUBLE PRECISION,\n  Longitude DOUBLE PRECISION\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Books' table with 'ISBN' (varchar 13) as a unique, non-null key.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Books (\n  BookID INT PRIMARY KEY,\n  Title VARCHAR(255) NOT NULL,\n  Author VARCHAR(100),\n  ISBN VARCHAR(13) UNIQUE NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'BankAccounts' table with 'Balance' that defaults to 0.00.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE BankAccounts (\n  AccountID INT PRIMARY KEY,\n  OwnerName VARCHAR(100),\n  Balance DECIMAL(12, 2) DEFAULT 0.00\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Drivers' table with 'LicenseID' as primary key and 'Age' that must be 18 or older.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Drivers (\n  LicenseID VARCHAR(20) PRIMARY KEY,\n  FullName VARCHAR(100),\n  Age INT CHECK (Age >= 18)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Flights' table where 'DepartureAirport' and 'ArrivalAirport' are both 3-char fixed length codes.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Flights (\n  FlightID INT PRIMARY KEY,\n  DepartureAirport CHAR(3) NOT NULL,\n  ArrivalAirport CHAR(3) NOT NULL,\n  DepartureTime TIMESTAMP\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Movies' table with 'Title' and 'ReleaseYear' (integer).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Movies (\n  MovieID INT PRIMARY KEY,\n  Title VARCHAR(255) NOT NULL,\n  ReleaseYear INT\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Actors' table with 'ActorID' (primary key) and 'Name'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Actors (\n  ActorID INT PRIMARY KEY,\n  Name VARCHAR(150) NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'MovieActors' junction table to link 'Movies' and 'Actors'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE MovieActors (\n  MovieID INT,\n  ActorID INT,\n  RoleName VARCHAR(100),\n  PRIMARY KEY (MovieID, ActorID),\n  FOREIGN KEY (MovieID) REFERENCES Movies(MovieID),\n  FOREIGN KEY (ActorID) REFERENCES Actors(ActorID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Classes' table where 'ClassCode' is unique and 'RoomNumber' must be a positive integer.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Classes (\n  ClassID INT PRIMARY KEY,\n  ClassCode VARCHAR(10) UNIQUE NOT NULL,\n  RoomNumber INT CHECK (RoomNumber > 0)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'HotelRooms' table with 'RoomNumber' as primary key and 'RoomType' (e.g., 'Single', 'Double', 'Suite').\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE HotelRooms (\n  RoomNumber INT PRIMARY KEY,\n  RoomType VARCHAR(20) CHECK (RoomType IN ('Single', 'Double', 'Suite')),\n  PricePerNight DECIMAL(8, 2)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Bookings' table to link 'HotelRooms' and 'Customers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Bookings (\n  BookingID INT PRIMARY KEY,\n  RoomNumber INT REFERENCES HotelRooms(RoomNumber),\n  CustomerID INT REFERENCES Customers(CustomerID),\n  CheckInDate DATE,\n  CheckOutDate DATE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Bookings' table with a CHECK constraint to ensure 'CheckOutDate' is after 'CheckInDate'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Bookings (\n  BookingID INT PRIMARY KEY,\n  RoomNumber INT,\n  CustomerID INT,\n  CheckInDate DATE,\n  CheckOutDate DATE,\n  CONSTRAINT CHK_Dates CHECK (CheckOutDate > CheckInDate)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'WeatherLog' table with 'LogTime' (timestamp) and 'Temperature' (float).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE WeatherLog (\n  LogID INT PRIMARY KEY,\n  LogTime TIMESTAMP,\n  Temperature FLOAT,\n  Humidity FLOAT\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Suppliers' table with 'SupplierID' (primary key) and 'Phone' (unique).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Suppliers (\n  SupplierID INT PRIMARY KEY,\n  SupplierName VARCHAR(100) NOT NULL,\n  Phone VARCHAR(20) UNIQUE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Products' table that references the 'Suppliers' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Products (\n  ProductID INT PRIMARY KEY,\n  ProductName VARCHAR(100),\n  SupplierID INT,\n  FOREIGN KEY (SupplierID) REFERENCES Suppliers(SupplierID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Shippers' table with 'ShipperID' (primary key) and 'ShipperName'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Shippers (\n  ShipperID INT PRIMARY KEY,\n  ShipperName VARCHAR(100) NOT NULL,\n  Phone VARCHAR(20)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Orders' table that includes a 'ShipperID' foreign key.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Orders (\n  OrderID INT PRIMARY KEY,\n  CustomerID INT REFERENCES Customers(CustomerID),\n  OrderDate DATE,\n  ShipperID INT REFERENCES Shippers(ShipperID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'UserPreferences' with 'UserID' (primary key) and 'SendEmail' (boolean, default true).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE UserPreferences (\n  UserID INT PRIMARY KEY,\n  SendEmail BOOLEAN DEFAULT true,\n  Theme VARCHAR(20) DEFAULT 'Default'\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Salesperson' table with 'SalespersonID' (primary key) and 'Commission' (decimal, default 0.05).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Salesperson (\n  SalespersonID INT PRIMARY KEY,\n  Name VARCHAR(100) NOT NULL,\n  Commission DECIMAL(4, 2) DEFAULT 0.05 CHECK (Commission > 0)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a table 'JobHistory' to track employee job changes.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE JobHistory (\n  HistoryID INT PRIMARY KEY,\n  EmpID INT REFERENCES Employees(EmpID),\n  JobTitle VARCHAR(100),\n  StartDate DATE,\n  EndDate DATE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Payments' table with 'PaymentID', 'Amount' (decimal), and 'PaymentDate' (default to current date).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Payments (\n  PaymentID INT PRIMARY KEY,\n  OrderID INT REFERENCES Orders(OrderID),\n  Amount DECIMAL(10, 2) NOT NULL,\n  PaymentDate DATE DEFAULT CURRENT_DATE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Reservations' table with 'TableNumber' and 'ReservationTime' as a composite primary key.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Reservations (\n  TableNumber INT,\n  ReservationTime TIMESTAMP,\n  CustomerName VARCHAR(100),\n  PartySize INT,\n  PRIMARY KEY (TableNumber, ReservationTime)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'StockTrades' table with 'TradeID' (primary key) and 'TradeType' ('Buy' or 'Sell').\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE StockTrades (\n  TradeID INT PRIMARY KEY,\n  TickerSymbol VARCHAR(5) NOT NULL,\n  TradeType VARCHAR(4) CHECK (TradeType IN ('Buy', 'Sell')),\n  Quantity INT,\n  Price DECIMAL(10, 2)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Patients' table with 'PatientID' (primary key) and 'BloodType'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Patients (\n  PatientID INT PRIMARY KEY,\n  Name VARCHAR(100) NOT NULL,\n  BirthDate DATE,\n  BloodType VARCHAR(3)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Appointments' table that references 'Patients'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Appointments (\n  ApptID INT PRIMARY KEY,\n  PatientID INT,\n  DoctorName VARCHAR(100),\n  ApptTime TIMESTAMP,\n  FOREIGN KEY (PatientID) REFERENCES Patients(PatientID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'CoursePrerequisites' table linking a 'CourseID' to a 'PrereqID', both referencing 'Courses'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE CoursePrerequisites (\n  CourseID VARCHAR(10),\n  PrereqID VARCHAR(10),\n  PRIMARY KEY (CourseID, PrereqID),\n  FOREIGN KEY (CourseID) REFERENCES Courses(CourseID),\n  FOREIGN KEY (PrereqID) REFERENCES Courses(CourseID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'StudentGrades' table with a composite key and a 'Grade' (char 1).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE StudentGrades (\n  StudentID INT REFERENCES Students(StudentID),\n  CourseID VARCHAR(10) REFERENCES Courses(CourseID),\n  Grade CHAR(1) CHECK (Grade IN ('A', 'B', 'C', 'D', 'F')),\n  PRIMARY KEY (StudentID, CourseID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Warehouses' table with 'WarehouseID' (primary key) and 'LocationCode' (unique).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Warehouses (\n  WarehouseID INT PRIMARY KEY,\n  LocationCode VARCHAR(10) UNIQUE NOT NULL,\n  Address TEXT\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'Inventory' table that references 'Products' and 'Warehouses'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Inventory (\n  ProductID INT REFERENCES Products(ProductID),\n  WarehouseID INT REFERENCES Warehouses(WarehouseID),\n  Quantity INT DEFAULT 0,\n  PRIMARY KEY (ProductID, WarehouseID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'UserAccounts' table where 'PasswordHash' is not null.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE UserAccounts (\n  UserID INT PRIMARY KEY,\n  Email VARCHAR(100) UNIQUE NOT NULL,\n  PasswordHash VARCHAR(255) NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'SystemConfig' table with 'ConfigKey' as primary key and 'ConfigValue' (text).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE SystemConfig (\n  ConfigKey VARCHAR(50) PRIMARY KEY,\n  ConfigValue TEXT,\n  LastModified TIMESTAMP DEFAULT NOW()\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'BlogAuthors' table with 'AuthorID' (primary key) and 'Bio' (text).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE BlogAuthors (\n  AuthorID INT PRIMARY KEY,\n  Name VARCHAR(100) NOT NULL,\n  Bio TEXT\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'BlogPosts' table that references 'BlogAuthors'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE BlogPosts (\n  PostID INT PRIMARY KEY,\n  AuthorID INT REFERENCES BlogAuthors(AuthorID),\n  Title VARCHAR(200) NOT NULL,\n  Content TEXT,\n  PublishedDate DATE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Comments' table where if an 'Author' is deleted, their comments are set to NULL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Comments (\n  CommentID INT PRIMARY KEY,\n  PostID INT REFERENCES BlogPosts(PostID) ON DELETE CASCADE,\n  AuthorID INT REFERENCES BlogAuthors(AuthorID) ON DELETE SET NULL,\n  CommentText TEXT\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'SalesTeams' table with 'TeamID' (primary key) and 'TeamName'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE SalesTeams (\n  TeamID INT PRIMARY KEY,\n  TeamName VARCHAR(50) NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Salesperson' table referencing 'SalesTeams'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Salesperson (\n  SalespersonID INT PRIMARY KEY,\n  Name VARCHAR(100),\n  TeamID INT,\n  FOREIGN KEY (TeamID) REFERENCES SalesTeams(TeamID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Customers' table that references a 'Salesperson'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Customers (\n  CustomerID INT PRIMARY KEY,\n  CustomerName VARCHAR(100),\n  AssignedSalespersonID INT,\n  FOREIGN KEY (AssignedSalespersonID) REFERENCES Salesperson(SalespersonID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'ProductCategories' table with 'CategoryID' (primary key) and a self-referencing 'ParentCategoryID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE ProductCategories (\n  CategoryID INT PRIMARY KEY,\n  CategoryName VARCHAR(50) NOT NULL,\n  ParentCategoryID INT,\n  FOREIGN KEY (ParentCategoryID) REFERENCES ProductCategories(CategoryID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Employees' table with 'SocialSecurityNumber' as a 9-char fixed length, unique column.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Employees (\n  EmpID INT PRIMARY KEY,\n  Name VARCHAR(100),\n  SSN CHAR(9) UNIQUE NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Subscriptions' table with 'Status' ('Active', 'Cancelled', 'Trial') and 'EndDate'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Subscriptions (\n  SubscriptionID INT PRIMARY KEY,\n  UserID INT REFERENCES Users(UserID),\n  PlanName VARCHAR(30),\n  Status VARCHAR(10) CHECK (Status IN ('Active', 'Cancelled', 'Trial')),\n  EndDate DATE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Media' table with 'FileID' (primary key) and 'FileSize' (in bytes, must be positive).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Media (\n  FileID INT PRIMARY KEY,\n  FileName VARCHAR(255) NOT NULL,\n  FileType VARCHAR(20),\n  FileSize BIGINT CHECK (FileSize > 0)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'LoginAttempts' table with 'AttemptID' (auto-increment) and 'WasSuccess' (boolean).\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Using SERIAL for PostgreSQL\nCREATE TABLE LoginAttempts (\n  AttemptID SERIAL PRIMARY KEY,\n  UserID INT REFERENCES Users(UserID),\n  AttemptTime TIMESTAMPTZ DEFAULT NOW(),\n  WasSuccess BOOLEAN NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'ShippingAddresses' table with 'AddressID' (primary key) and 'CountryCode' (2-char fixed length).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE ShippingAddresses (\n  AddressID INT PRIMARY KEY,\n  CustomerID INT REFERENCES Customers(CustomerID),\n  StreetAddress TEXT NOT NULL,\n  City VARCHAR(50),\n  PostalCode VARCHAR(10),\n  CountryCode CHAR(2) NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'ProductReviews' table with named constraints for PK, FK, and CHECK.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE ProductReviews (\n  ReviewID INT,\n  ProductID INT,\n  Rating INT,\n  CONSTRAINT PK_ProductReviews PRIMARY KEY (ReviewID),\n  CONSTRAINT FK_Reviews_Product FOREIGN KEY (ProductID) REFERENCES Products(ProductID),\n  CONSTRAINT CHK_RatingRange CHECK (Rating >= 1 AND Rating <= 5)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'PriceHistory' table to log price changes for products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE PriceHistory (\n  HistoryID INT PRIMARY KEY,\n  ProductID INT REFERENCES Products(ProductID),\n  OldPrice DECIMAL(10, 2),\n  NewPrice DECIMAL(10, 2),\n  ChangeDate TIMESTAMP DEFAULT NOW()\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'ZipCodes' table with 'Zip' (5-char fixed length) as primary key and 'State' (2-char fixed length).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE ZipCodes (\n  Zip CHAR(5) PRIMARY KEY,\n  City VARCHAR(50),\n  State CHAR(2)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an 'AuditLog' table with 'LogID' (auto-increment) and 'Action' (not null).\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Using IDENTITY for SQL Server\nCREATE TABLE AuditLog (\n  LogID INT IDENTITY(1,1) PRIMARY KEY,\n  UserName VARCHAR(50),\n  Action VARCHAR(255) NOT NULL,\n  Timestamp DATETIME DEFAULT GETDATE()\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'UserRoles' table with 'RoleID' (primary key) and 'RoleName' (unique).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE UserRoles (\n  RoleID INT PRIMARY KEY,\n  RoleName VARCHAR(30) UNIQUE NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'UserRoleJunction' table to link 'Users' and 'UserRoles' (many-to-many).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE UserRoleJunction (\n  UserID INT REFERENCES Users(UserID),\n  RoleID INT REFERENCES UserRoles(RoleID),\n  PRIMARY KEY (UserID, RoleID)\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'Features' table with 'FeatureName' and 'IsEnabled' (boolean, default false).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE Features (\n  FeatureID INT PRIMARY KEY,\n  FeatureName VARCHAR(50) UNIQUE NOT NULL,\n  IsEnabled BOOLEAN DEFAULT false\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a 'BannedUsers' table with 'UserID' (primary key, references 'Users') and 'Reason' (text).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE TABLE BannedUsers (\n  UserID INT PRIMARY KEY,\n  BanDate DATE DEFAULT CURRENT_DATE,\n  Reason TEXT,\n  FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE CASCADE\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select all columns from a table named 'Employees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect just the 'FirstName' and 'LastName' columns from the 'Employees' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT FirstName, LastName FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the 'ProductName' and 'Price' from the 'Products' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName, Price FROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select all products from the 'Electronics' category?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees with a salary greater than 50000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Salary > 50000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all orders that have a quantity less than 10.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Orders\nWHERE Quantity < 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products with a price of $19.99.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Price = 19.99;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all employees in the 'Sales' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who are *not* in the 'Sales' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Department <> 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all products where the stock is 100 or more.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Stock >= 100;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who joined on or before '2023-01-01'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE HireDate <= '2023-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all products from 'Electronics' that cost more than $500.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Category = 'Electronics' AND Price > 500;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees in the 'Sales' department who also have a salary over 60000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Department = 'Sales' AND Salary > 60000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all employees who are in the 'Marketing' OR 'Finance' departments.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Department = 'Marketing' OR Department = 'Finance';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that are either 'Books' or cost less than $10.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Category = 'Books' OR Price < 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all employees who are NOT in the 'IT' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE NOT Department = 'IT';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind products that are 'Electronics' and are not over $1000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Category = 'Electronics' AND NOT Price > 1000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect employees from 'Sales' OR 'Marketing' who also have a salary > 50000. Use parentheses.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE (Department = 'Sales' OR Department = 'Marketing') AND Salary > 50000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select all employees who are in 'Sales', 'Marketing', or 'Finance'? Use the IN operator.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Department IN ('Sales', 'Marketing', 'Finance');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all orders with a status of 'Shipped' or 'Delivered'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Orders\nWHERE Status IN ('Shipped', 'Delivered');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who are NOT in 'Sales' or 'Marketing'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Department NOT IN ('Sales', 'Marketing');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all products with a price between $50 and $100.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Price BETWEEN 50 AND 100;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all orders placed between '2024-01-01' and '2024-01-31'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Orders\nWHERE OrderDate BETWEEN '2024-01-01' AND '2024-01-31';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees with a salary NOT between 40000 and 60000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Salary NOT BETWEEN 40000 AND 60000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all employees whose 'FirstName' starts with 'A'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE FirstName LIKE 'A%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees whose 'LastName' ends with 'son'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE LastName LIKE '%son';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that have the word 'Pro' anywhere in their name.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE ProductName LIKE '%Pro%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find employees whose 'FirstName' has 'a' as the second letter?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE FirstName LIKE '_a%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all employees whose 'FirstName' is exactly 4 letters long and starts with 'J'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE FirstName LIKE 'J___';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who do not have a manager assigned (ManagerID is null).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE ManagerID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who DO have a manager assigned.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE ManagerID IS NOT NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all customers who are missing an email address.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Customers\nWHERE Email IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all orders that have *not* been shipped yet (ShippedDate is null).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Orders\nWHERE ShippedDate IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get a list of all unique departments from the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT DISTINCT Department FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the list of unique categories in the 'Products' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT DISTINCT Category FROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many unique last names are in the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(DISTINCT LastName) FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all employees, sorted alphabetically by 'LastName'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nORDER BY LastName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all employees, sorted by 'Salary' from highest to lowest.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nORDER BY Salary DESC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow all products, sorted by 'Price' from lowest to highest.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nORDER BY Price ASC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all employees, sorted by 'Department' alphabetically, and then by 'Salary' descending within each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nORDER BY Department ASC, Salary DESC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the 5 most recently hired employees.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Using LIMIT (MySQL/PostgreSQL)\nSELECT * FROM Employees\nORDER BY HireDate DESC\nLIMIT 5;\n\n-- Using TOP (SQL Server)\n-- SELECT TOP 5 * FROM Employees ORDER BY HireDate DESC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the top 10 most expensive products.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Using LIMIT (MySQL/PostgreSQL)\nSELECT * FROM Products\nORDER BY Price DESC\nLIMIT 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the 3 cheapest products that are not in the 'Books' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Category <> 'Books'\nORDER BY Price ASC\nLIMIT 3;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select the 10 products *after* the first 5 most expensive? (for pagination)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Using LIMIT OFFSET (MySQL/PostgreSQL)\nSELECT * FROM Products\nORDER BY Price DESC\nLIMIT 10 OFFSET 5;\n\n-- Using OFFSET FETCH (Standard SQL/SQL Server)\n-- SELECT * FROM Products\n-- ORDER BY Price DESC\n-- OFFSET 5 ROWS\n-- FETCH NEXT 10 ROWS ONLY;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect the 'ProductName' from 'Products' but show the column header as 'Product'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName AS Product\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me each employee's 'Salary' and their 'Salary' * 1.1 as 'SalaryWithBonus'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Salary, (Salary * 1.1) AS SalaryWithBonus\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nConcatenate 'FirstName' and 'LastName' into a 'FullName' column.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Standard SQL (||)\nSELECT FirstName || ' ' || LastName AS FullName\nFROM Employees;\n\n-- MySQL (CONCAT)\n-- SELECT CONCAT(FirstName, ' ', LastName) AS FullName FROM Employees;\n\n-- SQL Server (+)\n-- SELECT FirstName + ' ' + LastName AS FullName FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I count the total number of rows in the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*) FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGive me the total number of employees and call the result 'TotalEmployees'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*) AS TotalEmployees\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I count the number of employees who have a 'ManagerID' assigned?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(ManagerID) FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the total sum of all salaries in the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT SUM(Salary) AS TotalSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the total 'Quantity' of all items sold from the 'OrderItems' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT SUM(Quantity) AS TotalItemsSold\nFROM OrderItems;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the average salary of all employees?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT AVG(Salary) AS AverageSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the average price of products in the 'Books' category?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT AVG(Price) AS AverageBookPrice\nFROM Products\nWHERE Category = 'Books';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the highest salary in the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT MAX(Salary) AS HighestSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the most recent 'HireDate' in the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT MAX(HireDate) AS MostRecentHire\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the lowest salary in the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT MIN(Salary) AS LowestSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the earliest 'HireDate' in the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT MIN(HireDate) AS EarliestHire\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the total number of employees in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, COUNT(*)\nFROM Employees\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGive me the count of employees per department, but show the department name and the count.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, COUNT(*) AS EmployeeCount\nFROM Employees\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the average salary for each department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, AVG(Salary) AS AverageSalary\nFROM Employees\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the total number of products in each 'Category'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, COUNT(*) AS ProductCount\nFROM Products\nGROUP BY Category;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the highest salary in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, MAX(Salary) AS HighestSalary\nFROM Employees\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the lowest price in each product 'Category'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, MIN(Price) AS LowestPrice\nFROM Products\nGROUP BY Category;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCalculate the total quantity of items sold for each 'ProductID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID, SUM(Quantity) AS TotalSold\nFROM OrderItems\nGROUP BY ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many orders were placed by each 'CustomerID'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID, COUNT(OrderID) AS OrderCount\nFROM Orders\nGROUP BY CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the number of employees hired each year.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (Using YEAR() function, common in MySQL/T-SQL)\nSELECT YEAR(HireDate) AS HireYear, COUNT(*)\nFROM Employees\nGROUP BY YEAR(HireDate);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the average price and total stock for each product 'Category'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, AVG(Price) AS AvgPrice, SUM(Stock) AS TotalStock\nFROM Products\nGROUP BY Category;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind departments where the employee count is more than 10.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, COUNT(*) AS EmployeeCount\nFROM Employees\nGROUP BY Department\nHAVING COUNT(*) > 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me departments where the average salary is over $70,000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, AVG(Salary) AS AverageSalary\nFROM Employees\nGROUP BY Department\nHAVING AVG(Salary) > 70000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind product categories where the total stock is less than 100.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, SUM(Stock) AS TotalStock\nFROM Products\nGROUP BY Category\nHAVING SUM(Stock) < 100;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me 'ProductIDs' that have been ordered 50 or more times in total.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID, SUM(Quantity) AS TotalQuantity\nFROM OrderItems\nGROUP BY ProductID\nHAVING SUM(Quantity) >= 50;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'CustomerIDs' who have placed more than 5 orders.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID, COUNT(OrderID) AS OrderCount\nFROM Orders\nGROUP BY CustomerID\nHAVING COUNT(OrderID) > 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow categories where the maximum price of a product is over $1000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, MAX(Price) AS MaxPrice\nFROM Products\nGROUP BY Category\nHAVING MAX(Price) > 1000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind categories where the minimum price of a product is at least $10.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, MIN(Price) AS MinPrice\nFROM Products\nGROUP BY Category\nHAVING MIN(Price) >= 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me departments with an average salary between $50,000 and $60,000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, AVG(Salary) AS AverageSalary\nFROM Employees\nGROUP BY Department\nHAVING AVG(Salary) BETWEEN 50000 AND 60000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind departments that have more than 3 employees AND an average salary below $45,000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, COUNT(*) AS EmployeeCount, AVG(Salary) AS AverageSalary\nFROM Employees\nGROUP BY Department\nHAVING COUNT(*) > 3 AND AVG(Salary) < 45000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the list of departments, ordered by their average salary (highest first).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, AVG(Salary) AS AverageSalary\nFROM Employees\nGROUP BY Department\nORDER BY AverageSalary DESC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select the current date and time from the database? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT GETDATE();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select the current date and time from the database? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT NOW();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select the current date and time from the database? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CURRENT_TIMESTAMP();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select the current date only? (Standard SQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CURRENT_DATE;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select a simple string literal, like 'Hello World'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT 'Hello World' AS Message;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select the result of a simple calculation, like 5 + 5?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT 5 + 5 AS Result;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all product names in uppercase.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT UPPER(ProductName) FROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all product names in lowercase.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT LOWER(ProductName) FROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect the first 10 characters of each employee's 'LastName'.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Standard SQL\nSELECT SUBSTRING(LastName FROM 1 FOR 10) FROM Employees;\n\n-- MySQL/SQL Server\n-- SELECT SUBSTRING(LastName, 1, 10) FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all employees from the 'Sales' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products with a price over $100.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Price > 100;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all orders with a quantity of 1.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Orders\nWHERE Quantity = 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who were hired on or after '2024-01-01'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE HireDate >= '2024-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all products that are *not* in the 'Books' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Category <> 'Books';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees in the 'Engineering' department who also have a salary over 70000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Department = 'Engineering' AND Salary > 70000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all products that are in the 'Apparel' category OR have a price under $20.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Category = 'Apparel' OR Price < 20;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees in 'Sales' or 'Marketing' using the IN operator.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Department IN ('Sales', 'Marketing');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees whose department is NOT 'HR' or 'Finance'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE Department NOT IN ('HR', 'Finance');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all products with a price between $30 and $50.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Price BETWEEN 30 AND 50;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees hired during the year 2023.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE HireDate BETWEEN '2023-01-01' AND '2023-12-31';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all employees whose 'LastName' starts with 'S'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE LastName LIKE 'S%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products with 'mouse' anywhere in the name.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE ProductName LIKE '%mouse%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees whose first name is 4 letters long and starts with 'M'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE FirstName LIKE 'M___';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all customers who do not have an email address listed.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Customers\nWHERE Email IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all employees who have a known manager.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE ManagerID IS NOT NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all orders that have been shipped (ShippedDate is not null).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Orders\nWHERE ShippedDate IS NOT NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind employees in 'Sales' with a salary over 50k, or any employee in 'Marketing'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Employees\nWHERE (Department = 'Sales' AND Salary > 50000) OR (Department = 'Marketing');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all products where the stock is less than or equal to 10.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE Stock <= 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that are NOT 'Electronics'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM Products\nWHERE NOT Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I count the total number of employees?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*) AS TotalEmployees\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many products are in the 'Electronics' category?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*)\nFROM Products\nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I count the number of employees who have a manager?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(ManagerID) AS EmployeesWithManager\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many employees have a salary listed (not null)?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(Salary)\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many unique last names are in the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(DISTINCT LastName)\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many different departments are represented in the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(DISTINCT Department)\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many unique product categories are there?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(DISTINCT Category) AS NumberOfCategories\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many customers have 'gmail.com' in their email?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*)\nFROM Customers\nWHERE Email LIKE '%@gmail.com';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the total count of all orders?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(OrderID) AS TotalOrders\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many orders are currently marked as 'Pending'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*)\nFROM Orders\nWHERE Status = 'Pending';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the total number of employees in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, COUNT(*) AS EmployeeCount\nFROM Employees\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many products are in each category? Show the category and the count.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, COUNT(ProductID) AS ProductCount\nFROM Products\nGROUP BY Category;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many orders has each customer placed?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID, COUNT(OrderID) AS OrderCount\nFROM Orders\nGROUP BY CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many employees were hired in each year?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Using EXTRACT for PostgreSQL/Standard SQL\nSELECT EXTRACT(YEAR FROM HireDate) AS HireYear, COUNT(*)\nFROM Employees\nGROUP BY HireYear;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the count of unique managers in the 'Employees' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(DISTINCT ManagerID)\nFROM Employees\nWHERE ManagerID IS NOT NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many employees in the 'Sales' department have a salary over 50k?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*)\nFROM Employees\nWHERE Department = 'Sales' AND Salary > 50000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the total number of line items in the 'OrderItems' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*)\nFROM OrderItems;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many orders have a 'Shipped' status?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(OrderID)\nFROM Orders\nWHERE Status = 'Shipped';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the count of employees for each manager.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ManagerID, COUNT(*) AS DirectReports\nFROM Employees\nWHERE ManagerID IS NOT NULL\nGROUP BY ManagerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many products have a price between $10 and $50?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT COUNT(*)\nFROM Products\nWHERE Price BETWEEN 10 AND 50;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the number of employees in each department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, COUNT(*)\nFROM Employees\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the average salary for each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, AVG(Salary)\nFROM Employees\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the total number of products in each category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, COUNT(ProductID)\nFROM Products\nGROUP BY Category;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow many orders were placed by each customer?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID, COUNT(OrderID)\nFROM Orders\nGROUP BY CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the highest salary in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, MAX(Salary)\nFROM Employees\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the lowest price in each product category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, MIN(Price)\nFROM Products\nGROUP BY Category;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCalculate the total quantity sold for each 'ProductID' from 'OrderItems'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID, SUM(Quantity)\nFROM OrderItems\nGROUP BY ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total salary paid for each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, SUM(Salary)\nFROM Employees\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the most recent 'HireDate' for each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, MAX(HireDate)\nFROM Employees\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the earliest 'OrderDate' for each 'CustomerID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID, MIN(OrderDate)\nFROM Orders\nGROUP BY CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the number of employees for each 'ManagerID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ManagerID, COUNT(*)\nFROM Employees\nGROUP BY ManagerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGroup by both 'Category' and 'Brand' to find the total stock.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, Brand, SUM(Stock)\nFROM Products\nGROUP BY Category, Brand;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the average quantity sold for each 'OrderID' and 'ProductID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT OrderID, ProductID, AVG(Quantity)\nFROM OrderItems\nGROUP BY OrderID, ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the number of employees hired each year.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Using YEAR() function (MySQL/T-SQL)\nSELECT YEAR(HireDate) AS HireYear, COUNT(*)\nFROM Employees\nGROUP BY YEAR(HireDate);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the total number of orders for each 'Status' type.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Status, COUNT(OrderID)\nFROM Orders\nGROUP BY Status;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the average price for each 'Category', sorted by the average price descending.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, AVG(Price) AS AvgPrice\nFROM Products\nGROUP BY Category\nORDER BY AvgPrice DESC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGroup employees by 'Department' and show the count, but only for 'Sales' and 'Marketing'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, COUNT(*)\nFROM Employees\nWHERE Department IN ('Sales', 'Marketing')\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the total revenue for each 'OrderID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT OrderID, SUM(Quantity * Price) AS TotalRevenue\nFROM OrderItems\nGROUP BY OrderID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the number of customers from each 'Country'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Country, COUNT(CustomerID)\nFROM Customers\nGROUP BY Country;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the average salary per department, but only for employees hired after 2022.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, AVG(Salary)\nFROM Employees\nWHERE HireDate > '2022-12-31'\nGROUP BY Department;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind departments where the employee count is more than 10.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, COUNT(*) AS EmployeeCount\nFROM Employees\nGROUP BY Department\nHAVING COUNT(*) > 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me departments where the average salary is over $70,000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, AVG(Salary) AS AverageSalary\nFROM Employees\nGROUP BY Department\nHAVING AVG(Salary) > 70000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind product categories where the total stock is less than 100.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, SUM(Stock) AS TotalStock\nFROM Products\nGROUP BY Category\nHAVING SUM(Stock) < 100;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me 'ProductIDs' that have been ordered 50 or more times in total quantity.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID, SUM(Quantity) AS TotalQuantity\nFROM OrderItems\nGROUP BY ProductID\nHAVING SUM(Quantity) >= 50;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'CustomerIDs' who have placed more than 5 orders.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID, COUNT(OrderID) AS OrderCount\nFROM Orders\nGROUP BY CustomerID\nHAVING COUNT(OrderID) > 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow categories where the maximum price of a product is over $1000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, MAX(Price) AS MaxPrice\nFROM Products\nGROUP BY Category\nHAVING MAX(Price) > 1000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind categories where the minimum price of a product is at least $10.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, MIN(Price) AS MinPrice\nFROM Products\nGROUP BY Category\nHAVING MIN(Price) >= 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me departments with an average salary between $50,000 and $60,000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, AVG(Salary) AS AverageSalary\nFROM Employees\nGROUP BY Department\nHAVING AVG(Salary) BETWEEN 50000 AND 60000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind departments that have more than 3 employees AND an average salary below $45,000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, COUNT(*) AS EmployeeCount, AVG(Salary) AS AverageSalary\nFROM Employees\nGROUP BY Department\nHAVING COUNT(*) > 3 AND AVG(Salary) < 45000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind categories where the total stock is over 1000 OR the average price is under $20.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, SUM(Stock) AS TotalStock, AVG(Price) AS AvgPrice\nFROM Products\nGROUP BY Category\nHAVING SUM(Stock) > 1000 OR AVG(Price) < 20;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow 'CustomerIDs' who have placed exactly 1 order.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID, COUNT(OrderID) AS OrderCount\nFROM Orders\nGROUP BY CustomerID\nHAVING COUNT(OrderID) = 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'ProductIDs' that have a total revenue of more than $10,000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID, SUM(Quantity * UnitPrice) AS TotalRevenue\nFROM OrderItems\nGROUP BY ProductID\nHAVING SUM(Quantity * UnitPrice) > 10000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow departments where the lowest salary is less than 30000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, MIN(Salary) AS MinSalary\nFROM Employees\nGROUP BY Department\nHAVING MIN(Salary) < 30000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'ManagerIDs' who manage 5 or more people.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ManagerID, COUNT(*) AS ReportCount\nFROM Employees\nWHERE ManagerID IS NOT NULL\nGROUP BY ManagerID\nHAVING COUNT(*) >= 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow categories with an average price over $50, but only for 'Electronics' and 'Appliances'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, AVG(Price) AS AvgPrice\nFROM Products\nWHERE Category IN ('Electronics', 'Appliances')\nGROUP BY Category\nHAVING AVG(Price) > 50;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'CustomerIDs' who have placed an order in 2024 and have more than 2 orders total.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID, COUNT(OrderID) AS TotalOrders\nFROM Orders\nWHERE OrderDate BETWEEN '2024-01-01' AND '2024-12-31'\nGROUP BY CustomerID\nHAVING COUNT(OrderID) > 2;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow departments where the highest salary is not equal to 100000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, MAX(Salary)\nFROM Employees\nGROUP BY Department\nHAVING MAX(Salary) <> 100000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind product categories where the total number of items is greater than 10.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Category, COUNT(*) AS ItemCount\nFROM Products\nGROUP BY Category\nHAVING COUNT(*) > 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me departments that have a total salary payout of more than $1,000,000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, SUM(Salary) AS TotalSalary\nFROM Employees\nGROUP BY Department\nHAVING SUM(Salary) > 1000000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow 'OrderIDs' that have more than 5 different products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT OrderID, COUNT(ProductID) AS UniqueProducts\nFROM OrderItems\nGROUP BY OrderID\nHAVING COUNT(ProductID) > 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a new column named 'Email' (type VARCHAR(100)) to the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN Email VARCHAR(100);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'PhoneNumber' column (type VARCHAR(20)) to the 'Customers' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nADD COLUMN PhoneNumber VARCHAR(20);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to add a 'StockQuantity' column (type INT) to the 'Products' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN StockQuantity INT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd an 'IsActive' column (type BOOLEAN) to the 'Users' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nADD COLUMN IsActive BOOLEAN;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a 'Description' column (type TEXT) to the 'Products' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN Description TEXT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'LastLogin' column (type TIMESTAMP) to the 'Users' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nADD COLUMN LastLogin TIMESTAMP;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a 'HireDate' column (type DATE) to the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN HireDate DATE;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Country' column (type VARCHAR(50)) to the 'Customers' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nADD COLUMN Country VARCHAR(50);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to add a 'Commission' column (type DECIMAL(5, 2)) to 'Employees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN Commission DECIMAL(5, 2);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Priority' column (type INT) with a default value of 1 to the 'Tasks' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Tasks\nADD COLUMN Priority INT DEFAULT 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a 'Status' column (type VARCHAR(20)) with a default of 'Active' to 'Products'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN Status VARCHAR(20) DEFAULT 'Active';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'SendNewsletter' column (type BOOLEAN) with a default of true to 'Customers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nADD COLUMN SendNewsletter BOOLEAN DEFAULT true;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'CreatedAt' column to 'Orders' that defaults to the current timestamp. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nADD COLUMN CreatedAt TIMESTAMPTZ DEFAULT NOW();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'CreatedAt' column to 'Orders' that defaults to the current timestamp. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nADD COLUMN CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to add a 'Notes' column (type TEXT) that can be null to the 'Orders' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nADD COLUMN Notes TEXT NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'ManagerID' column (type INT) to the 'Employees' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN ManagerID INT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'ShippingAddress' column (type VARCHAR(255)) to the 'Orders' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nADD COLUMN ShippingAddress VARCHAR(255);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a 'Discount' column (type DECIMAL) with a default of 0.00 to 'Products'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN Discount DECIMAL(5, 2) DEFAULT 0.00;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'JobTitle' column (type VARCHAR(100)) to the 'Employees' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN JobTitle VARCHAR(100);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'SKU' column (type VARCHAR(50)) to the 'Products' table that must be unique.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN SKU VARCHAR(50) UNIQUE;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Stock' column (type INT) to 'Products' that must be 0 or more.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN Stock INT CHECK (Stock >= 0);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Rating' column (type INT) to 'Reviews' that must be between 1 and 5.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Reviews\nADD COLUMN Rating INT CHECK (Rating >= 1 AND Rating <= 5);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd an 'Age' column (type INT) to 'Users' that must be 18 or older.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nADD COLUMN Age INT CHECK (Age >= 18);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Gender' column (type CHAR(1)) to 'Employees' that allows only 'M', 'F', or 'O'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN Gender CHAR(1) CHECK (Gender IN ('M', 'F', 'O'));\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Status' column (type VARCHAR(10)) to 'Tasks' with a default of 'New' and a check for 'New', 'In Progress', 'Done'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Tasks\nADD COLUMN Status VARCHAR(10) DEFAULT 'New' CHECK (Status IN ('New', 'In Progress', 'Done'));\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove the 'PhoneNumber' column from the 'Customers' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nDROP COLUMN PhoneNumber;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete the 'Commission' column from the 'Employees' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP COLUMN Commission;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the 'IsActive' column from the 'Users' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nDROP COLUMN IsActive;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI no longer need the 'Description' column in 'Products'. How do I remove it?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nDROP COLUMN Description;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'LastLogin' column from the 'Users' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nDROP COLUMN LastLogin;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop a constraint named 'CHK_RatingRange' from the 'Reviews' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Reviews\nDROP CONSTRAINT CHK_RatingRange;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove the unique constraint 'UQ_Email' from the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP CONSTRAINT UQ_Email;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove the foreign key constraint 'FK_Emp_Dept' from 'Employees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP CONSTRAINT FK_Emp_Dept;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove the primary key constraint 'PK_Users' from the 'Users' table? (Note: This might fail if it's referenced by other tables).\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nDROP CONSTRAINT PK_Users;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the check constraint 'CHK_Stock' from the 'Products' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nDROP CONSTRAINT CHK_Stock;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI want to drop the 'OldColumn' from the 'TestTable'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE TestTable\nDROP COLUMN OldColumn;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to remove the 'Notes' column from the 'Orders' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nDROP COLUMN Notes;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'Country' column from 'Customers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nDROP COLUMN Country;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'Priority' column from 'Tasks'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Tasks\nDROP COLUMN Priority;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'Discount' column from 'Products'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nDROP COLUMN Discount;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI want to drop the 'ManagerID' column from 'Employees'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP COLUMN ManagerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete the 'ShippingAddress' column from the 'Orders' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nDROP COLUMN ShippingAddress;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'SKU' column from 'Products'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nDROP COLUMN SKU;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'Age' column from 'Users'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nDROP COLUMN Age;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'Gender' column from 'Employees'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP COLUMN Gender;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the default value from the 'Status' column in the 'Orders' table? (PostgreSQL/Standard SQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nALTER COLUMN Status DROP DEFAULT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a new column named 'Email' (type VARCHAR(100)) to the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN Email VARCHAR(100);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'PhoneNumber' column (type VARCHAR(20)) to the 'Customers' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nADD COLUMN PhoneNumber VARCHAR(20);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to add a 'StockQuantity' column (type INT) to the 'Products' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN StockQuantity INT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd an 'IsActive' column (type BOOLEAN) to the 'Users' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nADD COLUMN IsActive BOOLEAN;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a 'Description' column (type TEXT) to the 'Products' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN Description TEXT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'LastLogin' column (type TIMESTAMP) to the 'Users' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nADD COLUMN LastLogin TIMESTAMP;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a 'HireDate' column (type DATE) to the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN HireDate DATE;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Country' column (type VARCHAR(50)) to the 'Customers' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nADD COLUMN Country VARCHAR(50);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to add a 'Commission' column (type DECIMAL(5, 2)) to 'Employees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN Commission DECIMAL(5, 2);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Priority' column (type INT) with a default value of 1 to the 'Tasks' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Tasks\nADD COLUMN Priority INT DEFAULT 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a 'Status' column (type VARCHAR(20)) with a default of 'Active' to 'Products'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN Status VARCHAR(20) DEFAULT 'Active';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'SendNewsletter' column (type BOOLEAN) with a default of true to 'Customers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nADD COLUMN SendNewsletter BOOLEAN DEFAULT true;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'CreatedAt' column to 'Orders' that defaults to the current timestamp. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nADD COLUMN CreatedAt TIMESTAMPTZ DEFAULT NOW();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'CreatedAt' column to 'Orders' that defaults to the current timestamp. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nADD COLUMN CreatedAt DATETIME DEFAULT CURRENT_TIMESTAMP;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to add a 'Notes' column (type TEXT) that can be null to the 'Orders' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nADD COLUMN Notes TEXT NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'ManagerID' column (type INT) to the 'Employees' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN ManagerID INT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'ShippingAddress' column (type VARCHAR(255)) to the 'Orders' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nADD COLUMN ShippingAddress VARCHAR(255);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a 'Discount' column (type DECIMAL) with a default of 0.00 to 'Products'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN Discount DECIMAL(5, 2) DEFAULT 0.00;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'JobTitle' column (type VARCHAR(100)) to the 'Employees' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN JobTitle VARCHAR(100);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'SKU' column (type VARCHAR(50)) to the 'Products' table that must be unique.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN SKU VARCHAR(50) UNIQUE;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Stock' column (type INT) to 'Products' that must be 0 or more.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nADD COLUMN Stock INT CHECK (Stock >= 0);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Rating' column (type INT) to 'Reviews' that must be between 1 and 5.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Reviews\nADD COLUMN Rating INT CHECK (Rating >= 1 AND Rating <= 5);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd an 'Age' column (type INT) to 'Users' that must be 18 or older.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nADD COLUMN Age INT CHECK (Age >= 18);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Gender' column (type CHAR(1)) to 'Employees' that allows only 'M', 'F', or 'O'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nADD COLUMN Gender CHAR(1) CHECK (Gender IN ('M', 'F', 'O'));\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a 'Status' column (type VARCHAR(10)) to 'Tasks' with a default of 'New' and a check for 'New', 'In Progress', 'Done'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Tasks\nADD COLUMN Status VARCHAR(10) DEFAULT 'New' CHECK (Status IN ('New', 'In Progress', 'Done'));\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove the 'PhoneNumber' column from the 'Customers' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nDROP COLUMN PhoneNumber;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete the 'Commission' column from the 'Employees' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP COLUMN Commission;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the 'IsActive' column from the 'Users' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nDROP COLUMN IsActive;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI no longer need the 'Description' column in 'Products'. How do I remove it?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nDROP COLUMN Description;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'LastLogin' column from the 'Users' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nDROP COLUMN LastLogin;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop a constraint named 'CHK_RatingRange' from the 'Reviews' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Reviews\nDROP CONSTRAINT CHK_RatingRange;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove the unique constraint 'UQ_Email' from the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP CONSTRAINT UQ_Email;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove the foreign key constraint 'FK_Emp_Dept' from 'Employees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP CONSTRAINT FK_Emp_Dept;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove the primary key constraint 'PK_Users' from the 'Users' table? (Note: This might fail if it's referenced by other tables).\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nDROP CONSTRAINT PK_Users;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the check constraint 'CHK_Stock' from the 'Products' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nDROP CONSTRAINT CHK_Stock;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI want to drop the 'OldColumn' from the 'TestTable'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE TestTable\nDROP COLUMN OldColumn;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to remove the 'Notes' column from the 'Orders' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nDROP COLUMN Notes;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'Country' column from 'Customers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nDROP COLUMN Country;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'Priority' column from 'Tasks'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Tasks\nDROP COLUMN Priority;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'Discount' column from 'Products'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nDROP COLUMN Discount;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI want to drop the 'ManagerID' column from 'Employees'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP COLUMN ManagerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete the 'ShippingAddress' column from the 'Orders' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nDROP COLUMN ShippingAddress;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'SKU' column from 'Products'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Products\nDROP COLUMN SKU;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'Age' column from 'Users'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Users\nDROP COLUMN Age;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'Gender' column from 'Employees'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP COLUMN Gender;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the default value from the 'Status' column in the 'Orders' table? (PostgreSQL/Standard SQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nALTER COLUMN Status DROP DEFAULT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I insert a new employee (ID 101, Name 'John Doe') into the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Employees (EmpID, FullName) \nVALUES (101, 'John Doe');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me how to insert a new product with ID 201, Name 'Keyboard', and Price 49.99.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Products (ProductID, ProductName, Price) \nVALUES (201, 'Keyboard', 49.99);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a new customer, 'Alice Smith' (ID 1), with the email 'alice@example.com'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Customers (CustomerID, CustomerName, Email) \nVALUES (1, 'Alice Smith', 'alice@example.com');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert a new order (ID 1001) for Customer 1, placed on '2025-01-05'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Orders (OrderID, CustomerID, OrderDate) \nVALUES (1001, 1, '2025-01-05');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I insert a row into 'OrderItems' for Order 1001, Product 201, with a quantity of 2?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO OrderItems (OrderID, ProductID, Quantity) \nVALUES (1001, 201, 2);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I insert a new employee, specifying all columns: ID 102, Name 'Jane Roe', Dept 'Sales', Salary 55000?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Employees (EmpID, FullName, Department, Salary) \nVALUES (102, 'Jane Roe', 'Sales', 55000);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert a new product, 'Mouse' (ID 202), in the 'Electronics' category with a price of 25.00 and 150 in stock.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Products (ProductID, ProductName, Category, Price, Stock) \nVALUES (202, 'Mouse', 'Electronics', 25.00, 150);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to add a new 'Logs' entry with the message 'System start' and the current time? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Logs (LogMessage, LogTime) \nVALUES ('System start', NOW());\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert a new order (ID 1002) for Customer 2 using the current date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Orders (OrderID, CustomerID, OrderDate) \nVALUES (1002, 2, CURRENT_DATE);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a new employee (ID 103, Name 'Bob') who doesn't have a department assigned yet?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Employees (EmpID, FullName, Department) \nVALUES (103, 'Bob', NULL);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert a new order (ID 1003) for Customer 1, relying on the default 'Status'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Orders (OrderID, CustomerID, OrderDate) \nVALUES (1003, 1, '2025-01-10');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I insert three new employees into the 'Employees' table in a single statement?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Employees (EmpID, FullName, Department) \nVALUES \n  (104, 'Tom Thumb', 'IT'), \n  (105, 'Sue Storm', 'HR'), \n  (106, 'Peter Pan', 'IT');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I insert multiple new products into the 'Products' table at once?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Products (ProductID, ProductName, Category, Price) \nVALUES \n  (203, 'Monitor', 'Electronics', 199.99),\n  (204, 'Desk Chair', 'Furniture', 89.50),\n  (205, 'Coffee Mug', 'Homeware', 12.00);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd two new customers in one query.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Customers (CustomerID, CustomerName) \nVALUES \n  (3, 'Charlie Brown'), \n  (4, 'David Copperfield');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert multiple items for 'Order 1002' at the same time.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO OrderItems (OrderID, ProductID, Quantity) \nVALUES \n  (1002, 202, 1), \n  (1002, 205, 3);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I insert a row into 'Employees' without specifying the column names?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- This relies on the exact table column order (e.g., EmpID, FullName, Department, Salary)\nINSERT INTO Employees \nVALUES (107, 'Eva Green', 'Finance', 70000);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a new product without listing columns, assuming (ProductID, ProductName, Price).\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Products \nVALUES (206, 'Headphones', 150.00);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add a new customer, inserting a NULL for their email?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Customers (CustomerID, CustomerName, Email) \nVALUES (5, 'Frank West', NULL);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert a new employee 'New Hire' (ID 108) into 'Sales', but with no salary assigned yet.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Employees (EmpID, FullName, Department, Salary) \nVALUES (108, 'New Hire', 'Sales', NULL);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a new 'Admin' user (ID 6) who joined on the current date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Users (UserID, Username, JoinDate) \nVALUES (6, 'Admin', CURRENT_DATE);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I copy all employees from the 'Employees' table into 'EmployeesArchive'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO EmployeesArchive (EmpID, FullName, Department) \nSELECT EmpID, FullName, Department \nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I copy just the 'Sales' employees into the 'SalesTeam' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO SalesTeam (EmployeeID, Name, Salary) \nSELECT EmpID, FullName, Salary \nFROM Employees \nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert all products from the 'Electronics' category into a 'ElectronicsProducts' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO ElectronicsProducts (ProductID, Name, Price) \nSELECT ProductID, ProductName, Price \nFROM Products \nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCopy all products with a price over $1000 into a 'HighValueProducts' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO HighValueProducts (PID, PName, Price) \nSELECT ProductID, ProductName, Price \nFROM Products \nWHERE Price > 1000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nArchive all orders that were placed before the year 2024.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO OldOrders (OrderID, CustomerID, OrderDate, Status) \nSELECT OrderID, CustomerID, OrderDate, Status \nFROM Orders \nWHERE OrderDate < '2024-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I update employee 101's last name to 'Johnson'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET LastName = 'Johnson' \nWHERE EmpID = 101;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nChange the price of the 'Laptop' (ProductID 201) to 1150.00.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products \nSET Price = 1150.00 \nWHERE ProductID = 201;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUpdate customer 'Alice Smith' (ID 1) to set her email to 'alice.j@newdomain.com'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Customers \nSET Email = 'alice.j@newdomain.com' \nWHERE CustomerID = 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I change the 'Status' of Order 1001 to 'Shipped'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders \nSET Status = 'Shipped' \nWHERE OrderID = 1001;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUpdate the quantity of 'Order 1002', 'Product 205' to 4.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE OrderItems \nSET Quantity = 4 \nWHERE OrderID = 1002 AND ProductID = 205;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I move employee 102 ('Jane Roe') to the 'Marketing' department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET Department = 'Marketing' \nWHERE EmpID = 102;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGive employee 101 ('John Doe') a raise to 75000 and change his title to 'Senior Developer'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET Salary = 75000, JobTitle = 'Senior Developer' \nWHERE EmpID = 101;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUpdate product 202 ('Mouse') to a new price of 27.50 and set stock to 200.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products \nSET Price = 27.50, Stock = 200 \nWHERE ProductID = 202;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to update customer 3's email and phone number at the same time?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Customers \nSET Email = 'charlie@new.com', PhoneNumber = '555-1234' \nWHERE CustomerID = 3;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'Status' of Order 1003 to 'Cancelled' and add a 'Note' that says 'Customer request'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders \nSET Status = 'Cancelled', Note = 'Customer request' \nWHERE OrderID = 1003;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I give a 10% raise to all employees in the 'Sales' department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET Salary = Salary * 1.10 \nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nIncrease the salary of all 'IT' employees by 5000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET Salary = Salary + 5000 \nWHERE Department = 'IT';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nApply a 20% discount to all products in the 'Apparel' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products \nSET Price = Price * 0.80 \nWHERE Category = 'Apparel';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDecrease the stock of all 'Electronics' by 1.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products \nSET Stock = Stock - 1 \nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nChange all 'Pending' orders to 'Processing'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders \nSET Status = 'Processing' \nWHERE Status = 'Pending';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I add 50 to the stock of 'ProductID' 203?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products \nSET Stock = Stock + 50 \nWHERE ProductID = 203;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAppend ' (On Sale)' to the 'ProductName' for all items in the 'Homeware' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Standard SQL (||)\nUPDATE Products \nSET ProductName = ProductName || ' (On Sale)' \nWHERE Category = 'Homeware';\n\n-- MySQL (CONCAT)\n-- UPDATE Products \n-- SET ProductName = CONCAT(ProductName, ' (On Sale)') \n-- WHERE Category = 'Homeware';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I update all employee salaries at once to give a 3% cost-of-living raise?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET Salary = Salary * 1.03;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet all 'Shipped' orders that were placed before 2024 to 'Archived'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders \nSET Status = 'Archived' \nWHERE Status = 'Shipped' AND OrderDate < '2024-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUpdate the 'Email' for all customers in 'Canada' to end in '.ca'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Customers \nSET Email = REPLACE(Email, '.com', '.ca') \nWHERE Country = 'Canada';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'ManagerID' for employee 103 to NULL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET ManagerID = NULL \nWHERE EmpID = 103;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'Price' to 0 for all products where 'Stock' is 0.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products \nSET Price = 0 \nWHERE Stock = 0;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'Category' to 'Unknown' for all products where the category is currently NULL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products \nSET Category = 'Unknown' \nWHERE Category IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I update the 'Status' for all orders placed by 'CustomerID' 2?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders \nSET Status = 'On Hold' \nWHERE CustomerID = 2;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nChange the 'Department' to 'Operations' for employees in 'IT' OR 'HR'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET Department = 'Operations' \nWHERE Department IN ('IT', 'HR');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDiscount all products with a price between $10 and $20 by 10%.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products \nSET Price = Price * 0.90 \nWHERE Price BETWEEN 10 AND 20;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'Email' of 'Peter Pan' to 'peter@neverland.com'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET Email = 'peter@neverland.com' \nWHERE FullName = 'Peter Pan';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUpdate the 'Stock' for all products, setting it to 10 if it is currently NULL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products \nSET Stock = 10 \nWHERE Stock IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I update all employees' salaries using a CASE statement based on department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = CASE \n    WHEN Department = 'Sales' THEN Salary * 1.10\n    WHEN Department = 'IT' THEN Salary * 1.05\n    ELSE Salary * 1.02\n  END;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to update the 'UnitPrice' in 'OrderItems' to match the current 'Price' in 'Products'? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE oi\nSET oi.UnitPrice = p.Price\nFROM OrderItems oi\nJOIN Products p ON oi.ProductID = p.ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to update 'UnitPrice' in 'OrderItems' to match the current 'Price' in 'Products'? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE OrderItems oi\nJOIN Products p ON oi.ProductID = p.ProductID\nSET oi.UnitPrice = p.Price;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to update 'UnitPrice' in 'OrderItems' to match the current 'Price' in 'Products'? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE OrderItems oi\nSET UnitPrice = p.Price\nFROM Products p\nWHERE oi.ProductID = p.ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'ManagerID' of all 'Sales' employees to Employee 102.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET ManagerID = 102 \nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow to set the 'Salary' of employee 104 to the average salary of the 'IT' department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET Salary = (SELECT AVG(Salary) FROM (SELECT * FROM Employees) AS Temp WHERE Department = 'IT')\nWHERE EmpID = 104;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGive a $1000 bonus to all employees hired before 2020.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET Salary = Salary + 1000 \nWHERE HireDate < '2020-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nChange the 'Category' of 'Product' 203 to 'Computing'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products \nSET Category = 'Computing' \nWHERE ProductID = 203;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nMark all orders from 'CustomerID' 4 as 'On Hold'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders \nSET Status = 'On Hold' \nWHERE CustomerID = 4;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'Email' for all employees in 'Finance' to 'finance.user@company.com'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees \nSET Email = 'finance.user@company.com' \nWHERE Department = 'Finance';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'Price' of all 'Books' to $15.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products \nSET Price = 15.00 \nWHERE Category = 'Books';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I insert a new employee, 'Grace Hopper' (ID 109), into the 'IT' department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Employees (EmpID, FullName, Department) \nVALUES (109, 'Grace Hopper', 'IT');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert a new product 'USB Cable' (ID 207) with a price of 9.99.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Products (ProductID, ProductName, Price) \nVALUES (207, 'USB Cable', 9.99);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd a new customer 'Ivy Lee' (ID 7) to the database.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Customers (CustomerID, CustomerName) \nVALUES (7, 'Ivy Lee');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert a new order (ID 1004) for Customer 3, placed today.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Orders (OrderID, CustomerID, OrderDate) \nVALUES (1004, 3, CURRENT_DATE);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd 5 units of Product 207 to Order 1004.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO OrderItems (OrderID, ProductID, Quantity) \nVALUES (1004, 207, 5);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I copy all 'Furniture' products to a 'FurnitureArchive' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO FurnitureArchive (ProductID, Name, Price)\nSELECT ProductID, ProductName, Price\nFROM Products\nWHERE Category = 'Furniture';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd 'Jack Kirby' (ID 110) and 'Stan Lee' (ID 111) to the 'Employees' table in one go.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO Employees (EmpID, FullName, Department)\nVALUES\n  (110, 'Jack Kirby', 'Creative'),\n  (111, 'Stan Lee', 'Creative');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I update 'Grace Hopper' (ID 109) to have a salary of 120000?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = 120000\nWHERE EmpID = 109;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUpdate the 'USB Cable' (ID 207) to have a stock of 500.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products\nSET Stock = 500\nWHERE ProductID = 207;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nChange customer 'Ivy Lee' (ID 7) email to 'ivy@vines.com'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Customers\nSET Email = 'ivy@vines.com'\nWHERE CustomerID = 7;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nMark 'Order 1004' as 'Processing'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders\nSET Status = 'Processing'\nWHERE OrderID = 1004;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nMove all employees in 'Creative' to the 'Marketing' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Department = 'Marketing'\nWHERE Department = 'Creative';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGive a 5% raise to all employees who were hired before 2022.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = Salary * 1.05\nWHERE HireDate < '2022-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGive a $200 bonus to all employees in the 'HR' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = Salary + 200\nWHERE Department = 'HR';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nPut all 'Homeware' products on sale, reducing their price by 15%.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products\nSET Price = Price * 0.85\nWHERE Category = 'Homeware';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAdd 100 to the stock of all 'Books'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products\nSET Stock = Stock + 100\nWHERE Category = 'Books';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nChange all 'Delivered' orders to 'Completed'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders\nSET Status = 'Completed'\nWHERE Status = 'Delivered';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'ManagerID' to NULL for all employees in the 'Finance' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET ManagerID = NULL\nWHERE Department = 'Finance';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'Price' to 5.00 for all products in the 'Clearance' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products\nSET Price = 5.00\nWHERE Category = 'Clearance';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I update 'Employee' 105's 'FullName' and 'Salary' in one statement?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET FullName = 'Susan Storm', Salary = 62000\nWHERE EmpID = 105;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUpdate the 'Desk Chair' (ID 204) to a new category 'Office' and price 95.00.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products\nSET Category = 'Office', Price = 95.00\nWHERE ProductID = 204;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'Email' of 'David Copperfield' (ID 4) to 'magic@ex.com' and 'Country' to 'UK'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Customers\nSET Email = 'magic@ex.com', Country = 'UK'\nWHERE CustomerID = 4;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I reset the 'Stock' to 0 for all products that have NULL in the stock column?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products\nSET Stock = 0\nWHERE Stock IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I assign employee 101 as the manager for all employees in the 'IT' department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET ManagerID = 101\nWHERE Department = 'IT';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I update all product prices, giving a 10% discount to 'Electronics' and a 20% discount to 'Apparel'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products\nSET Price = CASE \n    WHEN Category = 'Electronics' THEN Price * 0.90\n    WHEN Category = 'Apparel' THEN Price * 0.80\n    ELSE Price\n  END;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUpdate all orders from 'CustomerID' 1 or 2 to have a 'Priority' status.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders\nSET Status = 'Priority'\nWHERE CustomerID IN (1, 2);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nReduce the price of all products with 'Coffee' in the name by $1.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products\nSET Price = Price - 1\nWHERE ProductName LIKE '%Coffee%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all employees, and their department name if they have one.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT e.Name, d.DeptName\nFROM Employees e\nLEFT JOIN Departments d ON e.DeptID = d.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all departments, and any employees in them. Include empty departments.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT d.DeptName, e.Name\nFROM Departments d\nLEFT JOIN Employees e ON d.DeptID = e.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow all employees and all departments, matching them where possible.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT e.Name, d.DeptName\nFROM Employees e\nFULL OUTER JOIN Departments d ON e.DeptID = d.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get a list of all employees and the projects they are working on? (Tables: Employees, Projects, EmployeeProjects)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT e.Name, p.ProjectName\nFROM Employees e\nJOIN EmployeeProjects ep ON e.EmpID = ep.EmpID\nJOIN Projects p ON ep.ProjectID = p.ProjectID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I list an employee and their manager's name in one row?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name AS EmployeeName, \n  m.Name AS ManagerName\nFROM Employees e\nLEFT JOIN Employees m ON e.ManagerID = m.EmpID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find employees who earn more than the company average salary? (Subquery)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, Salary\nFROM Employees\nWHERE Salary > (SELECT AVG(Salary) FROM Employees);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get a list of employee names and their department names? (Tables: Employees, Departments)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Employees.Name, \n  Departments.DeptName\nFROM Employees\nINNER JOIN Departments ON Employees.DeptID = Departments.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the customer name and the orders they placed. (Tables: Customers, Orders)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Customers.CustomerName, \n  Orders.OrderID, \n  Orders.OrderDate\nFROM Customers\nINNER JOIN Orders ON Customers.CustomerID = Orders.CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need a list of all products and the names of the suppliers who provide them. (Tables: Products, Suppliers)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Products.ProductName, \n  Suppliers.SupplierName\nFROM Products\nJOIN Suppliers ON Products.SupplierID = Suppliers.SupplierID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me *all* employees, and their department name if they have one. If an employee has no department, they should still be in the list.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Employees.Name, \n  Departments.DeptName\nFROM Employees\nLEFT JOIN Departments ON Employees.DeptID = Departments.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI want to see all customers, and any orders they have. Customers with no orders must be included.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Customers.CustomerName, \n  Orders.OrderID\nFROM Customers\nLEFT OUTER JOIN Orders ON Customers.CustomerID = Orders.CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me *all* departments, and any employees in them. If a department is empty, it should still be in the list.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Departments.DeptName, \n  Employees.Name\nFROM Departments\nLEFT JOIN Employees ON Departments.DeptID = Employees.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the syntax for a right join? Show all employees and any matching departments, but also include any departments that are empty.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Employees.Name, \n  Departments.DeptName\nFROM Employees\nRIGHT JOIN Departments ON Employees.DeptID = Departments.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow all orders, and the customer who placed them. Include any orders that have a missing CustomerID.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Orders.OrderID, \n  Customers.CustomerName\nFROM Orders\nRIGHT OUTER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need a list of all employees *and* all departments, matching them where possible. If an employee has no department, or a department has no employees, they should still be shown.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Employees.Name, \n  Departments.DeptName\nFROM Employees\nFULL OUTER JOIN Departments ON Employees.DeptID = Departments.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow all customers and all orders. Match them if possible, but include customers with no orders and orders with no customers.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Customers.CustomerName, \n  Orders.OrderID\nFROM Customers\nFULL JOIN Orders ON Customers.CustomerID = Orders.CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get a list of all possible combinations of 'Students' and 'Classes'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Students.StudentName, \n  Classes.ClassName\nFROM Students\nCROSS JOIN Classes;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me every possible pairing of a 'Product' with a 'Warehouse'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Products.ProductName, \n  Warehouses.WarehouseName\nFROM Products\nCROSS JOIN Warehouses;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I list an employee and their manager's name in one row? (Table: Employees, with ManagerID)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name AS EmployeeName, \n  m.Name AS ManagerName\nFROM Employees e\nLEFT JOIN Employees m ON e.ManagerID = m.EmpID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all employees who have the same 'HireDate' as another employee.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e1.Name, \n  e2.Name, \n  e1.HireDate\nFROM Employees e1\nJOIN Employees e2 ON e1.HireDate = e2.HireDate AND e1.EmpID <> e2.EmpID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get the product name, order ID, and quantity for all items sold? (Tables: Products, OrderItems)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Products.ProductName, \n  OrderItems.OrderID, \n  OrderItems.Quantity\nFROM Products\nJOIN OrderItems ON Products.ProductID = OrderItems.ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI need the customer name, order date, and product name for every item sold. (Tables: Customers, Orders, OrderItems, Products)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  o.OrderDate, \n  p.ProductName\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nJOIN OrderItems oi ON o.OrderID = oi.OrderID\nJOIN Products p ON oi.ProductID = p.ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all employees in the 'Engineering' department. Use a JOIN. (Tables: Employees, Departments)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nWHERE d.DeptName = 'Engineering';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet all orders placed by 'John Smith'. Use a JOIN. (Tables: Customers, Orders)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  o.OrderID, \n  o.OrderDate\nFROM Orders o\nJOIN Customers c ON o.CustomerID = c.CustomerID\nWHERE c.CustomerName = 'John Smith';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the total number of employees in each department. Show the department name and the count.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName, \n  COUNT(e.EmpID) AS EmployeeCount\nFROM Departments d\nLEFT JOIN Employees e ON d.DeptID = e.DeptID\nGROUP BY d.DeptName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCalculate the total revenue for each customer. Show customer name and total revenue.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  SUM(oi.Quantity * oi.UnitPrice) AS TotalRevenue\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nJOIN OrderItems oi ON o.OrderID = oi.OrderID\nGROUP BY c.CustomerName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find all customers who have *never* placed an order? Use a JOIN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName\nFROM Customers c\nLEFT JOIN Orders o ON c.CustomerID = o.CustomerID\nWHERE o.OrderID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that have *never* been sold. Use a JOIN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProductName\nFROM Products p\nLEFT JOIN OrderItems oi ON p.ProductID = oi.ProductID\nWHERE oi.OrderID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all departments that have no employees. Use a RIGHT JOIN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName\nFROM Employees e\nRIGHT JOIN Departments d ON e.DeptID = d.DeptID\nWHERE e.EmpID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me employees and departments, but only where a match exists. Use INNER JOIN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  d.DeptName\nFROM Employees e\nINNER JOIN Departments d ON e.DeptID = d.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a list of employee names, their project names, and the hours worked. (Tables: Employees, Projects, EmployeeProjects)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  p.ProjectName, \n  ep.HoursWorked\nFROM Employees e\nJOIN EmployeeProjects ep ON e.EmpID = ep.EmpID\nJOIN Projects p ON ep.ProjectID = p.ProjectID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the names of employees who worked on the 'Bluebook' project.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name\nFROM Employees e\nJOIN EmployeeProjects ep ON e.EmpID = ep.EmpID\nJOIN Projects p ON ep.ProjectID = p.ProjectID\nWHERE p.ProjectName = 'Bluebook';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCalculate the total hours worked for each project. Show project name and total hours.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProjectName, \n  SUM(ep.HoursWorked) AS TotalHours\nFROM Projects p\nLEFT JOIN EmployeeProjects ep ON p.ProjectID = ep.ProjectID\nGROUP BY p.ProjectName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCalculate the total hours worked by each employee. Show employee name and total hours.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  SUM(ep.HoursWorked) AS TotalHours\nFROM Employees e\nLEFT JOIN EmployeeProjects ep ON e.EmpID = ep.EmpID\nGROUP BY e.Name;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all employees from the 'Sales' department who were hired after 2023. Use a JOIN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  e.HireDate\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nWHERE d.DeptName = 'Sales' AND e.HireDate > '2023-12-31';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet the total revenue (Quantity * UnitPrice) for all 'Electronics' products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SUM(oi.Quantity * oi.UnitPrice) AS TotalElectronicsRevenue\nFROM OrderItems oi\nJOIN Products p ON oi.ProductID = p.ProductID\nWHERE p.Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the average salary for each department, but only show departments in 'New York'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName, \n  AVG(e.Salary) AS AverageSalary\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nWHERE d.Location = 'New York'\nGROUP BY d.DeptName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all employees who share a manager with 'John Smith'. Use a self-join.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e2.Name\nFROM Employees e1\nJOIN Employees e2 ON e1.ManagerID = e2.ManagerID\nWHERE e1.Name = 'John Smith' AND e2.Name <> 'John Smith';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show all employees and all projects, even if they are not related? (FULL OUTER JOIN)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  p.ProjectName\nFROM Employees e\nLEFT JOIN EmployeeProjects ep ON e.EmpID = ep.EmpID\nFULL OUTER JOIN Projects p ON ep.ProjectID = p.ProjectID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all possible 'T-Shirt' combinations from 'Sizes' and 'Colors' tables.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  s.SizeName, \n  c.ColorName\nFROM Sizes s\nCROSS JOIN Colors c;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I join 'Employees' and 'Departments' using the 'USING' keyword?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- This assumes the join column 'DeptID' is named the same in both tables.\nSELECT \n  Name, \n  DeptName\nFROM Employees\nJOIN Departments USING (DeptID);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me employees who are in the same department as 'Jane Doe'. Use a JOIN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e2.Name\nFROM Employees e1\nJOIN Employees e2 ON e1.DeptID = e2.DeptID\nWHERE e1.Name = 'Jane Doe' AND e2.Name <> 'Jane Doe';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I join 'Orders' and 'OrderItems' on 'OrderID'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  o.OrderDate, \n  oi.ProductID, \n  oi.Quantity\nFROM Orders o\nJOIN OrderItems oi ON o.OrderID = oi.OrderID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'Employees' and their 'Managers'. Use a self-join with aliases 'e' and 'm'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name AS Employee, \n  m.Name AS Manager\nFROM Employees e\nLEFT JOIN Employees m ON e.ManagerID = m.EmpID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all 'OrderItems' for orders placed in '2024'. Use a JOIN with 'Orders'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  oi.*\nFROM OrderItems oi\nJOIN Orders o ON oi.OrderID = o.OrderID\nWHERE o.OrderDate BETWEEN '2024-01-01' AND '2024-12-31';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all products sold to 'Customer' 101. (Requires 4 tables)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  DISTINCT p.ProductName\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nJOIN OrderItems oi ON o.OrderID = oi.OrderID\nJOIN Products p ON oi.ProductID = p.ProductID\nWHERE c.CustomerID = 101;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'Employees' who are *not* managers. Use a self-join.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name\nFROM Employees e\nLEFT JOIN Employees m ON e.EmpID = m.ManagerID\nWHERE m.EmpID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is a 'Natural Join'? Show an example between 'Employees' and 'Departments'.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Natural Join automatically joins on columns with the same name (e.g., DeptID).\n-- It's generally avoided in production code as it can be ambiguous.\nSELECT \n  Name, \n  DeptName\nFROM Employees\nNATURAL JOIN Departments;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'Employees' who do not have a department. Use a LEFT JOIN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name\nFROM Employees e\nLEFT JOIN Departments d ON e.DeptID = d.DeptID\nWHERE d.DeptID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the average salary of employees, grouped by department location.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.Location, \n  AVG(e.Salary) AS AvgSalary\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nGROUP BY d.Location;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me 'INNER JOIN' using table aliases 't1' and 't2'. (Tables: TableA, TableB, Column: ID)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  t1.ColumnA, \n  t2.ColumnB\nFROM TableA t1\nINNER JOIN TableB t2 ON t1.ID = t2.ID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me 'LEFT JOIN' using table aliases 'a' and 'b'. (Tables: TableA, TableB, Column: ID)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  a.ColumnA, \n  b.ColumnB\nFROM TableA a\nLEFT JOIN TableB b ON a.ID = b.ID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me 'RIGHT JOIN' using table aliases 'a' and 'b'. (Tables: TableA, TableB, Column: ID)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  a.ColumnA, \n  b.ColumnB\nFROM TableA a\nRIGHT JOIN TableB b ON a.ID = b.ID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me 'FULL OUTER JOIN' using table aliases 'a' and 'b'. (Tables: TableA, TableB, Column: ID)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  a.ColumnA, \n  b.ColumnB\nFROM TableA a\nFULL OUTER JOIN TableB b ON a.ID = b.ID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me 'CROSS JOIN' using table aliases 'a' and 'b'. (Tables: TableA, TableB)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  a.*, \n  b.*\nFROM TableA a\nCROSS JOIN TableB b;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me a 'self-join' using table aliases 'e1' and 'e2'. (Table: Employees, Column: ManagerID)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e1.Name AS Employee, \n  e2.Name AS Manager\nFROM Employees e1\nLEFT JOIN Employees e2 ON e1.ManagerID = e2.EmpID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I join three tables? (Employees, Departments, Locations)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  d.DeptName, \n  l.City\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nJOIN Locations l ON d.LocationID = l.LocationID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nJoin 'Customers', 'Orders', and 'Shippers' tables.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  o.OrderID, \n  s.ShipperName\nFROM Orders o\nJOIN Customers c ON o.CustomerID = c.CustomerID\nJOIN Shippers s ON o.ShipperID = s.ShipperID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nJoin 'Products', 'Categories', and 'Suppliers' tables.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProductName, \n  c.CategoryName, \n  s.SupplierName\nFROM Products p\nJOIN Categories c ON p.CategoryID = c.CategoryID\nJOIN Suppliers s ON p.SupplierID = s.SupplierID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find customers who live in 'London' and have placed an order?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  o.OrderID\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nWHERE c.City = 'London';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all orders that included a 'Laptop'. (Tables: Orders, OrderItems, Products)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  DISTINCT o.OrderID, \n  o.OrderDate\nFROM Orders o\nJOIN OrderItems oi ON o.OrderID = oi.OrderID\nJOIN Products p ON oi.ProductID = p.ProductID\nWHERE p.ProductName = 'Laptop';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a list of all 'Employees' and 'Projects' they are on. Include employees not on any project.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  p.ProjectName\nFROM Employees e\nLEFT JOIN EmployeeProjects ep ON e.EmpID = ep.EmpID\nLEFT JOIN Projects p ON ep.ProjectID = p.ProjectID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a list of all 'Projects' and 'Employees' on them. Include projects with no employees.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProjectName, \n  e.Name\nFROM Projects p\nLEFT JOIN EmployeeProjects ep ON p.ProjectID = ep.ProjectID\nLEFT JOIN Employees e ON ep.EmpID = e.EmpID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who are *not* assigned to the 'Alpha' project.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name\nFROM Employees e\nLEFT JOIN EmployeeProjects ep ON e.EmpID = ep.EmpID\nLEFT JOIN Projects p ON ep.ProjectID = p.ProjectID AND p.ProjectName = 'Alpha'\nWHERE p.ProjectID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the total number of orders placed by customers from 'USA'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  COUNT(o.OrderID) AS TotalOrders\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nWHERE c.Country = 'USA';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the average salary of employees, grouped by department, sorted by average salary descending.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName, \n  AVG(e.Salary) AS AvgSalary\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nGROUP BY d.DeptName\nORDER BY AvgSalary DESC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the total number of items sold per product category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.Category, \n  SUM(oi.Quantity) AS TotalSold\nFROM Products p\nJOIN OrderItems oi ON p.ProductID = oi.ProductID\nGROUP BY p.Category;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all customers from 'New York' and the total amount they've spent.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  SUM(oi.Quantity * oi.UnitPrice) AS TotalSpent\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nJOIN OrderItems oi ON o.OrderID = oi.OrderID\nWHERE c.City = 'New York'\nGROUP BY c.CustomerName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all departments that have more than 10 employees. Use a JOIN and GROUP BY.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName, \n  COUNT(e.EmpID) AS EmployeeCount\nFROM Departments d\nJOIN Employees e ON d.DeptID = e.DeptID\nGROUP BY d.DeptName\nHAVING COUNT(e.EmpID) > 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'Employees' from 'Building A'. (Requires 3 tables: Employees, Departments, Locations)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nJOIN Locations l ON d.LocationID = l.LocationID\nWHERE l.Building = 'Building A';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the total revenue for orders placed in 2024.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SUM(oi.Quantity * oi.UnitPrice) AS TotalRevenue\nFROM Orders o\nJOIN OrderItems oi ON o.OrderID = oi.OrderID\nWHERE o.OrderDate >= '2024-01-01' AND o.OrderDate < '2025-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I join 'Employees' and 'Departments' on 'DeptID'? Use 'e' and 'd' as aliases.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  d.DeptName\nFROM Employees AS e\nJOIN Departments AS d ON e.DeptID = d.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the name of the manager for 'John Smith'. Use a self-join.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  m.Name AS ManagerName\nFROM Employees e\nJOIN Employees m ON e.ManagerID = m.EmpID\nWHERE e.Name = 'John Smith';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all customers and the count of orders they placed, including customers with 0 orders.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  COUNT(o.OrderID) AS OrderCount\nFROM Customers c\nLEFT JOIN Orders o ON c.CustomerID = o.CustomerID\nGROUP BY c.CustomerName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who have the same 'LastName' as their manager. Use a self-join.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name\nFROM Employees e\nJOIN Employees m ON e.ManagerID = m.EmpID\nWHERE e.LastName = m.LastName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get all 'Shipped' orders from customers in 'London'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  o.OrderID\nFROM Orders o\nJOIN Customers c ON o.CustomerID = c.CustomerID\nWHERE o.Status = 'Shipped' AND c.City = 'London';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all products that have been sold. Use a JOIN with OrderItems.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  DISTINCT p.ProductName\nFROM Products p\nJOIN OrderItems oi ON p.ProductID = oi.ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'Employees' and 'Departments' that are in the same 'Location'. (Tables: Employees, Departments)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Assuming Employees table also has a Location column\nSELECT \n  e.Name, \n  d.DeptName\nFROM Employees e\nJOIN Departments d ON e.Location = d.Location;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who earn more than their manager. Use a self-join.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name AS EmployeeName, \n  e.Salary AS EmployeeSalary, \n  m.Name AS ManagerName, \n  m.Salary AS ManagerSalary\nFROM Employees e\nJOIN Employees m ON e.ManagerID = m.EmpID\nWHERE e.Salary > m.Salary;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all employees who work in a department that has no manager. (Tables: Employees, Departments)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Assuming Departments has a ManagerID column\nSELECT \n  e.Name\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nWHERE d.ManagerID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I join 'Employees' and 'Salaries' on 'EmpID'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  s.SalaryAmount\nFROM Employees e\nJOIN Salaries s ON e.EmpID = s.EmpID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I join 'Students' and 'Grades' on 'StudentID'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  s.StudentName, \n  g.Course, \n  g.Grade\nFROM Students s\nJOIN Grades g ON s.StudentID = g.StudentID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'Students' and their 'Grades', including students with no grades.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  s.StudentName, \n  g.Grade\nFROM Students s\nLEFT JOIN Grades g ON s.StudentID = g.StudentID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'Courses' and their 'Grades', including courses with no grades.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CourseName, \n  g.Grade\nFROM Courses c\nLEFT JOIN Grades g ON c.CourseID = g.CourseID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'Students' and 'Grades', but also include 'Grades' not linked to a 'Student'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  s.StudentName, \n  g.Grade\nFROM Students s\nRIGHT JOIN Grades g ON s.StudentID = g.StudentID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'Students' and 'Grades', including students without grades and grades without students.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  s.StudentName, \n  g.Grade\nFROM Students s\nFULL OUTER JOIN Grades g ON s.StudentID = g.StudentID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get every 'Student' paired with every 'Teacher'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  s.StudentName, \n  t.TeacherName\nFROM Students s\nCROSS JOIN Teachers t;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the average grade for each 'Student'. Show student name and average grade.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  s.StudentName, \n  AVG(g.NumericGrade) AS AverageGrade\nFROM Students s\nJOIN Grades g ON s.StudentID = g.StudentID\nGROUP BY s.StudentName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the average grade for each 'Course'. Show course name and average grade.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CourseName, \n  AVG(g.NumericGrade) AS AverageGrade\nFROM Courses c\nJOIN Grades g ON c.CourseID = g.CourseID\nGROUP BY c.CourseName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all students who got an 'A' in 'History 101'. (Tables: Students, Grades, Courses)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  s.StudentName\nFROM Students s\nJOIN Grades g ON s.StudentID = g.StudentID\nJOIN Courses c ON g.CourseID = c.CourseID\nWHERE c.CourseName = 'History 101' AND g.Grade = 'A';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I join 'Employees' and 'Departments' without aliases?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Employees.Name, \n  Departments.DeptName\nFROM Employees\nJOIN Departments ON Employees.DeptID = Departments.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees hired on the same date as 'Alice'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e2.Name\nFROM Employees e1\nJOIN Employees e2 ON e1.HireDate = e2.HireDate\nWHERE e1.Name = 'Alice' AND e2.Name <> 'Alice';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all 'OrderItems' that have a 'ProductID' that is also in 'Products'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  oi.*\nFROM OrderItems oi\nINNER JOIN Products p ON oi.ProductID = p.ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all 'OrderItems', and include the 'ProductName' from 'Products'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  oi.OrderID, \n  p.ProductName, \n  oi.Quantity\nFROM OrderItems oi\nJOIN Products p ON oi.ProductID = p.ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all 'Orders' and the 'CustomerName' for each, sorted by order date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  o.OrderID, \n  o.OrderDate, \n  c.CustomerName\nFROM Orders o\nJOIN Customers c ON o.CustomerID = c.CustomerID\nORDER BY o.OrderDate;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all projects that have no employees assigned. Use a LEFT JOIN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProjectName\nFROM Projects p\nLEFT JOIN EmployeeProjects ep ON p.ProjectID = ep.ProjectID\nWHERE ep.EmpID IS NULL;\n```\n<end_Do_turn>"}
{"text": "<start_of_turn>user\nFind all employees who are not assigned to any projects. Use a LEFT JOIN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name\nFROM Employees e\nLEFT JOIN EmployeeProjects ep ON e.EmpID = ep.EmpID\nWHERE ep.ProjectID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees and all projects, showing 'NULL' for non-matches. (FULL JOIN)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  p.ProjectName\nFROM Employees e\nLEFT JOIN EmployeeProjects ep ON e.EmpID = ep.EmpID\nFULL JOIN Projects p ON ep.ProjectID = p.ProjectID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I join 'Employees' and 'Departments' on two columns, 'DeptID' and 'LocationID'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  d.DeptName\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID AND e.LocationID = d.LocationID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me employees who are in the 'Sales' department *and* are working on the 'Alpha' project.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nJOIN EmployeeProjects ep ON e.EmpID = ep.EmpID\nJOIN Projects p ON ep.ProjectID = p.ProjectID\nWHERE d.DeptName = 'Sales' AND p.ProjectName = 'Alpha';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all customers from 'USA' and all orders from 'USA' warehouses. (Join Customers, Orders, Warehouses)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  o.OrderID\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nJOIN Warehouses w ON o.WarehouseID = w.WarehouseID\nWHERE c.Country = 'USA' AND w.Country = 'USA';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'Employees' and their 'Managers' from the 'Engineering' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name AS Employee, \n  m.Name AS Manager\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nLEFT JOIN Employees m ON e.ManagerID = m.EmpID\nWHERE d.DeptName = 'Engineering';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I rank all employees by their salary, from highest to lowest?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the rank of products by price, from most expensive to least expensive.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  RANK() OVER (ORDER BY Price DESC) AS PriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I rank employees by salary *within* each department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  RANK() OVER (PARTITION BY Department ORDER BY Salary DESC) AS DeptSalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the rank of products by price, partitioned by their category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  RANK() OVER (PARTITION BY Category ORDER BY Price DESC) AS CategoryPriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get the rank of customers by their 'JoinDate'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerName, \n  JoinDate, \n  RANK() OVER (ORDER BY JoinDate ASC) AS JoinRank\nFROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the rank of orders by their total amount, highest first.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  TotalAmount, \n  RANK() OVER (ORDER BY TotalAmount DESC) AS OrderRank\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank students by their 'Grade', partitioned by 'Course'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  StudentName, \n  Course, \n  Grade, \n  RANK() OVER (PARTITION BY Course ORDER BY Grade ASC) AS GradeRank\nFROM StudentGrades;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between RANK() and DENSE_RANK()?\n<end_of_turn>\n<start_of_turn>model\n`RANK()` skips ranks after a tie (e.g., 1, 2, 2, 4), while `DENSE_RANK()` does not skip ranks (e.g., 1, 2, 2, 3).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me an example of DENSE_RANK() for employee salaries.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  DENSE_RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUse DENSE_RANK() to rank products by price within each category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  DENSE_RANK() OVER (PARTITION BY Category ORDER BY Price DESC) AS CategoryPriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the top 3 highest salaries per department using DENSE_RANK()?\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH RankedSalaries AS (\n  SELECT \n    Name, \n    Department, \n    Salary, \n    DENSE_RANK() OVER (PARTITION BY Department ORDER BY Salary DESC) AS RankNum\n  FROM Employees\n)\nSELECT Name, Department, Salary, RankNum\nFROM RankedSalaries\nWHERE RankNum <= 3;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by their hire date, oldest first, using DENSE_RANK().\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  DENSE_RANK() OVER (ORDER BY HireDate ASC) AS HireRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a unique, sequential number to each employee, ordered by name.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  ROW_NUMBER() OVER (ORDER BY Name ASC) AS RowNum\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I use ROW_NUMBER() to get the 10th-20th most expensive products (pagination)?\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH NumberedProducts AS (\n  SELECT \n    ProductName, \n    Price, \n    ROW_NUMBER() OVER (ORDER BY Price DESC) AS RowNum\n  FROM Products\n)\nSELECT ProductName, Price\nFROM NumberedProducts\nWHERE RowNum BETWEEN 10 AND 20;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I assign a row number to each employee *within* their department, ordered by salary?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  ROW_NUMBER() OVER (PARTITION BY Department ORDER BY Salary DESC) AS RowNum\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow can I find and delete duplicate employees based on 'Email'?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (T-SQL / PostgreSQL Syntax)\nWITH Duplicates AS (\n  SELECT \n    EmpID, \n    ROW_NUMBER() OVER (PARTITION BY Email ORDER BY EmpID) AS RowNum\n  FROM Employees\n)\nDELETE FROM Duplicates\nWHERE RowNum > 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a simple row number to all customers, ordered by CustomerID.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerName, \n  ROW_NUMBER() OVER (ORDER BY CustomerID) AS RowNum\nFROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the single most recent order for each customer.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH NumberedOrders AS (\n  SELECT \n    OrderID, \n    CustomerID, \n    OrderDate, \n    ROW_NUMBER() OVER (PARTITION BY CustomerID ORDER BY OrderDate DESC) AS RowNum\n  FROM Orders\n)\nSELECT OrderID, CustomerID, OrderDate\nFROM NumberedOrders\nWHERE RowNum = 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show each employee's salary and the salary of the employee hired just *before* them?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LAG(Salary, 1) OVER (ORDER BY HireDate) AS PreviousSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's salary and the salary of the employee hired just *after* them.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LEAD(Salary, 1) OVER (ORDER BY HireDate) AS NextSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get each employee's salary and the salary of the previous employee *within the same department*?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  LAG(Salary, 1) OVER (PARTITION BY Department ORDER BY Salary) AS PrevDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the 'Next' employee's name for each employee when ordered alphabetically.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  LEAD(Name) OVER (ORDER BY Name) AS NextEmployeeName\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the difference in salary between an employee and the person hired just before them?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  Salary - LAG(Salary, 1, Salary) OVER (ORDER BY HireDate) AS SalaryDiff\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the current order's amount and the previous order's amount (based on date).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  TotalAmount, \n  LAG(TotalAmount) OVER (ORDER BY OrderDate) AS PreviousOrderAmount\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the current product's price and the next most expensive product's price.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  LEAD(Price) OVER (ORDER BY Price) AS NextPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCompare each day's sales to the sales from 7 days prior.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  LAG(DailySales, 7) OVER (ORDER BY SaleDate) AS Sales7DaysAgo\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the time difference between a customer's current order and their previous order.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (PostgreSQL)\nSELECT \n  CustomerID, \n  OrderDate, \n  OrderDate - LAG(OrderDate) OVER (PARTITION BY CustomerID ORDER BY OrderDate) AS TimeSinceLastOrder\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show each employee's salary and the average salary of their department on the same row?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  AVG(Salary) OVER (PARTITION BY Department) AS DeptAverageSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sum of all salaries, but as a new column on every employee row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  SUM(Salary) OVER () AS TotalCompanySalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get a running total of all sales, ordered by date?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  TotalAmount, \n  SUM(TotalAmount) OVER (ORDER BY OrderDate) AS RunningTotal\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me a running total of sales *for each customer*.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerID, \n  OrderID, \n  OrderDate, \n  TotalAmount, \n  SUM(TotalAmount) OVER (PARTITION BY CustomerID ORDER BY OrderDate) AS CustomerRunningTotal\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the total number of employees in each department, but show it on every employee row?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  COUNT(*) OVER (PARTITION BY Department) AS DeptEmployeeCount\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total number of all employees in the company on every single row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  COUNT(*) OVER () AS TotalEmployees\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the highest salary in each department and show it on each employee's row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  MAX(Salary) OVER (PARTITION BY Department) AS HighestDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the lowest price in each product category, but show it next to each product.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  MIN(Price) OVER (PARTITION BY Category) AS LowestCategoryPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's salary as a percentage of their department's total salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  Salary * 100.0 / SUM(Salary) OVER (PARTITION BY Department) AS PctOfDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each product's price as a percentage of the total price of all products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  Price * 100.0 / SUM(Price) OVER () AS PctOfTotalPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get a 3-day moving average of sales?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  AVG(DailySales) OVER (\n    ORDER BY SaleDate \n    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n  ) AS '3DayMovingAvg'\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the total sales in a 7-day window (3 days before, current day, 3 days after).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  SUM(DailySales) OVER (\n    ORDER BY SaleDate \n    ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING\n  ) AS '7DayWindowTotal'\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the first value in an ordered set. (e.g., the name of the first person hired).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  FIRST_VALUE(Name) OVER (ORDER BY HireDate ASC) AS FirstHired\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the name of the highest-paid employee on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  FIRST_VALUE(Name) OVER (ORDER BY Salary DESC) AS HighestEarner\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the name of the lowest-paid employee in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  FIRST_VALUE(Name) OVER (PARTITION BY Department ORDER BY Salary ASC) AS LowestEarnerInDept\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the name of the last person hired in the company on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  LAST_VALUE(Name) OVER (\n    ORDER BY HireDate ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS LastHired\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the name of the most expensive product on every product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  LAST_VALUE(ProductName) OVER (\n    ORDER BY Price ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS MostExpensive\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the most expensive product *in each category* on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  LAST_VALUE(ProductName) OVER (\n    PARTITION BY Category \n    ORDER BY Price ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS MostExpensiveInCategory\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I divide employees into 4 equal groups (quartiles) based on salary?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  NTILE(4) OVER (ORDER BY Salary DESC) AS SalaryQuartile\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide students into 10 groups (deciles) based on their grade.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  StudentName, \n  Grade, \n  NTILE(10) OVER (ORDER BY Grade DESC) AS GradeDecile\nFROM StudentGrades;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I split products into 5 groups (quintiles) within each category?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  NTILE(5) OVER (PARTITION BY Category ORDER BY Price DESC) AS PriceQuintile\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the percentile rank for each employee's salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (PostgreSQL / SQL Server syntax)\nSELECT \n  Name, \n  Salary, \n  PERCENT_RANK() OVER (ORDER BY Salary) AS SalaryPercentile\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the cumulative distribution of product prices.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (PostgreSQL / SQL Server syntax)\nSELECT \n  ProductName, \n  Price, \n  CUME_DIST() OVER (ORDER BY Price) AS CumulativeDistribution\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary. If there's a tie, give them the same rank and skip the next number.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary. If there's a tie, give them the same rank but do not skip the next number.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  DENSE_RANK() OVER (ORDER BY Salary DESC) AS SalaryDenseRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGive me a unique number for each row in the 'Orders' table, starting from 1, based on 'OrderDate'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  ROW_NUMBER() OVER (ORDER BY OrderDate) AS OrderNum\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the salary of the person hired just before, using a default of 0 if it's the first person.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LAG(Salary, 1, 0) OVER (ORDER BY HireDate) AS PreviousSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the salary of the person hired two positions *after* the current employee.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LEAD(Salary, 2) OVER (ORDER BY HireDate) AS NextNextSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sales for the current, previous, and next day all on one row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales AS CurrentSales,\n  LAG(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS PreviousSales,\n  LEAD(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS NextSales\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the average company salary on every employee row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  AVG(Salary) OVER () AS CompanyAverage\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total quantity sold for each product, on every 'OrderItems' row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  ProductID, \n  Quantity, \n  SUM(Quantity) OVER (PARTITION BY ProductID) AS TotalSoldForProduct\nFROM OrderItems;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow a cumulative sum of employee salaries, ordered by employee ID.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  EmpID, \n  Name, \n  Salary, \n  SUM(Salary) OVER (ORDER BY EmpID) AS RunningTotalSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow a cumulative count of employees hired, ordered by hire date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  COUNT(*) OVER (ORDER BY HireDate) AS CumulativeHires\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the highest salary in the whole company and display it on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  MAX(Salary) OVER () AS MaxCompanySalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the lowest salary in each department, but show it on every employee's row for that department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  MIN(Salary) OVER (PARTITION BY Department) AS MinDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the price of each product and the price of the most expensive product in its category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  MAX(Price) OVER (PARTITION BY Category) AS MaxCategoryPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary, but do not partition by department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS OverallRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a row number to all products, ordered by price from cheapest to most expensive.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  ROW_NUMBER() OVER (ORDER BY Price ASC) AS PriceRowNumber\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign row numbers to orders, restarting the count for each customer, ordered by date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerID, \n  OrderID, \n  OrderDate, \n  ROW_NUMBER() OVER (PARTITION BY CustomerID ORDER BY OrderDate) AS CustomerOrderNumber\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the salary of the employee hired immediately before the current one, in the same department, ordered by name.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  LAG(Salary) OVER (PARTITION BY Department ORDER BY Name) AS PreviousEmpSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 'HireDate' of the employee hired immediately after the current one, in the same department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  LEAD(HireDate) OVER (PARTITION BY Department ORDER BY HireDate) AS NextHireDate\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sales for the current month and the previous month.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Month, \n  MonthlySales, \n  LAG(MonthlySales, 1, 0) OVER (ORDER BY Month) AS PreviousMonthSales\nFROM MonthlySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sales for the current month and the next month.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Month, \n  MonthlySales, \n  LEAD(MonthlySales, 1, 0) OVER (ORDER BY Month) AS NextMonthSales\nFROM MonthlySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCompare each employee's salary to the average salary of all employees.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  AVG(Salary) OVER () AS CompanyAvgSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a running total of the 'Quantity' of items sold, ordered by 'ProductID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductID, \n  Quantity, \n  SUM(Quantity) OVER (ORDER BY ProductID) AS RunningQuantityTotal\nFROM OrderItems;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a running total of 'Salary' for each department, ordered by 'HireDate'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  Salary, \n  SUM(Salary) OVER (PARTITION BY Department ORDER BY HireDate) AS DeptRunningSalaryTotal\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total count of all orders on every single order row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  COUNT(*) OVER () AS TotalOrderCount\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total number of orders for each customer, displayed on each of their order rows.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  CustomerID, \n  OrderDate, \n  COUNT(*) OVER (PARTITION BY CustomerID) AS CustomerTotalOrders\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the most expensive product in the entire store and show it on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  MAX(Price) OVER () AS MaxStorePrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the cheapest product in the entire store and show it on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  MIN(Price) OVER () AS MinStorePrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total 'Stock' for each 'Category', displayed on each product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Stock, \n  SUM(Stock) OVER (PARTITION BY Category) AS TotalCategoryStock\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the second-highest salary in the company? Use DENSE_RANK.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH Ranked AS (\n  SELECT \n    Salary, \n    DENSE_RANK() OVER (ORDER BY Salary DESC) AS RankNum\n  FROM Employees\n)\nSELECT Salary\nFROM Ranked\nWHERE RankNum = 2\nLIMIT 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 5th most recently hired employee.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH Ranked AS (\n  SELECT \n    Name, \n    HireDate, \n    ROW_NUMBER() OVER (ORDER BY HireDate DESC) AS RowNum\n  FROM Employees\n)\nSELECT Name, HireDate\nFROM Ranked\nWHERE RowNum = 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the name of the first employee hired in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  FIRST_VALUE(Name) OVER (PARTITION BY Department ORDER BY HireDate ASC) AS FirstHiredInDept\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the name of the most recent employee hired in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  LAST_VALUE(Name) OVER (\n    PARTITION BY Department \n    ORDER BY HireDate ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS LastHiredInDept\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide all products into 3 'Tiers' based on price.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  NTILE(3) OVER (ORDER BY Price DESC) AS PriceTier\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide employees into 2 groups (halves) per department based on salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  NTILE(2) OVER (PARTITION BY Department ORDER BY Salary DESC) AS SalaryHalf\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the price of each product compared to the average price of all products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  AVG(Price) OVER () AS AveragePrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the total number of products in each category, shown on every product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  COUNT(*) OVER (PARTITION BY Category) AS ProductsInCategory\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow a running total of product stock, ordered by ProductID.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductID, \n  ProductName, \n  Stock, \n  SUM(Stock) OVER (ORDER BY ProductID) AS RunningStockTotal\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary in descending order.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS Rank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUse DENSE_RANK() to rank products by price, cheapest first.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  DENSE_RANK() OVER (ORDER BY Price ASC) AS PriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a unique number to each customer, ordered by 'CustomerName'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerName, \n  ROW_NUMBER() OVER (ORDER BY CustomerName) AS CustomerNumber\nFROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each day's sales and the sales from the day before.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  LAG(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS PreviousDaySales\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each day's sales and the sales for the next day.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  LEAD(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS NextDaySales\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total salary for the 'Sales' department on every 'Sales' employee's row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  SUM(Salary) OVER (PARTITION BY Department) AS DepartmentTotalSalary\nFROM Employees\nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a cumulative sum of all 'Order' amounts, ordered by 'OrderID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  TotalAmount, \n  SUM(TotalAmount) OVER (ORDER BY OrderID) AS CumulativeTotal\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the highest salary in the company and show it on every employee row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  MAX(Salary) OVER () AS MaxSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the lowest price in the 'Electronics' category and show it on every 'Electronics' product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  MIN(Price) OVER (PARTITION BY Category) AS MinCategoryPrice\nFROM Products\nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total count of products on every product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  COUNT(*) OVER () AS TotalProductCount\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the first employee hired in the whole company.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  FIRST_VALUE(Name) OVER (ORDER BY HireDate ASC) AS FirstEmployee\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the last employee hired in the whole company.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  LAST_VALUE(Name) OVER (ORDER BY HireDate ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS LastEmployee\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide all employees into 100 'percentile' groups.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  NTILE(100) OVER (ORDER BY Salary) AS PercentileGroup\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the second-most expensive product in each category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH Ranked AS (\n  SELECT \n    ProductName, \n    Category, \n    Price, \n    DENSE_RANK() OVER (PARTITION BY Category ORDER BY Price DESC) AS RankNum\n  FROM Products\n)\nSELECT ProductName, Category, Price\nFROM Ranked\nWHERE RankNum = 2;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I combine the list of employees from 'Employees_East' and 'Employees_West' into one list?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID, Name FROM Employees_East\nUNION\nSELECT EmpID, Name FROM Employees_West;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me a combined list of all 'Pending' orders and all 'Processing' orders from the 'Orders' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT OrderID, CustomerID, OrderDate FROM Orders WHERE Status = 'Pending'\nUNION\nSELECT OrderID, CustomerID, OrderDate FROM Orders WHERE Status = 'Processing';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nI have two tables, 'Products_A' and 'Products_B'. How do I get a single list of all unique product names from both?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName FROM Products_A\nUNION\nSELECT ProductName FROM Products_B;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine the email addresses from the 'Customers' table and the 'Suppliers' table into one list.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Email FROM Customers\nUNION\nSELECT Email FROM Suppliers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat's the difference between UNION and UNION ALL?\n<end_of_turn>\n<start_of_turn>model\n`UNION` removes duplicate rows from the combined result set. `UNION ALL` includes all rows, including duplicates, and is faster.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I combine 'Employees_East' and 'Employees_West', including all duplicates? Use UNION ALL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID, Name FROM Employees_East\nUNION ALL\nSELECT EmpID, Name FROM Employees_West;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me a combined list of all 'Pending' and 'Processing' orders, including duplicates if any exist.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT OrderID, CustomerID, OrderDate FROM Orders WHERE Status = 'Pending'\nUNION ALL\nSELECT OrderID, CustomerID, OrderDate FROM Orders WHERE Status = 'Processing';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine the email addresses from 'Customers' and 'Suppliers', keeping all entries.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Email FROM Customers\nUNION ALL\nSELECT Email FROM Suppliers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a full list of all product names from 'Products_A' and 'Products_B', including all duplicates.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName FROM Products_A\nUNION ALL\nSELECT ProductName FROM Products_B;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine the 'ActiveCustomers' and 'InactiveCustomers' tables into one list with all records.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID, CustomerName FROM ActiveCustomers\nUNION ALL\nSELECT CustomerID, CustomerName FROM InactiveCustomers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find employees who work in *both* the 'Sales' department and the 'Marketing' department? (Assuming a junction table 'EmployeeDepartments').\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID FROM EmployeeDepartments WHERE DeptName = 'Sales'\nINTERSECT\nSELECT EmpID FROM EmployeeDepartments WHERE DeptName = 'Marketing';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all customers who are in *both* the 'TopSpenders' table and the 'FrequentBuyers' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID, CustomerName FROM TopSpenders\nINTERSECT\nSELECT CustomerID, CustomerName FROM FrequentBuyers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the 'ProductIDs' that are present in *both* 'WarehouseA' and 'WarehouseB' inventory.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM WarehouseA\nINTERSECT\nSELECT ProductID FROM WarehouseB;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhich students are enrolled in *both* 'History 101' and 'Math 101'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT StudentID FROM StudentEnrollment WHERE Course = 'History 101'\nINTERSECT\nSELECT StudentID FROM StudentEnrollment WHERE Course = 'Math 101';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 'City' names that exist in *both* the 'Customers' table and the 'Suppliers' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT City FROM Customers\nINTERSECT\nSELECT City FROM Suppliers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find employees who are in the 'Employees_East' table but *not* in the 'OnVacation' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID, Name FROM Employees_East\nEXCEPT\nSELECT EmpID, Name FROM OnVacation;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all customers who have *not* placed an order. (Tables: Customers, Orders)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID FROM Customers\nEXCEPT\nSELECT CustomerID FROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that are in 'WarehouseA' but *not* in 'WarehouseB'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM WarehouseA\nEXCEPT\nSELECT ProductID FROM WarehouseB;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhich students are enrolled in 'History 101' but *not* in 'Math 101'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT StudentID FROM StudentEnrollment WHERE Course = 'History 101'\nEXCEPT\nSELECT StudentID FROM StudentEnrollment WHERE Course = 'Math 101';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that have *never* been sold. (Tables: Products, OrderItems)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM Products\nEXCEPT\nSELECT ProductID FROM OrderItems;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the 'MINUS' operator in SQL?\n<end_of_turn>\n<start_of_turn>model\n`MINUS` is an operator used in some SQL dialects (like Oracle) that is identical to `EXCEPT`. It returns all unique rows from the first query that are not in the second query.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me an example of MINUS. (Oracle syntax)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Oracle SQL syntax\nSELECT ProductID FROM WarehouseA\nMINUS\nSELECT ProductID FROM WarehouseB;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCan I use UNION with an ORDER BY clause?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Yes, you add a single ORDER BY at the very end of the entire statement.\n(SELECT Name, HireDate FROM Employees_East)\nUNION\n(SELECT Name, HireDate FROM Employees_West)\nORDER BY HireDate DESC;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me how to use UNION ALL and then order the combined result.\n<end_of_turn>\n<start_of_turn>model\n```sql\n(SELECT ProductName, Price FROM Products_A)\nUNION ALL\n(SELECT ProductName, Price FROM Products_B)\nORDER BY ProductName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCan I use UNION if the columns have different names?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Yes, as long as the data types are compatible. The first query's column names will be used.\nSELECT EmpID, FullName FROM Employees\nUNION\nSELECT CustomerID, CustomerName FROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWill this UNION work if the number of columns is different?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- No, this query will fail. \n-- SELECT Name, Department FROM Employees\n-- UNION\n-- SELECT ProductName FROM Products;\n-- Both queries in a UNION must have the same number of columns.\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I fix a UNION query where one table has an extra column?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Add a NULL placeholder for the missing column.\nSELECT Name, Department FROM Employees\nUNION\nSELECT ProductName, NULL FROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine a list of employee names and customer names into a single list with a 'Type' label.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, 'Employee' AS Type FROM Employees\nUNION ALL\nSELECT CustomerName, 'Customer' AS Type FROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all cities where we have either a customer or a supplier.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT City FROM Customers\nUNION\nSELECT City FROM Suppliers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all cities where we have both a customer and a supplier.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT City FROM Customers\nINTERSECT\nSELECT City FROM Suppliers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all cities where we have a customer, but no supplier.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT City FROM Customers\nEXCEPT\nSELECT City FROM Suppliers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all cities where we have a supplier, but no customer.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT City FROM Suppliers\nEXCEPT\nSELECT City FROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine the 'ID' and 'Name' from 'Table1' and 'Table2'. Remove duplicates.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ID, Name FROM Table1\nUNION\nSELECT ID, Name FROM Table2;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine 'ID' and 'Name' from 'Table1' and 'Table2'. Keep all duplicates.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ID, Name FROM Table1\nUNION ALL\nSELECT ID, Name FROM Table2;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the common 'ID' and 'Name' pairs that are in both 'Table1' and 'Table2'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ID, Name FROM Table1\nINTERSECT\nSELECT ID, Name FROM Table2;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 'ID' and 'Name' pairs that are in 'Table1' but not in 'Table2'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ID, Name FROM Table1\nEXCEPT\nSELECT ID, Name FROM Table2;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 'ID' and 'Name' pairs that are in 'Table2' but not in 'Table1'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ID, Name FROM Table2\nEXCEPT\nSELECT ID, Name FROM Table1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a unique list of all 'ProductIDs' from 'Sales_2024' and 'Sales_2025'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM Sales_2024\nUNION\nSELECT ProductID FROM Sales_2025;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a complete list of all 'ProductIDs' sold in 'Sales_2024' and 'Sales_2025', with duplicates.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM Sales_2024\nUNION ALL\nSELECT ProductID FROM Sales_2025;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 'ProductIDs' that were sold in *both* 2024 and 2025.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM Sales_2024\nINTERSECT\nSELECT ProductID FROM Sales_2025;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 'ProductIDs' that were sold in 2024 but *not* in 2025.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM Sales_2024\nEXCEPT\nSELECT ProductID FROM Sales_2025;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 'ProductIDs' that were sold in 2025 but *not* in 2024.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM Sales_2025\nEXCEPT\nSELECT ProductID FROM Sales_2024;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCan I use UNION to combine a 'VARCHAR' column and an 'INT' column?\n<end_of_turn>\n<start_of_turn>model\nNo, `UNION` requires that the data types in each corresponding column be compatible. You would need to explicitly `CAST` the INT column to VARCHAR.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me how to fix a UNION between a VARCHAR and an INT column. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName FROM Products\nUNION\nSELECT CAST(EmpID AS VARCHAR) FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I combine a list of active employees and a list of retired employees?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID, Name, Status FROM ActiveEmployees\nUNION ALL\nSELECT EmpID, Name, Status FROM RetiredEmployees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'UserIDs' that are in 'TableA' or 'TableB' (unique list).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT UserID FROM TableA\nUNION\nSELECT UserID FROM TableB;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'UserIDs' that are in 'TableA' or 'TableB' (full list with duplicates).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT UserID FROM TableA\nUNION ALL\nSELECT UserID FROM TableB;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'UserIDs' that are in both 'TableA' and 'TableB'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT UserID FROM TableA\nINTERSECT\nSELECT UserID FROM TableB;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'UserIDs' that are in 'TableA' but not 'TableB'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT UserID FROM TableA\nEXCEPT\nSELECT UserID FROM TableB;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'UserIDs' that are in 'TableB' but not 'TableA'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT UserID FROM TableB\nEXCEPT\nSELECT UserID FROM TableA;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine a list of employee names and manager names into one unique list.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name FROM Employees\nUNION\nSELECT ManagerName FROM Managers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine employee names and manager names, keeping all entries.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name FROM Employees\nUNION ALL\nSELECT ManagerName FROM Managers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind names that are on both the 'Employee' list and the 'Manager' list.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name FROM Employees\nINTERSECT\nSELECT ManagerName FROM Managers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind names that are on the 'Employee' list but not on the 'Manager' list.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name FROM Employees\nEXCEPT\nSELECT ManagerName FROM Managers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind names that are on the 'Manager' list but not on the 'Employee' list.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ManagerName FROM Managers\nEXCEPT\nSELECT Name FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a unique list of all 'CustomerIDs' from 'Orders_2024' and 'Orders_2025'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID FROM Orders_2024\nUNION\nSELECT CustomerID FROM Orders_2025;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a full list of all 'CustomerIDs' from 'Orders_2024' and 'Orders_2025', including duplicates.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID FROM Orders_2024\nUNION ALL\nSELECT CustomerID FROM Orders_2025;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhich 'CustomerIDs' placed orders in *both* 2024 and 2025?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID FROM Orders_2024\nINTERSECT\nSELECT CustomerID FROM Orders_2025;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhich 'CustomerIDs' placed an order in 2024 but *not* in 2025?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID FROM Orders_2024\nEXCEPT\nSELECT CustomerID FROM Orders_2025;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhich 'CustomerIDs' placed an order in 2025 but *not* in 2024?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerID FROM Orders_2025\nEXCEPT\nSELECT CustomerID FROM Orders_2024;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine 'ProductID', 'Price' from 'Products' and 'ServiceID', 'Price' from 'Services'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID, Price FROM Products\nUNION ALL\nSELECT ServiceID, Price FROM Services;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine 'TaskName' from 'HighPriorityTasks' and 'LowPriorityTasks' and sort them alphabetically.\n<end_of_turn>\n<start_of_turn>model\n```sql\n(SELECT TaskName FROM HighPriorityTasks)\nUNION\n(SELECT TaskName FROM LowPriorityTasks)\nORDER BY TaskName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a unique list of all cities from 'Customers', 'Employees', and 'Suppliers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT City FROM Customers\nUNION\nSELECT City FROM Employees\nUNION\nSELECT City FROM Suppliers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a full list (with duplicates) of all cities from 'Customers', 'Employees', and 'Suppliers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT City FROM Customers\nUNION ALL\nSELECT City FROM Employees\nUNION ALL\nSELECT City FROM Suppliers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind cities that are common to 'Customers', 'Employees', and 'Suppliers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT City FROM Customers\nINTERSECT\nSELECT City FROM Employees\nINTERSECT\nSELECT City FROM Suppliers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind employees who are in 'Employees' but not in 'Managers' or 'Admins'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT EmpID FROM Employees\nEXCEPT\nSELECT ManagerID FROM Managers\nEXCEPT\nSELECT AdminID FROM Admins;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'PhoneNumbers' from 'Customers' and 'Employees'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT PhoneNumber FROM Customers\nUNION\nSELECT PhoneNumber FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all 'PhoneNumbers' from 'Customers' and 'Employees', with duplicates.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT PhoneNumber FROM Customers\nUNION ALL\nSELECT PhoneNumber FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'PhoneNumbers' that are in both the 'Customers' and 'Employees' tables.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT PhoneNumber FROM Customers\nINTERSECT\nSELECT PhoneNumber FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'PhoneNumbers' that are in 'Customers' but not in 'Employees'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT PhoneNumber FROM Customers\nEXCEPT\nSELECT PhoneNumber FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'PhoneNumbers' that are in 'Employees' but not in 'Customers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT PhoneNumber FROM Employees\nEXCEPT\nSELECT PhoneNumber FROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine a list of 'ProductIDs' from 'Sales' and 'Returns'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM Sales\nUNION\nSELECT ProductID FROM Returns;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine 'ProductIDs' from 'Sales' and 'Returns', keeping duplicates.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM Sales\nUNION ALL\nSELECT ProductID FROM Returns;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'ProductIDs' that were sold and also returned.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM Sales\nINTERSECT\nSELECT ProductID FROM Returns;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'ProductIDs' that were sold but never returned.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM Sales\nEXCEPT\nSELECT ProductID FROM Returns;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'ProductIDs' that were returned but never sold (e.g., fraud or error).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductID FROM Returns\nEXCEPT\nSELECT ProductID FROM Sales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine 'EmployeeNames' from 'FullTime' and 'PartTime' tables.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name FROM FullTime\nUNION\nSELECT Name FROM PartTime;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine 'EmployeeNames' from 'FullTime' and 'PartTime' tables, keeping all records.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name FROM FullTime\nUNION ALL\nSELECT Name FROM PartTime;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind names of people who are in both the 'FullTime' and 'PartTime' tables (e.g., error).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name FROM FullTime\nINTERSECT\nSELECT Name FROM PartTime;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind names of people who are in 'FullTime' but not 'PartTime'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name FROM FullTime\nEXCEPT\nSELECT Name FROM PartTime;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind names of people who are in 'PartTime' but not 'FullTime'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name FROM PartTime\nEXCEPT\nSELECT Name FROM FullTime;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a unique list of 'ProjectIDs' from 'ActiveProjects' and 'CompletedProjects'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProjectID FROM ActiveProjects\nUNION\nSELECT ProjectID FROM CompletedProjects;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a full list of 'ProjectIDs' from 'ActiveProjects' and 'CompletedProjects' (with duplicates).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProjectID FROM ActiveProjects\nUNION ALL\nSELECT ProjectID FROM CompletedProjects;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'ProjectIDs' that are in *both* 'ActiveProjects' and 'CompletedProjects' (e.g., error).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProjectID FROM ActiveProjects\nINTERSECT\nSELECT ProjectID FROM CompletedProjects;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'ProjectIDs' that are in 'ActiveProjects' but not 'CompletedProjects'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProjectID FROM ActiveProjects\nEXCEPT\nSELECT ProjectID FROM CompletedProjects;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'ProjectIDs' that are in 'CompletedProjects' but not 'ActiveProjects'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProjectID FROM CompletedProjects\nEXCEPT\nSELECT ProjectID FROM ActiveProjects;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine 'Emails' from 'NewsletterSubscribers' and 'RegisteredUsers' into a unique list.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Email FROM NewsletterSubscribers\nUNION\nSELECT Email FROM RegisteredUsers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCombine 'Emails' from 'NewsletterSubscribers' and 'RegisteredUsers', keeping all.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Email FROM NewsletterSubscribers\nUNION ALL\nSELECT Email FROM RegisteredUsers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'Emails' that are on both the 'NewsletterSubscribers' and 'RegisteredUsers' lists.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Email FROM NewsletterSubscribers\nINTERSECT\nSELECT Email FROM RegisteredUsers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'Emails' that are in 'RegisteredUsers' but not 'NewsletterSubscribers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Email FROM RegisteredUsers\nEXCEPT\nSELECT Email FROM NewsletterSubscribers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind 'Emails' that are in 'NewsletterSubscribers' but not 'RegisteredUsers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Email FROM NewsletterSubscribers\nEXCEPT\nSELECT Email FROM RegisteredUsers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I rank all employees by their salary, from highest to lowest?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the rank of products by price, from most expensive to least expensive.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  RANK() OVER (ORDER BY Price DESC) AS PriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I rank employees by salary *within* each department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  RANK() OVER (PARTITION BY Department ORDER BY Salary DESC) AS DeptSalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the rank of products by price, partitioned by their category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  RANK() OVER (PARTITION BY Category ORDER BY Price DESC) AS CategoryPriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get the rank of customers by their 'JoinDate'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerName, \n  JoinDate, \n  RANK() OVER (ORDER BY JoinDate ASC) AS JoinRank\nFROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the rank of orders by their total amount, highest first.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  TotalAmount, \n  RANK() OVER (ORDER BY TotalAmount DESC) AS OrderRank\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank students by their 'Grade', partitioned by 'Course'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  StudentName, \n  Course, \n  Grade, \n  RANK() OVER (PARTITION BY Course ORDER BY Grade ASC) AS GradeRank\nFROM StudentGrades;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between RANK() and DENSE_RANK()?\n<end_of_turn>\n<start_of_turn>model\n`RANK()` skips ranks after a tie (e.g., 1, 2, 2, 4), while `DENSE_RANK()` does not skip ranks (e.g., 1, 2, 2, 3).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me an example of DENSE_RANK() for employee salaries.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  DENSE_RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUse DENSE_RANK() to rank products by price within each category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  DENSE_RANK() OVER (PARTITION BY Category ORDER BY Price DESC) AS CategoryPriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the top 3 highest salaries per department using DENSE_RANK()?\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH RankedSalaries AS (\n  SELECT \n    Name, \n    Department, \n    Salary, \n    DENSE_RANK() OVER (PARTITION BY Department ORDER BY Salary DESC) AS RankNum\n  FROM Employees\n)\nSELECT Name, Department, Salary, RankNum\nFROM RankedSalaries\nWHERE RankNum <= 3;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by their hire date, oldest first, using DENSE_RANK().\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  DENSE_RANK() OVER (ORDER BY HireDate ASC) AS HireRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a unique, sequential number to each employee, ordered by name.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  ROW_NUMBER() OVER (ORDER BY Name ASC) AS RowNum\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I use ROW_NUMBER() to get the 10th-20th most expensive products (pagination)?\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH NumberedProducts AS (\n  SELECT \n    ProductName, \n    Price, \n    ROW_NUMBER() OVER (ORDER BY Price DESC) AS RowNum\n  FROM Products\n)\nSELECT ProductName, Price\nFROM NumberedProducts\nWHERE RowNum BETWEEN 10 AND 20;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I assign a row number to each employee *within* their department, ordered by salary?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  ROW_NUMBER() OVER (PARTITION BY Department ORDER BY Salary DESC) AS RowNum\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow can I find and delete duplicate employees based on 'Email'?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (T-SQL / PostgreSQL Syntax)\nWITH Duplicates AS (\n  SELECT \n    EmpID, \n    ROW_NUMBER() OVER (PARTITION BY Email ORDER BY EmpID) AS RowNum\n  FROM Employees\n)\nDELETE FROM Duplicates\nWHERE RowNum > 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a simple row number to all customers, ordered by CustomerID.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerName, \n  ROW_NUMBER() OVER (ORDER BY CustomerID) AS RowNum\nFROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the single most recent order for each customer.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH NumberedOrders AS (\n  SELECT \n    OrderID, \n    CustomerID, \n    OrderDate, \n    ROW_NUMBER() OVER (PARTITION BY CustomerID ORDER BY OrderDate DESC) AS RowNum\n  FROM Orders\n)\nSELECT OrderID, CustomerID, OrderDate\nFROM NumberedOrders\nWHERE RowNum = 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show each employee's salary and the salary of the employee hired just *before* them?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LAG(Salary, 1) OVER (ORDER BY HireDate) AS PreviousSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's salary and the salary of the employee hired just *after* them.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LEAD(Salary, 1) OVER (ORDER BY HireDate) AS NextSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get each employee's salary and the salary of the previous employee *within the same department*?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  LAG(Salary, 1) OVER (PARTITION BY Department ORDER BY Salary) AS PrevDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the 'Next' employee's name for each employee when ordered alphabetically.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  LEAD(Name) OVER (ORDER BY Name) AS NextEmployeeName\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the difference in salary between an employee and the person hired just before them?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  Salary - LAG(Salary, 1, Salary) OVER (ORDER BY HireDate) AS SalaryDiff\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the current order's amount and the previous order's amount (based on date).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  TotalAmount, \n  LAG(TotalAmount) OVER (ORDER BY OrderDate) AS PreviousOrderAmount\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the current product's price and the next most expensive product's price.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  LEAD(Price) OVER (ORDER BY Price) AS NextPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCompare each day's sales to the sales from 7 days prior.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  LAG(DailySales, 7) OVER (ORDER BY SaleDate) AS Sales7DaysAgo\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the time difference between a customer's current order and their previous order.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (PostgreSQL)\nSELECT \n  CustomerID, \n  OrderDate, \n  OrderDate - LAG(OrderDate) OVER (PARTITION BY CustomerID ORDER BY OrderDate) AS TimeSinceLastOrder\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show each employee's salary and the average salary of their department on the same row?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  AVG(Salary) OVER (PARTITION BY Department) AS DeptAverageSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sum of all salaries, but as a new column on every employee row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  SUM(Salary) OVER () AS TotalCompanySalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get a running total of all sales, ordered by date?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  TotalAmount, \n  SUM(TotalAmount) OVER (ORDER BY OrderDate) AS RunningTotal\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me a running total of sales *for each customer*.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerID, \n  OrderID, \n  OrderDate, \n  TotalAmount, \n  SUM(TotalAmount) OVER (PARTITION BY CustomerID ORDER BY OrderDate) AS CustomerRunningTotal\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the total number of employees in each department, but show it on every employee row?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  COUNT(*) OVER (PARTITION BY Department) AS DeptEmployeeCount\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total number of all employees in the company on every single row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  COUNT(*) OVER () AS TotalEmployees\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the highest salary in each department and show it on each employee's row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  MAX(Salary) OVER (PARTITION BY Department) AS HighestDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the lowest price in each product category, but show it next to each product.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  MIN(Price) OVER (PARTITION BY Category) AS LowestCategoryPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's salary as a percentage of their department's total salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  Salary * 100.0 / SUM(Salary) OVER (PARTITION BY Department) AS PctOfDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each product's price as a percentage of the total price of all products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  Price * 100.0 / SUM(Price) OVER () AS PctOfTotalPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get a 3-day moving average of sales?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  AVG(DailySales) OVER (\n    ORDER BY SaleDate \n    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n  ) AS '3DayMovingAvg'\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the total sales in a 7-day window (3 days before, current day, 3 days after).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  SUM(DailySales) OVER (\n    ORDER BY SaleDate \n    ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING\n  ) AS '7DayWindowTotal'\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the first value in an ordered set. (e.g., the name of the first person hired).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  FIRST_VALUE(Name) OVER (ORDER BY HireDate ASC) AS FirstHired\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the name of the highest-paid employee on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  FIRST_VALUE(Name) OVER (ORDER BY Salary DESC) AS HighestEarner\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the name of the lowest-paid employee in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  FIRST_VALUE(Name) OVER (PARTITION BY Department ORDER BY Salary ASC) AS LowestEarnerInDept\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the name of the last person hired in the company on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  LAST_VALUE(Name) OVER (\n    ORDER BY HireDate ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS LastHired\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the name of the most expensive product on every product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  LAST_VALUE(ProductName) OVER (\n    ORDER BY Price ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS MostExpensive\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the most expensive product *in each category* on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  LAST_VALUE(ProductName) OVER (\n    PARTITION BY Category \n    ORDER BY Price ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS MostExpensiveInCategory\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I divide employees into 4 equal groups (quartiles) based on salary?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  NTILE(4) OVER (ORDER BY Salary DESC) AS SalaryQuartile\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide students into 10 groups (deciles) based on their grade.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  StudentName, \n  Grade, \n  NTILE(10) OVER (ORDER BY Grade DESC) AS GradeDecile\nFROM StudentGrades;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I split products into 5 groups (quintiles) within each category?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  NTILE(5) OVER (PARTITION BY Category ORDER BY Price DESC) AS PriceQuintile\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the percentile rank for each employee's salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (PostgreSQL / SQL Server syntax)\nSELECT \n  Name, \n  Salary, \n  PERCENT_RANK() OVER (ORDER BY Salary) AS SalaryPercentile\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the cumulative distribution of product prices.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (PostgreSQL / SQL Server syntax)\nSELECT \n  ProductName, \n  Price, \n  CUME_DIST() OVER (ORDER BY Price) AS CumulativeDistribution\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary. If there's a tie, give them the same rank and skip the next number.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary. If there's a tie, give them the same rank but do not skip the next number.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  DENSE_RANK() OVER (ORDER BY Salary DESC) AS SalaryDenseRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGive me a unique number for each row in the 'Orders' table, starting from 1, based on 'OrderDate'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  ROW_NUMBER() OVER (ORDER BY OrderDate) AS OrderNum\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the salary of the person hired just before, using a default of 0 if it's the first person.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LAG(Salary, 1, 0) OVER (ORDER BY HireDate) AS PreviousSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the salary of the person hired two positions *after* the current employee.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LEAD(Salary, 2) OVER (ORDER BY HireDate) AS NextNextSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sales for the current, previous, and next day all on one row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales AS CurrentSales,\n  LAG(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS PreviousSales,\n  LEAD(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS NextSales\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the average company salary on every employee row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  AVG(Salary) OVER () AS CompanyAverage\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total quantity sold for each product, on every 'OrderItems' row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  ProductID, \n  Quantity, \n  SUM(Quantity) OVER (PARTITION BY ProductID) AS TotalSoldForProduct\nFROM OrderItems;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow a cumulative sum of employee salaries, ordered by employee ID.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  EmpID, \n  Name, \n  Salary, \n  SUM(Salary) OVER (ORDER BY EmpID) AS RunningTotalSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow a cumulative count of employees hired, ordered by hire date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  COUNT(*) OVER (ORDER BY HireDate) AS CumulativeHires\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the highest salary in the whole company and display it on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  MAX(Salary) OVER () AS MaxCompanySalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the lowest salary in each department, but show it on every employee's row for that department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  MIN(Salary) OVER (PARTITION BY Department) AS MinDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the price of each product and the price of the most expensive product in its category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  MAX(Price) OVER (PARTITION BY Category) AS MaxCategoryPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary, but do not partition by department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS OverallRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a row number to all products, ordered by price from cheapest to most expensive.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  ROW_NUMBER() OVER (ORDER BY Price ASC) AS PriceRowNumber\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign row numbers to orders, restarting the count for each customer, ordered by date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerID, \n  OrderID, \n  OrderDate, \n  ROW_NUMBER() OVER (PARTITION BY CustomerID ORDER BY OrderDate) AS CustomerOrderNumber\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the salary of the employee hired immediately before the current one, in the same department, ordered by name.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  LAG(Salary) OVER (PARTITION BY Department ORDER BY Name) AS PreviousEmpSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 'HireDate' of the employee hired immediately after the current one, in the same department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  LEAD(HireDate) OVER (PARTITION BY Department ORDER BY HireDate) AS NextHireDate\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sales for the current month and the previous month.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Month, \n  MonthlySales, \n  LAG(MonthlySales, 1, 0) OVER (ORDER BY Month) AS PreviousMonthSales\nFROM MonthlySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sales for the current month and the next month.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Month, \n  MonthlySales, \n  LEAD(MonthlySales, 1, 0) OVER (ORDER BY Month) AS NextMonthSales\nFROM MonthlySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCompare each employee's salary to the average salary of all employees.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  AVG(Salary) OVER () AS CompanyAvgSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a running total of the 'Quantity' of items sold, ordered by 'ProductID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductID, \n  Quantity, \n  SUM(Quantity) OVER (ORDER BY ProductID) AS RunningQuantityTotal\nFROM OrderItems;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a running total of 'Salary' for each department, ordered by 'HireDate'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  Salary, \n  SUM(Salary) OVER (PARTITION BY Department ORDER BY HireDate) AS DeptRunningSalaryTotal\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total count of all orders on every single order row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  COUNT(*) OVER () AS TotalOrderCount\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total number of orders for each customer, displayed on each of their order rows.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  CustomerID, \n  OrderDate, \n  COUNT(*) OVER (PARTITION BY CustomerID) AS CustomerTotalOrders\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the most expensive product in the entire store and show it on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  MAX(Price) OVER () AS MaxStorePrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the cheapest product in the entire store and show it on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  MIN(Price) OVER () AS MinStorePrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total 'Stock' for each 'Category', displayed on each product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Stock, \n  SUM(Stock) OVER (PARTITION BY Category) AS TotalCategoryStock\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the second-highest salary in the company? Use DENSE_RANK.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH Ranked AS (\n  SELECT \n    Salary, \n    DENSE_RANK() OVER (ORDER BY Salary DESC) AS RankNum\n  FROM Employees\n)\nSELECT Salary\nFROM Ranked\nWHERE RankNum = 2\nLIMIT 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 5th most recently hired employee.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH Ranked AS (\n  SELECT \n    Name, \n    HireDate, \n    ROW_NUMBER() OVER (ORDER BY HireDate DESC) AS RowNum\n  FROM Employees\n)\nSELECT Name, HireDate\nFROM Ranked\nWHERE RowNum = 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the name of the first employee hired in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  FIRST_VALUE(Name) OVER (PARTITION BY Department ORDER BY HireDate ASC) AS FirstHiredInDept\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the name of the most recent employee hired in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  LAST_VALUE(Name) OVER (\n    PARTITION BY Department \n    ORDER BY HireDate ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS LastHiredInDept\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide all products into 3 'Tiers' based on price.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  NTILE(3) OVER (ORDER BY Price DESC) AS PriceTier\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide employees into 2 groups (halves) per department based on salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  NTILE(2) OVER (PARTITION BY Department ORDER BY Salary DESC) AS SalaryHalf\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the price of each product compared to the average price of all products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  AVG(Price) OVER () AS AveragePrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the total number of products in each category, shown on every product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  COUNT(*) OVER (PARTITION BY Category) AS ProductsInCategory\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow a running total of product stock, ordered by ProductID.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductID, \n  ProductName, \n  Stock, \n  SUM(Stock) OVER (ORDER BY ProductID) AS RunningStockTotal\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary in descending order.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS Rank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUse DENSE_RANK() to rank products by price, cheapest first.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  DENSE_RANK() OVER (ORDER BY Price ASC) AS PriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a unique number to each customer, ordered by 'CustomerName'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerName, \n  ROW_NUMBER() OVER (ORDER BY CustomerName) AS CustomerNumber\nFROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each day's sales and the sales from the day before.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  LAG(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS PreviousDaySales\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each day's sales and the sales for the next day.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  LEAD(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS NextDaySales\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total salary for the 'Sales' department on every 'Sales' employee's row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  SUM(Salary) OVER (PARTITION BY Department) AS DepartmentTotalSalary\nFROM Employees\nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a cumulative sum of all 'Order' amounts, ordered by 'OrderID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  TotalAmount, \n  SUM(TotalAmount) OVER (ORDER BY OrderID) AS CumulativeTotal\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the highest salary in the company and show it on every employee row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  MAX(Salary) OVER () AS MaxSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the lowest price in the 'Electronics' category and show it on every 'Electronics' product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  MIN(Price) OVER (PARTITION BY Category) AS MinCategoryPrice\nFROM Products\nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total count of products on every product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  COUNT(*) OVER () AS TotalProductCount\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the first employee hired in the whole company.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  FIRST_VALUE(Name) OVER (ORDER BY HireDate ASC) AS FirstEmployee\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the last employee hired in the whole company.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  LAST_VALUE(Name) OVER (ORDER BY HireDate ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS LastEmployee\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide all employees into 100 'percentile' groups.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  NTILE(100) OVER (ORDER BY Salary) AS PercentileGroup\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the second-most expensive product in each category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH Ranked AS (\n  SELECT \n    ProductName, \n    Category, \n    Price, \n    DENSE_RANK() OVER (PARTITION BY Category ORDER BY Price DESC) AS RankNum\n  FROM Products\n)\nSELECT ProductName, Category, Price\nFROM Ranked\nWHERE RankNum = 2;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I rank all employees by their salary, from highest to lowest?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the rank of products by price, from most expensive to least expensive.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  RANK() OVER (ORDER BY Price DESC) AS PriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I rank employees by salary *within* each department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  RANK() OVER (PARTITION BY Department ORDER BY Salary DESC) AS DeptSalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the rank of products by price, partitioned by their category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  RANK() OVER (PARTITION BY Category ORDER BY Price DESC) AS CategoryPriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get the rank of customers by their 'JoinDate', oldest first?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerName, \n  JoinDate, \n  RANK() OVER (ORDER BY JoinDate ASC) AS JoinRank\nFROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the rank of orders by their total amount, highest first.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  TotalAmount, \n  RANK() OVER (ORDER BY TotalAmount DESC) AS OrderRank\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank students by their 'Grade' (assuming 100 is best), partitioned by 'Course'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  StudentName, \n  Course, \n  Grade, \n  RANK() OVER (PARTITION BY Course ORDER BY Grade DESC) AS GradeRank\nFROM StudentGrades;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between RANK() and DENSE_RANK()?\n<end_of_turn>\n<start_of_turn>model\n`RANK()` skips ranks after a tie (e.g., 1, 2, 2, 4), while `DENSE_RANK()` does not skip ranks (e.g., 1, 2, 2, 3).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me an example of DENSE_RANK() for employee salaries.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  DENSE_RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUse DENSE_RANK() to rank products by price within each category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  DENSE_RANK() OVER (PARTITION BY Category ORDER BY Price DESC) AS CategoryPriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the top 3 highest salaries per department using DENSE_RANK()?\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH RankedSalaries AS (\n  SELECT \n    Name, \n    Department, \n    Salary, \n    DENSE_RANK() OVER (PARTITION BY Department ORDER BY Salary DESC) AS RankNum\n  FROM Employees\n)\nSELECT Name, Department, Salary, RankNum\nFROM RankedSalaries\nWHERE RankNum <= 3;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by their hire date, oldest first, using DENSE_RANK().\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  DENSE_RANK() OVER (ORDER BY HireDate ASC) AS HireRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a unique, sequential number to each employee, ordered by name.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  ROW_NUMBER() OVER (ORDER BY Name ASC) AS RowNum\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I use ROW_NUMBER() to get the 10th-20th most expensive products (pagination)?\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH NumberedProducts AS (\n  SELECT \n    ProductName, \n    Price, \n    ROW_NUMBER() OVER (ORDER BY Price DESC) AS RowNum\n  FROM Products\n)\nSELECT ProductName, Price\nFROM NumberedProducts\nWHERE RowNum BETWEEN 10 AND 20;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I assign a row number to each employee *within* their department, ordered by salary?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  ROW_NUMBER() OVER (PARTITION BY Department ORDER BY Salary DESC) AS RowNum\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow can I find and delete duplicate employees based on 'Email'?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (T-SQL / PostgreSQL Syntax)\nWITH Duplicates AS (\n  SELECT \n    EmpID, \n    ROW_NUMBER() OVER (PARTITION BY Email ORDER BY EmpID) AS RowNum\n  FROM Employees\n)\nDELETE FROM Duplicates\nWHERE RowNum > 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a simple row number to all customers, ordered by CustomerID.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerName, \n  ROW_NUMBER() OVER (ORDER BY CustomerID) AS RowNum\nFROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the single most recent order for each customer.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH NumberedOrders AS (\n  SELECT \n    OrderID, \n    CustomerID, \n    OrderDate, \n    ROW_NUMBER() OVER (PARTITION BY CustomerID ORDER BY OrderDate DESC) AS RowNum\n  FROM Orders\n)\nSELECT OrderID, CustomerID, OrderDate\nFROM NumberedOrders\nWHERE RowNum = 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show each employee's salary and the salary of the employee hired just *before* them?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LAG(Salary, 1) OVER (ORDER BY HireDate) AS PreviousSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's salary and the salary of the employee hired just *after* them.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LEAD(Salary, 1) OVER (ORDER BY HireDate) AS NextSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get each employee's salary and the salary of the previous employee *within the same department*?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  LAG(Salary, 1) OVER (PARTITION BY Department ORDER BY Salary) AS PrevDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the 'Next' employee's name for each employee when ordered alphabetically.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  LEAD(Name) OVER (ORDER BY Name) AS NextEmployeeName\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the difference in salary between an employee and the person hired just before them?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  Salary - LAG(Salary, 1, Salary) OVER (ORDER BY HireDate) AS SalaryDiff\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the current order's amount and the previous order's amount (based on date).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  TotalAmount, \n  LAG(TotalAmount) OVER (ORDER BY OrderDate) AS PreviousOrderAmount\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the current product's price and the next most expensive product's price.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  LEAD(Price) OVER (ORDER BY Price) AS NextPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCompare each day's sales to the sales from 7 days prior.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  LAG(DailySales, 7) OVER (ORDER BY SaleDate) AS Sales7DaysAgo\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the time difference between a customer's current order and their previous order.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (PostgreSQL)\nSELECT \n  CustomerID, \n  OrderDate, \n  OrderDate - LAG(OrderDate) OVER (PARTITION BY CustomerID ORDER BY OrderDate) AS TimeSinceLastOrder\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show each employee's salary and the average salary of their department on the same row?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  AVG(Salary) OVER (PARTITION BY Department) AS DeptAverageSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sum of all salaries, but as a new column on every employee row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  SUM(Salary) OVER () AS TotalCompanySalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get a running total of all sales, ordered by date?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  TotalAmount, \n  SUM(TotalAmount) OVER (ORDER BY OrderDate) AS RunningTotal\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me a running total of sales *for each customer*.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerID, \n  OrderID, \n  OrderDate, \n  TotalAmount, \n  SUM(TotalAmount) OVER (PARTITION BY CustomerID ORDER BY OrderDate) AS CustomerRunningTotal\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the total number of employees in each department, but show it on every employee row?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  COUNT(*) OVER (PARTITION BY Department) AS DeptEmployeeCount\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total number of all employees in the company on every single row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  COUNT(*) OVER () AS TotalEmployees\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the highest salary in each department and show it on each employee's row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  MAX(Salary) OVER (PARTITION BY Department) AS HighestDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the lowest price in each product category, but show it next to each product.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  MIN(Price) OVER (PARTITION BY Category) AS LowestCategoryPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's salary as a percentage of their department's total salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  Salary * 100.0 / SUM(Salary) OVER (PARTITION BY Department) AS PctOfDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each product's price as a percentage of the total price of all products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  Price * 100.0 / SUM(Price) OVER () AS PctOfTotalPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get a 3-day moving average of sales?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  AVG(DailySales) OVER (\n    ORDER BY SaleDate \n    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n  ) AS '3DayMovingAvg'\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the total sales in a 7-day window (3 days before, current day, 3 days after).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  SUM(DailySales) OVER (\n    ORDER BY SaleDate \n    ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING\n  ) AS '7DayWindowTotal'\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the first value in an ordered set. (e.g., the name of the first person hired).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  FIRST_VALUE(Name) OVER (ORDER BY HireDate ASC) AS FirstHired\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the name of the highest-paid employee on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  FIRST_VALUE(Name) OVER (ORDER BY Salary DESC) AS HighestEarner\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the name of the lowest-paid employee in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  FIRST_VALUE(Name) OVER (PARTITION BY Department ORDER BY Salary ASC) AS LowestEarnerInDept\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the name of the last person hired in the company on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  LAST_VALUE(Name) OVER (\n    ORDER BY HireDate ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS LastHired\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the name of the most expensive product on every product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  LAST_VALUE(ProductName) OVER (\n    ORDER BY Price ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS MostExpensive\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the most expensive product *in each category* on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  LAST_VALUE(ProductName) OVER (\n    PARTITION BY Category \n    ORDER BY Price ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS MostExpensiveInCategory\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I divide employees into 4 equal groups (quartiles) based on salary?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  NTILE(4) OVER (ORDER BY Salary DESC) AS SalaryQuartile\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide students into 10 groups (deciles) based on their grade.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  StudentName, \n  Grade, \n  NTILE(10) OVER (ORDER BY Grade DESC) AS GradeDecile\nFROM StudentGrades;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I split products into 5 groups (quintiles) within each category?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  NTILE(5) OVER (PARTITION BY Category ORDER BY Price DESC) AS PriceQuintile\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the percentile rank for each employee's salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (PostgreSQL / SQL Server syntax)\nSELECT \n  Name, \n  Salary, \n  PERCENT_RANK() OVER (ORDER BY Salary) AS SalaryPercentile\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the cumulative distribution of product prices.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (PostgreSQL / SQL Server syntax)\nSELECT \n  ProductName, \n  Price, \n  CUME_DIST() OVER (ORDER BY Price) AS CumulativeDistribution\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary. If there's a tie, give them the same rank and skip the next number.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary. If there's a tie, give them the same rank but do not skip the next number.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  DENSE_RANK() OVER (ORDER BY Salary DESC) AS SalaryDenseRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGive me a unique number for each row in the 'Orders' table, starting from 1, based on 'OrderDate'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  ROW_NUMBER() OVER (ORDER BY OrderDate) AS OrderNum\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the salary of the person hired just before, using a default of 0 if it's the first person.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LAG(Salary, 1, 0) OVER (ORDER BY HireDate) AS PreviousSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the salary of the person hired two positions *after* the current employee.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  Salary, \n  LEAD(Salary, 2) OVER (ORDER BY HireDate) AS NextNextSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sales for the current, previous, and next day all on one row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales AS CurrentSales,\n  LAG(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS PreviousSales,\n  LEAD(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS NextSales\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the average company salary on every employee row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  AVG(Salary) OVER () AS CompanyAverage\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total quantity sold for each product, on every 'OrderItems' row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  ProductID, \n  Quantity, \n  SUM(Quantity) OVER (PARTITION BY ProductID) AS TotalSoldForProduct\nFROM OrderItems;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow a cumulative sum of employee salaries, ordered by employee ID.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  EmpID, \n  Name, \n  Salary, \n  SUM(Salary) OVER (ORDER BY EmpID) AS RunningTotalSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow a cumulative count of employees hired, ordered by hire date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  COUNT(*) OVER (ORDER BY HireDate) AS CumulativeHires\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the highest salary in the whole company and display it on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  MAX(Salary) OVER () AS MaxCompanySalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the lowest salary in each department, but show it on every employee's row for that department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  MIN(Salary) OVER (PARTITION BY Department) AS MinDeptSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the price of each product and the price of the most expensive product in its category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Price, \n  MAX(Price) OVER (PARTITION BY Category) AS MaxCategoryPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary, but do not partition by department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS OverallRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a row number to all products, ordered by price from cheapest to most expensive.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  ROW_NUMBER() OVER (ORDER BY Price ASC) AS PriceRowNumber\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign row numbers to orders, restarting the count for each customer, ordered by date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerID, \n  OrderID, \n  OrderDate, \n  ROW_NUMBER() OVER (PARTITION BY CustomerID ORDER BY OrderDate) AS CustomerOrderNumber\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the salary of the employee hired immediately before the current one, in the same department, ordered by name.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  LAG(Salary) OVER (PARTITION BY Department ORDER BY Name) AS PreviousEmpSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 'HireDate' of the employee hired immediately after the current one, in the same department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  LEAD(HireDate) OVER (PARTITION BY Department ORDER BY HireDate) AS NextHireDate\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sales for the current month and the previous month.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Month, \n  MonthlySales, \n  LAG(MonthlySales, 1, 0) OVER (ORDER BY Month) AS PreviousMonthSales\nFROM MonthlySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total sales for the current month and the next month.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Month, \n  MonthlySales, \n  LEAD(MonthlySales, 1, 0) OVER (ORDER BY Month) AS NextMonthSales\nFROM MonthlySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCompare each employee's salary to the average salary of all employees.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  AVG(Salary) OVER () AS CompanyAvgSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a running total of the 'Quantity' of items sold, ordered by 'ProductID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductID, \n  Quantity, \n  SUM(Quantity) OVER (ORDER BY ProductID) AS RunningQuantityTotal\nFROM OrderItems;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet a running total of 'Salary' for each department, ordered by 'HireDate'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  Salary, \n  SUM(Salary) OVER (PARTITION BY Department ORDER BY HireDate) AS DeptRunningSalaryTotal\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total count of all orders on every single order row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  OrderDate, \n  COUNT(*) OVER () AS TotalOrderCount\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total number of orders for each customer, displayed on each of their order rows.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  CustomerID, \n  OrderDate, \n  COUNT(*) OVER (PARTITION BY CustomerID) AS CustomerTotalOrders\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the most expensive product in the entire store and show it on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  MAX(Price) OVER () AS MaxStorePrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the cheapest product in the entire store and show it on every row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  MIN(Price) OVER () AS MinStorePrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total 'Stock' for each 'Category', displayed on each product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  Stock, \n  SUM(Stock) OVER (PARTITION BY Category) AS TotalCategoryStock\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the second-highest salary in the company? Use DENSE_RANK.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH Ranked AS (\n  SELECT \n    Salary, \n    DENSE_RANK() OVER (ORDER BY Salary DESC) AS RankNum\n  FROM Employees\n)\nSELECT Salary\nFROM Ranked\nWHERE RankNum = 2\nLIMIT 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the 5th most recently hired employee.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH Ranked AS (\n  SELECT \n    Name, \n    HireDate, \n    ROW_NUMBER() OVER (ORDER BY HireDate DESC) AS RowNum\n  FROM Employees\n)\nSELECT Name, HireDate\nFROM Ranked\nWHERE RowNum = 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the name of the first employee hired in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  FIRST_VALUE(Name) OVER (PARTITION BY Department ORDER BY HireDate ASC) AS FirstHiredInDept\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the name of the most recent employee hired in each department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  HireDate, \n  LAST_VALUE(Name) OVER (\n    PARTITION BY Department \n    ORDER BY HireDate ASC \n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS LastHiredInDept\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide all products into 3 'Tiers' based on price.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  NTILE(3) OVER (ORDER BY Price DESC) AS PriceTier\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide employees into 2 groups (halves) per department based on salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Department, \n  Salary, \n  NTILE(2) OVER (PARTITION BY Department ORDER BY Salary DESC) AS SalaryHalf\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the price of each product compared to the average price of all products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  AVG(Price) OVER () AS AveragePrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the total number of products in each category, shown on every product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Category, \n  COUNT(*) OVER (PARTITION BY Category) AS ProductsInCategory\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow a running total of product stock, ordered by ProductID.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductID, \n  ProductName, \n  Stock, \n  SUM(Stock) OVER (ORDER BY ProductID) AS RunningStockTotal\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRank employees by salary in descending order.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) AS Rank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUse DENSE_RANK() to rank products by price, cheapest first.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  DENSE_RANK() OVER (ORDER BY Price ASC) AS PriceRank\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nAssign a unique number to each customer, ordered by 'CustomerName'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  CustomerName, \n  ROW_NUMBER() OVER (ORDER BY CustomerName) AS CustomerNumber\nFROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each day's sales and the sales from the day before.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  LAG(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS PreviousDaySales\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each day's sales and the sales for the next day.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales, \n  LEAD(DailySales, 1, 0) OVER (ORDER BY SaleDate) AS NextDaySales\nFROM DailySales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total salary for the 'Sales' department on every 'Sales' employee's row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  SUM(Salary) OVER (PARTITION BY Department) AS DepartmentTotalSalary\nFROM Employees\nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a cumulative sum of all 'Order' amounts, ordered by 'OrderID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  OrderID, \n  TotalAmount, \n  SUM(TotalAmount) OVER (ORDER BY OrderID) AS CumulativeTotal\nFROM Orders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the highest salary in the company and show it on every employee row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  MAX(Salary) OVER () AS MaxSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the lowest price in the 'Electronics' category and show it on every 'Electronics' product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  MIN(Price) OVER (PARTITION BY Category) AS MinCategoryPrice\nFROM Products\nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total count of products on every product row.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  COUNT(*) OVER () AS TotalProductCount\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the first employee hired in the whole company.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  FIRST_VALUE(Name) OVER (ORDER BY HireDate ASC) AS FirstEmployee\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the last employee hired in the whole company.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate, \n  LAST_VALUE(Name) OVER (ORDER BY HireDate ASC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS LastEmployee\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDivide all employees into 100 'percentile' groups.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  NTILE(100) OVER (ORDER BY Salary) AS PercentileGroup\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the second-most expensive product in each category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH Ranked AS (\n  SELECT \n    ProductName, \n    Category, \n    Price, \n    DENSE_RANK() OVER (PARTITION BY Category ORDER BY Price DESC) AS RankNum\n  FROM Products\n)\nSELECT ProductName, Category, Price\nFROM Ranked\nWHERE RankNum = 2;\n```\n<end_of_turn>"}

{"text": "<start_of_turn>user\nHow do I find all employees who work in the 'Sales' department? (Subquery)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees\nWHERE DeptID IN (SELECT DeptID FROM Departments WHERE DeptName = 'Sales');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find all departments that have at least one employee? (EXISTS)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT DeptName\nFROM Departments d\nWHERE EXISTS (\n  SELECT 1 FROM Employees e WHERE e.DeptID = d.DeptID\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I find the department name for each employee? (Scalar Subquery)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  (SELECT d.DeptName FROM Departments d WHERE d.DeptID = e.DeptID) AS Department\nFROM Employees e;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I get the total sales for each order? (Subquery in FROM)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  o.OrderID, \n  o.OrderDate, \n  OrderTotals.Total\nFROM Orders o\nJOIN (\n  SELECT OrderID, SUM(Price * Quantity) AS Total\n  FROM OrderItems\n  GROUP BY OrderID\n) AS OrderTotals ON o.OrderID = OrderTotals.OrderID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I use a CTE to find all employees in the 'Sales' department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nWITH SalesDept AS (\n  SELECT DeptID FROM Departments WHERE DeptName = 'Sales'\n)\nSELECT e.Name\nFROM Employees e\nJOIN SalesDept sd ON e.DeptID = sd.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a simple view of all employees in the 'Engineering' department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW EngineeringEmployees AS\nSELECT EmpID, Name, Salary\nFROM Employees\nWHERE DeptID = 1; -- Assuming 1 is Engineering\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I select from the view 'EngineeringEmployees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT * FROM EngineeringEmployees\nWHERE Salary > 50000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete a view named 'EngineeringEmployees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW EngineeringEmployees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I start a transaction?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSTART TRANSACTION;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I save the changes in my current transaction?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCOMMIT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I undo the changes in my current transaction?\n<end_of_turn>\n<start_of_turn>model\n```sql\nROLLBACK;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me a basic transaction to transfer $50 from account 1 to account 2.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSTART TRANSACTION;\n\nUPDATE Accounts SET Balance = Balance - 50 WHERE AccountID = 1;\nUPDATE Accounts SET Balance = Balance + 50 WHERE AccountID = 2;\n\nCOMMIT;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a basic trigger that logs a message before a new employee is inserted? (Conceptual MySQL syntax)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Trigger syntax is highly dialect-specific.\n-- This is a conceptual MySQL/PostgreSQL example.\nCREATE TRIGGER Before_Employee_Insert\nBEFORE INSERT ON Employees\nFOR EACH ROW\nBEGIN\n  -- In a real trigger, you might log NEW.Name to another table.\n  -- This is just to show the structure.\n  SET @message = 'About to insert a new employee.';\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to prevent an employee's salary from being reduced? (Conceptual PostgreSQL syntax)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- This is a conceptual PostgreSQL example.\nCREATE FUNCTION check_salary_update()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.Salary < OLD.Salary THEN\n    RAISE EXCEPTION 'Salary cannot be reduced.';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER Protect_Salary\nBEFORE UPDATE ON Employees\nFOR EACH ROW\nEXECUTE FUNCTION check_salary_update();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger that saves a copy of the old row to an 'Audit' table after a delete? (Conceptual syntax)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- This is a conceptual example. 'OLD' refers to the row being deleted.\nCREATE TRIGGER Audit_Delete\nAFTER DELETE ON Employees\nFOR EACH ROW\nBEGIN\n  INSERT INTO Employees_Audit (EmpID, Name, Salary, Action)\n  VALUES (OLD.EmpID, OLD.Name, OLD.Salary, 'DELETE');\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show all employees and also show their rank by salary, with 1 being the highest?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  RANK() OVER (ORDER BY Salary DESC) as SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete employee with ID 101 from the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE EmpID = 101;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete the product with 'ProductID' 205 from the 'Products' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE ProductID = 205;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove the customer named 'John Smith' from the 'Customers' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Customers\nWHERE CustomerName = 'John Smith';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete order 5001 from the 'Orders' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE OrderID = 5001;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all employees from the 'Sales' department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products in the 'Apparel' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Category = 'Apparel';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove all customers from 'France'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Customers\nWHERE Country = 'France';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all orders that have a 'Cancelled' status.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE Status = 'Cancelled';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all employees with a salary less than 30000?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Salary < 30000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove all products with a price over $1000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Price > 1000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all log entries older than '2023-01-01'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Logs\nWHERE LogDate < '2023-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all employees hired on or before '2015-12-31'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE HireDate <= '2015-12-31';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products where the stock is 0.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Stock = 0;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove all employees who are *not* in the 'IT' department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Department <> 'IT';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products that are *not* in the 'Electronics' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE NOT Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all employees in 'Sales' who also have a salary under 40000?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Department = 'Sales' AND Salary < 40000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products from 'Apparel' that cost more than $50.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Category = 'Apparel' AND Price > 50;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove all employees from the 'HR' OR 'Finance' departments.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Department = 'HR' OR Department = 'Finance';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete employees from 'Sales', 'Marketing', or 'HR' using the IN operator?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Department IN ('Sales', 'Marketing', 'HR');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all orders with a status of 'Cancelled' or 'Returned'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE Status IN ('Cancelled', 'Returned');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees who are *not* in 'IT' or 'Engineering'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Department NOT IN ('IT', 'Engineering');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove all products with a price between $10 and $20.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Price BETWEEN 10 AND 20;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all orders placed in June 2024.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE OrderDate BETWEEN '2024-06-01' AND '2024-06-30';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all employees whose 'LastName' starts with 'Z'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE LastName LIKE 'Z%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products with 'Old' in the name.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE ProductName LIKE '%Old%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove all employees who do not have a manager (ManagerID is null).\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE ManagerID IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all customers who are missing an 'Email' address.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Customers\nWHERE Email IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all employees who *do* have a 'ManagerID' assigned?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE ManagerID IS NOT NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all rows from 'OrderItems' for 'OrderID' 1001.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM OrderItems\nWHERE OrderID = 1001;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete a specific item ('ProductID' 202) from 'OrderID' 1001.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM OrderItems\nWHERE OrderID = 1001 AND ProductID = 202;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the command to delete *all* rows from the 'Logs' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Logs;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I empty the 'TemporaryData' table completely?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM TemporaryData;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the difference between DELETE and TRUNCATE?\n<end_of_turn>\n<start_of_turn>model\n`DELETE` is a DML operation that removes rows one by one and is logged (can be rolled back). `TRUNCATE` is a DDL operation that deallocates the table's data pages, is much faster, minimally logged, and cannot be rolled back.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I quickly empty a large table named 'EventLogs'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nTRUNCATE TABLE EventLogs;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the command to completely clear all data from the 'StagingArea' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nTRUNCATE TABLE StagingArea;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWill TRUNCATE work if the table is referenced by a foreign key?\n<end_of_turn>\n<start_of_turn>model\nNo, you cannot truncate a table that is referenced by a `FOREIGN KEY` constraint. You must drop the constraint first, or use `DELETE`.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWill `TRUNCATE TABLE Employees` fire any DELETE triggers?\n<end_of_turn>\n<start_of_turn>model\nNo, `TRUNCATE` is a DDL operation and does not fire DML triggers (like `ON DELETE`).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I reset the identity (auto-increment) counter when emptying a table? (e.g., in SQL Server)\n<end_of_turn>\n<start_of_turn>model\n`TRUNCATE TABLE` will automatically reset the `IDENTITY` counter. `DELETE` will not.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all orders placed by 'John Smith'? Use a subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE CustomerID = (SELECT CustomerID FROM Customers WHERE CustomerName = 'John Smith');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees who work in the 'Sales' department. Use a subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE DeptID = (SELECT DeptID FROM Departments WHERE DeptName = 'Sales');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products in the 'Books' category using a subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE CategoryID = (SELECT CategoryID FROM Categories WHERE CategoryName = 'Books');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all 'OrderItems' for products that are in the 'Apparel' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM OrderItems\nWHERE ProductID IN (SELECT ProductID FROM Products WHERE Category = 'Apparel');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all orders from customers who live in 'Canada'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE CustomerID IN (SELECT CustomerID FROM Customers WHERE Country = 'Canada');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees who have a salary below the company average.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Note: Some dialects like MySQL require an extra subquery for this.\nDELETE FROM Employees\nWHERE Salary < (SELECT AVG(Salary) FROM (SELECT * FROM Employees) AS Temp); \n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products that have never been sold.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE ProductID NOT IN (SELECT DISTINCT ProductID FROM OrderItems);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees who are not managers.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE EmpID NOT IN (SELECT DISTINCT ManagerID FROM Employees WHERE ManagerID IS NOT NULL);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all departments that have no employees.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Departments\nWHERE DeptID NOT IN (SELECT DISTINCT DeptID FROM Employees WHERE DeptID IS NOT NULL);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all customers who have not placed an order in 2024.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Customers\nWHERE CustomerID NOT IN (\n  SELECT CustomerID FROM Orders WHERE OrderDate BETWEEN '2024-01-01' AND '2024-12-31'\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees using a JOIN. (e.g., all employees in 'Sales') (T-SQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) syntax\nDELETE e\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nWHERE d.DeptName = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees using a JOIN. (e.g., all employees in 'Sales') (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL syntax\nDELETE e\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nWHERE d.DeptName = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all 'OrderItems' for 'Cancelled' orders. Use a JOIN. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL syntax (USING)\nDELETE FROM OrderItems oi\nUSING Orders o\nWHERE oi.OrderID = o.OrderID AND o.Status = 'Cancelled';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all 'OrderItems' for 'Cancelled' orders. Use a JOIN. (T-SQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL syntax\nDELETE oi\nFROM OrderItems oi\nJOIN Orders o ON oi.OrderID = o.OrderID\nWHERE o.Status = 'Cancelled';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all 'OrderItems' for 'Cancelled' orders. Use a JOIN. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL syntax\nDELETE oi\nFROM OrderItems oi\nJOIN Orders o ON oi.OrderID = o.OrderID\nWHERE o.Status = 'Cancelled';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all orders for customers from 'London'. Use a JOIN.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL/MySQL syntax\nDELETE o\nFROM Orders o\nJOIN Customers c ON o.CustomerID = c.CustomerID\nWHERE c.City = 'London';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products from the 'Discontinued' category. Use a JOIN.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL/MySQL syntax\nDELETE p\nFROM Products p\nJOIN Categories c ON p.CategoryID = c.CategoryID\nWHERE c.CategoryName = 'Discontinued';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees who were hired before their manager. Use a self-join. (T-SQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL/MySQL syntax\nDELETE e\nFROM Employees e\nJOIN Employees m ON e.ManagerID = m.EmpID\nWHERE e.HireDate < m.HireDate;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products that have zero stock and are in the 'Apparel' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Stock = 0 AND Category = 'Apparel';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees who have 'Temp' in their 'JobTitle'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE JobTitle LIKE '%Temp%';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all customers who joined in 2018.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Customers\nWHERE JoinDate BETWEEN '2018-01-01' AND '2018-12-31';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products with a price of 19.95.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Price = 19.95;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees with a 'Salary' between 40000 and 45000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Salary BETWEEN 40000 AND 45000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all customers whose 'Email' is NULL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Customers\nWHERE Email IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all 'OrderItems' with a 'Quantity' of 0.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM OrderItems\nWHERE Quantity = 0;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees *except* those in the 'IT' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Department <> 'IT';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products *except* those in 'Electronics' or 'Books'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Category NOT IN ('Electronics', 'Books');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all orders placed by 'CustomerID' 101, 102, or 103.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE CustomerID IN (101, 102, 103);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees whose 'LastName' ends in 'son'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE LastName LIKE '%son';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all log entries with the message 'Test Log'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Logs\nWHERE Message = 'Test Log';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products with a price less than 5.00.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Price < 5.00;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees with a salary greater than or equal to 100000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Salary >= 100000;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all customers from 'ZipCode' 90210.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Customers\nWHERE ZipCode = '90210';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products from 'SupplierID' 50.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE SupplierID = 50;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees who have no 'Salary' entered (is NULL).\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Salary IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all 'OrderItems' that have a 'Discount' applied (Discount > 0).\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM OrderItems\nWHERE Discount > 0;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees from 'Finance' hired in 2020.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Department = 'Finance' AND HireDate BETWEEN '2020-01-01' AND '2020-12-31';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products with 0 stock from 'Warehouse' 3.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Inventory\nWHERE Stock = 0 AND WarehouseID = 3;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all 'Inactive' users.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Users\nWHERE Status = 'Inactive';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees named 'Bob'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE FirstName = 'Bob';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products in 'Category' 5.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE CategoryID = 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all customers who are 65 or older.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Customers\nWHERE Age >= 65;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all orders from 'CustomerID' 4 or 'CustomerID' 5.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE CustomerID = 4 OR CustomerID = 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all log entries that are *not* 'ERROR' type.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Logs\nWHERE LogType <> 'ERROR';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products with a 'Price' of 0 or NULL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Price = 0 OR Price IS NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees with an 'EmpID' between 500 and 600.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE EmpID BETWEEN 500 AND 600;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all customers whose 'LastName' ends with 'ez'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Customers\nWHERE LastName LIKE '%ez';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products whose 'ProductName' has exactly 3 letters.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE ProductName LIKE '___';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees who have a 'HireDate' (it is not null).\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE HireDate IS NOT NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all 'OrderItems' for 'ProductID' 404 or 405.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM OrderItems\nWHERE ProductID IN (404, 405);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees who are *not* from 'DeptID' 1, 2, or 3.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE DeptID NOT IN (1, 2, 3);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products with 'Price' *not* between 100 and 200.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Price NOT BETWEEN 100 AND 200;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all rows in 'TempData' using TRUNCATE?\n<end_of_turn>\n<start_of_turn>model\n```sql\nTRUNCATE TABLE TempData;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the command to empty the 'Cache' table quickly?\n<end_of_turn>\n<start_of_turn>model\n```sql\nTRUNCATE TABLE Cache;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees with a salary over 100k in the 'Finance' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Salary > 100000 AND Department = 'Finance';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products that are 'OutOfStock' and have a 'Price' of 0.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE Status = 'OutOfStock' AND Price = 0;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all customers whose 'FirstName' is 'Sam' and 'LastName' is 'Jones'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Customers\nWHERE FirstName = 'Sam' AND LastName = 'Jones';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all orders from '2023-01-15'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE OrderDate = '2023-01-15';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all log entries from 'UserID' 12.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Logs\nWHERE UserID = 12;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all 'OrderItems' for 'OrderID' 200 and 'ProductID' 30.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM OrderItems\nWHERE OrderID = 200 AND ProductID = 30;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nEmpty the 'ErrorLog' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nTRUNCATE TABLE ErrorLog;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nEmpty the 'TransactionHistory' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nTRUNCATE TABLE TransactionHistory;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all rows from 'Employees'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all rows from 'Products'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show employee salary rank, but restart the ranking for each department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  DeptID, \n  Salary, \n  RANK() OVER (PARTITION BY DeptID ORDER BY Salary DESC) as DeptSalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat's the difference between RANK() and DENSE_RANK()?\n<end_of_turn>\n<start_of_turn>model\n`RANK()` skips ranks after a tie (e.g., 1, 2, 2, 4). `DENSE_RANK()` does not skip ranks after a tie (e.g., 1, 2, 2, 3).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me how to use `DENSE_RANK()`.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  DENSE_RANK() OVER (ORDER BY Salary DESC) as SalaryRank\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show each employee's salary next to the average salary for their department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  DeptID, \n  Salary, \n  AVG(Salary) OVER (PARTITION BY DeptID) as DeptAvgSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show each day's sales and a 7-day rolling average? (Window Function)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  DailySales,\n  AVG(DailySales) OVER (\n    ORDER BY SaleDate\n    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW\n  ) AS '7DayRollingAvg'\nFROM DailySalesSummary;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show each employee's hire date, and the hire date of the person hired just before them? (LAG)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  HireDate,\n  LAG(HireDate, 1) OVER (ORDER BY HireDate) AS PreviousHireDate\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I show each employee's salary and the salary of the next employee when sorted by name? (LEAD)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary,\n  LEAD(Salary, 1) OVER (ORDER BY Name) AS NextEmployeeSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I calculate a cumulative sum of all sales? (Running Total)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  SaleDate, \n  SaleAmount,\n  SUM(SaleAmount) OVER (ORDER BY SaleDate) AS RunningTotal\nFROM Sales;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who have the highest salary in the company. Use a subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, Salary\nFROM Employees\nWHERE Salary = (SELECT MAX(Salary) FROM Employees);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the employee with the lowest salary. Use a subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, Salary\nFROM Employees\nWHERE Salary = (SELECT MIN(Salary) FROM Employees);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who earn more than the company's average salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, Salary\nFROM Employees\nWHERE Salary > (SELECT AVG(Salary) FROM Employees);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that are more expensive than the average price of all products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName, Price\nFROM Products\nWHERE Price > (SELECT AVG(Price) FROM Products);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that are cheaper than the average price.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName, Price\nFROM Products\nWHERE Price < (SELECT AVG(Price) FROM Products);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who work in the 'Sales' department. Use a subquery with IN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees\nWHERE DeptID IN (SELECT DeptID FROM Departments WHERE DeptName = 'Sales');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all customers who have placed an order. Use a subquery with IN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerName\nFROM Customers\nWHERE CustomerID IN (SELECT CustomerID FROM Orders);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that have been sold at least once. Use IN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName\nFROM Products\nWHERE ProductID IN (SELECT DISTINCT ProductID FROM OrderItems);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who are in the 'New York' location. (Tables: Employees, Departments)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees\nWHERE DeptID IN (SELECT DeptID FROM Departments WHERE Location = 'New York');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all orders that contain 'Product' 101.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT OrderID, OrderDate\nFROM Orders\nWHERE OrderID IN (SELECT OrderID FROM OrderItems WHERE ProductID = 101);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who do *not* work in the 'Sales' department. Use NOT IN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees\nWHERE DeptID NOT IN (SELECT DeptID FROM Departments WHERE DeptName = 'Sales');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all customers who have *never* placed an order. Use NOT IN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerName\nFROM Customers\nWHERE CustomerID NOT IN (SELECT CustomerID FROM Orders WHERE CustomerID IS NOT NULL);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that have *never* been sold. Use NOT IN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName\nFROM Products\nWHERE ProductID NOT IN (SELECT ProductID FROM OrderItems);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all employees who are *not* in the 'New York' location.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees\nWHERE DeptID NOT IN (SELECT DeptID FROM Departments WHERE Location = 'New York');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all orders that do *not* contain 'Product' 101.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT OrderID\nFROM Orders\nWHERE OrderID NOT IN (SELECT OrderID FROM OrderItems WHERE ProductID = 101);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all customers who have placed an order. Use EXISTS.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerName\nFROM Customers c\nWHERE EXISTS (\n  SELECT 1 FROM Orders o WHERE o.CustomerID = c.CustomerID\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that have been sold. Use EXISTS.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName\nFROM Products p\nWHERE EXISTS (\n  SELECT 1 FROM OrderItems oi WHERE oi.ProductID = p.ProductID\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all departments that have at least one employee. Use EXISTS.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT DeptName\nFROM Departments d\nWHERE EXISTS (\n  SELECT 1 FROM Employees e WHERE e.DeptID = d.DeptID\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me all employees who are managers. (i.e., their EmpID appears in the ManagerID column).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees e1\nWHERE EXISTS (\n  SELECT 1 FROM Employees e2 WHERE e2.ManagerID = e1.EmpID\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all customers who have bought a 'Laptop'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerName\nFROM Customers c\nWHERE EXISTS (\n  SELECT 1 FROM Orders o\n  JOIN OrderItems oi ON o.OrderID = oi.OrderID\n  JOIN Products p ON oi.ProductID = p.ProductID\n  WHERE o.CustomerID = c.CustomerID AND p.ProductName = 'Laptop'\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all customers who have *never* placed an order. Use NOT EXISTS.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerName\nFROM Customers c\nWHERE NOT EXISTS (\n  SELECT 1 FROM Orders o WHERE o.CustomerID = c.CustomerID\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products that have *never* been sold. Use NOT EXISTS.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName\nFROM Products p\nWHERE NOT EXISTS (\n  SELECT 1 FROM OrderItems oi WHERE oi.ProductID = p.ProductID\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all departments that are empty (have no employees). Use NOT EXISTS.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT DeptName\nFROM Departments d\nWHERE NOT EXISTS (\n  SELECT 1 FROM Employees e WHERE e.DeptID = d.DeptID\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who are *not* managers. Use NOT EXISTS.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees e1\nWHERE NOT EXISTS (\n  SELECT 1 FROM Employees e2 WHERE e2.ManagerID = e1.EmpID\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all customers who have *not* bought a 'Laptop'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerName\nFROM Customers c\nWHERE NOT EXISTS (\n  SELECT 1 FROM Orders o\n  JOIN OrderItems oi ON o.OrderID = oi.OrderID\n  JOIN Products p ON oi.ProductID = p.ProductID\n  WHERE o.CustomerID = c.CustomerID AND p.ProductName = 'Laptop'\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me the name and department of all employees. Use a subquery in the FROM clause.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  d.DeptName\nFROM Employees e\nJOIN (SELECT DeptID, DeptName FROM Departments) AS d\n  ON e.DeptID = d.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the average of the maximum salaries from all departments.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT AVG(MaxSalary)\nFROM (\n  SELECT DeptID, MAX(Salary) AS MaxSalary\n  FROM Employees\n  GROUP BY DeptID\n) AS DeptMaxSalaries;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all customers and the total amount they spent. Use a derived table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  OrderTotals.Total\nFROM Customers c\nJOIN (\n  SELECT o.CustomerID, SUM(oi.Quantity * oi.UnitPrice) AS Total\n  FROM Orders o\n  JOIN OrderItems oi ON o.OrderID = oi.OrderID\n  GROUP BY o.CustomerID\n) AS OrderTotals\n  ON c.CustomerID = OrderTotals.CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who earn more than their department's average salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  e.Salary, \n  DeptAvg.AvgSalary\nFROM Employees e\nJOIN (\n  SELECT DeptID, AVG(Salary) AS AvgSalary\n  FROM Employees\n  GROUP BY DeptID\n) AS DeptAvg\n  ON e.DeptID = DeptAvg.DeptID\nWHERE e.Salary > DeptAvg.AvgSalary;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the top 5 customers by total order count.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  OrderCounts.NumOrders\nFROM Customers c\nJOIN (\n  SELECT CustomerID, COUNT(OrderID) AS NumOrders\n  FROM Orders\n  GROUP BY CustomerID\n) AS OrderCounts\n  ON c.CustomerID = OrderCounts.CustomerID\nORDER BY OrderCounts.NumOrders DESC\nLIMIT 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the name of the department with the highest average salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName, \n  DeptAvg.AvgSalary\nFROM Departments d\nJOIN (\n  SELECT DeptID, AVG(Salary) AS AvgSalary\n  FROM Employees\n  GROUP BY DeptID\n) AS DeptAvg\n  ON d.DeptID = DeptAvg.DeptID\nORDER BY DeptAvg.AvgSalary DESC\nLIMIT 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all products from the 'Electronics' category. Use a derived table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT *\nFROM (\n  SELECT * FROM Products\n) AS AllProducts\nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all orders from 2024. Use a subquery in the FROM clause.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT *\nFROM (\n  SELECT * FROM Orders WHERE OrderDate BETWEEN '2024-01-01' AND '2024-12-31'\n) AS Orders2024;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGet all employees hired after 'John Smith'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, HireDate\nFROM Employees\nWHERE HireDate > (SELECT HireDate FROM Employees WHERE Name = 'John Smith');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees in the same department as 'Jane Doe'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees\nWHERE DeptID = (SELECT DeptID FROM Employees WHERE Name = 'Jane Doe')\n  AND Name <> 'Jane Doe';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's name and the total number of orders they processed. (Correlated subquery in SELECT)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e.Name, \n  (SELECT COUNT(o.OrderID) FROM Orders o WHERE o.EmployeeID = e.EmpID) AS OrderCount\nFROM Employees e;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each customer's name and their total number of orders. (Correlated subquery in SELECT)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  (SELECT COUNT(o.OrderID) FROM Orders o WHERE o.CustomerID = c.CustomerID) AS TotalOrders\nFROM Customers c;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each product's name and the total quantity sold. (Correlated subquery in SELECT)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProductName, \n  (SELECT SUM(oi.Quantity) FROM OrderItems oi WHERE oi.ProductID = p.ProductID) AS TotalSold\nFROM Products p;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each department's name and the number of employees in it. (Correlated subquery in SELECT)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName, \n  (SELECT COUNT(e.EmpID) FROM Employees e WHERE e.DeptID = d.DeptID) AS EmployeeCount\nFROM Departments d;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFor each employee, show their name and their manager's name. (Correlated subquery in SELECT)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e1.Name, \n  (SELECT e2.Name FROM Employees e2 WHERE e2.EmpID = e1.ManagerID) AS ManagerName\nFROM Employees e1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each customer's name and the date of their most recent order.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  c.CustomerName, \n  (SELECT MAX(o.OrderDate) FROM Orders o WHERE o.CustomerID = c.CustomerID) AS LastOrderDate\nFROM Customers c;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each product's name and its most recent sale date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProductName, \n  (SELECT MAX(o.OrderDate) FROM Orders o\n   JOIN OrderItems oi ON o.OrderID = oi.OrderID\n   WHERE oi.ProductID = p.ProductID) AS LastSaleDate\nFROM Products p;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's name and their salary as a percentage of the company's total salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  Salary * 100.0 / (SELECT SUM(Salary) FROM Employees) AS PctOfTotalSalary\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each product's price and the average price for its category. (Correlated subquery)\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p1.ProductName, \n  p1.Category, \n  p1.Price, \n  (SELECT AVG(p2.Price) FROM Products p2 WHERE p2.Category = p1.Category) AS AvgCategoryPrice\nFROM Products p1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's name, salary, and their department's average salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  e1.Name, \n  e1.Salary, \n  (SELECT AVG(e2.Salary) FROM Employees e2 WHERE e2.DeptID = e1.DeptID) AS AvgDeptSalary\nFROM Employees e1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete all orders placed by 'John Smith'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE CustomerID = (SELECT CustomerID FROM Customers WHERE CustomerName = 'John Smith');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees from the 'Sales' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE DeptID = (SELECT DeptID FROM Departments WHERE DeptName = 'Sales');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all 'OrderItems' for products in the 'Books' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM OrderItems\nWHERE ProductID IN (SELECT ProductID FROM Products WHERE Category = 'Books');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all orders placed by customers from 'Canada'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE CustomerID IN (SELECT CustomerID FROM Customers WHERE Country = 'Canada');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees who have a salary below the company average.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE Salary < (SELECT AVG(Salary) FROM (SELECT * FROM Employees) AS Temp);\n-- (Note: MySQL often requires the extra subquery for DELETE/UPDATE)\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all products that have never been sold.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Products\nWHERE ProductID NOT IN (SELECT DISTINCT ProductID FROM OrderItems);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all employees who are not managers.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Employees\nWHERE EmpID NOT IN (SELECT DISTINCT ManagerID FROM (SELECT * FROM Employees) AS Temp WHERE ManagerID IS NOT NULL);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all departments that have no employees.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Departments\nWHERE DeptID NOT IN (SELECT DISTINCT DeptID FROM Employees WHERE DeptID IS NOT NULL);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I give a 10% raise to all employees in the 'Sales' department? Use a subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = Salary * 1.10\nWHERE DeptID = (SELECT DeptID FROM Departments WHERE DeptName = 'Sales');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nUpdate the 'Status' to 'Archived' for all orders placed before 2023.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders\nSET Status = 'Archived'\nWHERE OrderDate < '2023-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the 'Price' of all 'Electronics' products to be 5% higher.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products\nSET Price = Price * 1.05\nWHERE Category = 'Electronics';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the salary of all employees to the company average salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = (SELECT AVG(Salary) FROM (SELECT * FROM Employees) AS Temp);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nGive a $1000 raise to all employees who are managers.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = Salary + 1000\nWHERE EmpID IN (SELECT DISTINCT ManagerID FROM (SELECT * FROM Employees) AS Temp WHERE ManagerID IS NOT NULL);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nArchive all orders from customers in 'London'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Orders\nSET Status = 'Archived'\nWHERE CustomerID IN (SELECT CustomerID FROM Customers WHERE City = 'London');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSet the salary of all employees in 'New York' to 60000.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = 60000\nWHERE DeptID IN (\n  SELECT DeptID FROM Departments WHERE Location = 'New York'\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDiscount all products that have never been sold by 50%.\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Products\nSET Price = Price * 0.50\nWHERE ProductID NOT IN (SELECT DISTINCT ProductID FROM OrderItems);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind employees who earn more than at least one employee in the 'Sales' department. Use ANY.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, Salary\nFROM Employees\nWHERE Salary > ANY (\n  SELECT Salary FROM Employees WHERE Department = 'Sales'\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind employees who earn more than all employees in the 'HR' department. Use ALL.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, Salary\nFROM Employees\nWHERE Salary > ALL (\n  SELECT Salary FROM Employees WHERE Department = 'HR'\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind products with a price greater than any product in the 'Books' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName, Price\nFROM Products\nWHERE Price > ANY (SELECT Price FROM Products WHERE Category = 'Books');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind products with a price greater than all products in the 'Homeware' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName, Price\nFROM Products\nWHERE Price > ALL (SELECT Price FROM Products WHERE Category = 'Homeware');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the cheapest product that is more expensive than all books.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT MIN(Price)\nFROM Products\nWHERE Price > ALL (SELECT Price FROM Products WHERE Category = 'Books');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind any employees who have the exact same salary as an employee in the 'Finance' department.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, Salary\nFROM Employees e1\nWHERE Salary = ANY (SELECT Salary FROM Employees e2 WHERE e2.Department = 'Finance' AND e1.EmpID <> e2.EmpID);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind departments whose *lowest* salary is greater than the *highest* salary in 'HR'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Department, MIN(Salary)\nFROM Employees\nGROUP BY Department\nHAVING MIN(Salary) > (SELECT MAX(Salary) FROM Employees WHERE Department = 'HR');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert all employees from 'Sales' into a 'SalesArchive' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO SalesArchive (EmpID, Name)\nSELECT EmpID, Name FROM Employees\nWHERE DeptID = (SELECT DeptID FROM Departments WHERE DeptName = 'Sales');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert all customers who have placed an order into a 'ActiveCustomers' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO ActiveCustomers (CustomerID, CustomerName)\nSELECT CustomerID, CustomerName FROM Customers\nWHERE CustomerID IN (SELECT DISTINCT CustomerID FROM Orders);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nInsert products with 0 stock into a 'DiscontinuedProducts' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nINSERT INTO DiscontinuedProducts (ProductID, ProductName)\nSELECT ProductID, ProductName FROM Products\nWHERE Stock = 0;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's name and their salary, relative to the average salary (Salary - AvgSalary).\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  Name, \n  Salary, \n  Salary - (SELECT AVG(Salary) FROM Employees) AS DiffFromAverage\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each product's name and its price as a percentage of the most expensive product.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  ProductName, \n  Price, \n  Price * 100.0 / (SELECT MAX(Price) FROM Products) AS PctOfMaxPrice\nFROM Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the average total order value.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT AVG(OrderTotal)\nFROM (\n  SELECT OrderID, SUM(Quantity * UnitPrice) AS OrderTotal\n  FROM OrderItems\n  GROUP BY OrderID\n) AS OrderTotals;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who were hired in the same year as the employee with the highest salary.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (Using EXTRACT for PostgreSQL/Standard SQL)\nSELECT Name, HireDate\nFROM Employees\nWHERE EXTRACT(YEAR FROM HireDate) = (\n  SELECT EXTRACT(YEAR FROM HireDate) \n  FROM Employees \n  WHERE Salary = (SELECT MAX(Salary) FROM Employees)\n  LIMIT 1\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect all orders that contain more than 3 unique items.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT OrderID\nFROM OrderItems\nGROUP BY OrderID\nHAVING COUNT(ProductID) > 3;\n-- (Subquery version)\nSELECT OrderID, OrderDate\nFROM Orders\nWHERE OrderID IN (\n  SELECT OrderID \n  FROM OrderItems \n  GROUP BY OrderID \n  HAVING COUNT(ProductID) > 3\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all customers who have ordered a product in the 'Books' category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerName\nFROM Customers\nWHERE CustomerID IN (\n  SELECT o.CustomerID \n  FROM Orders o\n  JOIN OrderItems oi ON o.OrderID = oi.OrderID\n  JOIN Products p ON oi.ProductID = p.ProductID\n  WHERE p.Category = 'Books'\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who do not manage anyone.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees\nWHERE EmpID NOT IN (\n  SELECT DISTINCT ManagerID FROM Employees WHERE ManagerID IS NOT NULL\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all products that have been sold, using a subquery in the FROM clause.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT p.ProductName\nFROM Products p\nJOIN (SELECT DISTINCT ProductID FROM OrderItems) AS SoldProducts\n  ON p.ProductID = SoldProducts.ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nList all departments and their employee count, using a derived table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  d.DeptName, \n  COALESCE(ec.EmployeeCount, 0) AS EmployeeCount\nFROM Departments d\nLEFT JOIN (\n  SELECT DeptID, COUNT(*) AS EmployeeCount\n  FROM Employees\n  GROUP BY DeptID\n) AS ec\n  ON d.DeptID = ec.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSelect the product with the highest price. Use a derived table and LIMIT.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName, Price\nFROM (\n  SELECT ProductName, Price\n  FROM Products\n  ORDER BY Price DESC\n) AS SortedProducts\nLIMIT 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees hired in the last 6 months.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (PostgreSQL)\nSELECT Name, HireDate\nFROM Employees\nWHERE HireDate >= (NOW() - INTERVAL '6 months');\n\n-- (MySQL)\n-- SELECT Name, HireDate\n-- FROM Employees\n-- WHERE HireDate >= (CURDATE() - INTERVAL 6 MONTH);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind the order with the highest total value.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT OrderID, SUM(Quantity * UnitPrice) AS TotalValue\nFROM OrderItems\nGROUP BY OrderID\nORDER BY TotalValue DESC\nLIMIT 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow each employee's name and their salary. Use a derived table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, Salary\nFROM (\n  SELECT Name, Salary FROM Employees\n) AS AllEmployees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees in 'Sales' hired in 2023. Use a derived table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM (\n  SELECT Name, Department, HireDate\n  FROM Employees\n  WHERE Department = 'Sales'\n) AS SalesEmployees\nWHERE HireDate BETWEEN '2023-01-01' AND '2023-12-31';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all products with a price higher than the 'Laptop'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT ProductName, Price\nFROM Products\nWHERE Price > (SELECT Price FROM Products WHERE ProductName = 'Laptop' LIMIT 1);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who have the same manager as 'John Smith'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees\nWHERE ManagerID = (SELECT ManagerID FROM Employees WHERE Name = 'John Smith' LIMIT 1)\n  AND Name <> 'John Smith';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all customers who live in the same city as 'Alice Smith'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerName\nFROM Customers\nWHERE City = (SELECT City FROM Customers WHERE CustomerName = 'Alice Smith' LIMIT 1)\n  AND CustomerName <> 'Alice Smith';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the average salary for the 'Sales' department. Use a scalar subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT (\n  SELECT AVG(Salary) \n  FROM Employees \n  WHERE Department = 'Sales'\n) AS SalesAvgSalary;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the total number of customers. Use a scalar subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT (SELECT COUNT(*) FROM Customers) AS TotalCustomers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow the highest price of any product in the 'Electronics' category. Use a subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT (\n  SELECT MAX(Price) \n  FROM Products \n  WHERE Category = 'Electronics'\n) AS MaxElectronicsPrice;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all orders placed on the earliest order date in the table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT OrderID, OrderDate\nFROM Orders\nWHERE OrderDate = (SELECT MIN(OrderDate) FROM Orders);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees hired on the most recent hire date.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name, HireDate\nFROM Employees\nWHERE HireDate = (SELECT MAX(HireDate) FROM Employees);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I update all employees in 'Sales' to have the 'Sales' department's average salary?\n<end_of_turn>\n<start_of_turn>model\n```sql\nUPDATE Employees\nSET Salary = (SELECT AVG(Salary) FROM (SELECT * FROM Employees) AS Temp WHERE Department = 'Sales')\nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete all orders from customers who have 'test' in their email.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDELETE FROM Orders\nWHERE CustomerID IN (SELECT CustomerID FROM Customers WHERE Email LIKE '%test%');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who were hired in 2023. Use a subquery.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees\nWHERE EmpID IN (SELECT EmpID FROM Employees WHERE HireDate BETWEEN '2023-01-01' AND '2023-12-31');\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all employees who are *not* in the 'IT' or 'Finance' departments. Use NOT IN.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT Name\nFROM Employees\nWHERE Department NOT IN ('IT', 'Finance');\n-- Using a subquery:\n-- SELECT Name\n-- FROM Employees\n-- WHERE DeptID NOT IN (SELECT DeptID FROM Departments WHERE DeptName IN ('IT', 'Finance'));\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nFind all customers who have placed an order for more than $100.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT CustomerName\nFROM Customers\nWHERE CustomerID IN (\n  SELECT o.CustomerID \n  FROM Orders o\n  JOIN OrderItems oi ON o.OrderID = oi.OrderID\n  WHERE (oi.Quantity * oi.UnitPrice) > 100\n);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow all products, and for each one, show the total number of orders it has appeared in.\n<end_of_turn>\n<start_of_turn>model\n```sql\nSELECT \n  p.ProductName, \n  (SELECT COUNT(DISTINCT oi.OrderID) FROM OrderItems oi WHERE oi.ProductID = p.ProductID) AS OrderCount\nFROM Products p;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow all employees whose salary is in the top 10% of the company.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- (PostgreSQL syntax)\nSELECT Name, Salary\nFROM Employees\nWHERE Salary >= (SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY Salary) FROM Employees);\n-- (Generic version)\n-- SELECT Name, Salary\n-- FROM Employees e\n-- WHERE (SELECT COUNT(*) FROM Employees e2 WHERE e2.Salary > e.Salary) < (SELECT COUNT(*) * 0.1 FROM Employees);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a simple view named 'SalesEmployees' that shows all employees from the 'Sales' department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW SalesEmployees AS\nSELECT EmpID, Name, Salary\nFROM Employees\nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'HighValueProducts' for all products with a price over $100.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW HighValueProducts AS\nSELECT ProductID, ProductName, Price\nFROM Products\nWHERE Price > 100;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a view 'CustomerEmails' that only shows customer names and emails?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW CustomerEmails AS\nSELECT CustomerName, Email\nFROM Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'ActiveProjects' that shows all projects with a 'Status' of 'Active'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW ActiveProjects AS\nSELECT ProjectID, ProjectName, StartDate\nFROM Projects\nWHERE Status = 'Active';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a view 'RecentOrders' showing orders from 2024 onwards?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW RecentOrders AS\nSELECT OrderID, CustomerID, OrderDate\nFROM Orders\nWHERE OrderDate >= '2024-01-01';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'EmployeeContactInfo' with employee names and emails.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW EmployeeContactInfo AS\nSELECT Name, Email\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'UkCustomers' for all customers from the 'UK'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW UkCustomers AS\nSELECT CustomerID, CustomerName, City\nFROM Customers\nWHERE Country = 'UK';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'OutOfStockProducts' for products with 0 stock.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW OutOfStockProducts AS\nSELECT ProductID, ProductName\nFROM Products\nWHERE Stock = 0;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'HighPriorityTasks' for tasks with priority > 5.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW HighPriorityTasks AS\nSELECT TaskID, TaskName, Priority\nFROM Tasks\nWHERE Priority > 5;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'PendingOrders' for all orders with a 'Pending' status.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW PendingOrders AS\nSELECT OrderID, OrderDate, CustomerID\nFROM Orders\nWHERE Status = 'Pending';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a view that joins 'Employees' and 'Departments' to show names and department names?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW EmployeeDepartments AS\nSELECT e.Name, d.DeptName\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'OrderDetailsView' that joins 'Orders', 'Customers', and 'Products'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW OrderDetailsView AS\nSELECT o.OrderID, c.CustomerName, p.ProductName, oi.Quantity\nFROM Orders o\nJOIN Customers c ON o.CustomerID = c.CustomerID\nJOIN OrderItems oi ON o.OrderID = oi.OrderID\nJOIN Products p ON oi.ProductID = p.ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'ProductSupplierView' joining 'Products' and 'Suppliers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW ProductSupplierView AS\nSELECT p.ProductName, s.SupplierName, s.ContactEmail\nFROM Products p\nJOIN Suppliers s ON p.SupplierID = s.SupplierID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'EmployeeManagerView' that self-joins 'Employees' to show employee and manager names.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW EmployeeManagerView AS\nSELECT e.Name AS Employee, m.Name AS Manager\nFROM Employees e\nLEFT JOIN Employees m ON e.ManagerID = m.EmpID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'CustomerOrderHistory' that joins 'Customers' and 'Orders'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW CustomerOrderHistory AS\nSELECT c.CustomerName, o.OrderID, o.OrderDate, o.TotalAmount\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a view 'DepartmentSalarySummary' that shows the average salary per department?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW DepartmentSalarySummary AS\nSELECT \n  d.DeptName, \n  AVG(e.Salary) AS AverageSalary, \n  COUNT(e.EmpID) AS EmployeeCount\nFROM Departments d\nJOIN Employees e ON d.DeptID = e.DeptID\nGROUP BY d.DeptName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'ProductTotalRevenue' showing total revenue for each product.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW ProductTotalRevenue AS\nSELECT \n  p.ProductName, \n  SUM(oi.Quantity * oi.UnitPrice) AS TotalRevenue\nFROM Products p\nJOIN OrderItems oi ON p.ProductID = oi.ProductID\nGROUP BY p.ProductName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'CustomerTotalSpent' with the total amount spent by each customer.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW CustomerTotalSpent AS\nSELECT \n  c.CustomerName, \n  SUM(o.TotalAmount) AS TotalSpent\nFROM Customers c\nJOIN Orders o ON c.CustomerID = o.CustomerID\nGROUP BY c.CustomerName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'CategoryProductCount' that shows how many products are in each category.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW CategoryProductCount AS\nSELECT \n  Category, \n  COUNT(ProductID) AS ProductCount\nFROM Products\nGROUP BY Category;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'OrderSummary' with OrderID and the total number of items in that order.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW OrderSummary AS\nSELECT \n  OrderID, \n  SUM(Quantity) AS TotalItems\nFROM OrderItems\nGROUP BY OrderID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create or replace an existing view named 'SalesEmployees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE OR REPLACE VIEW SalesEmployees AS\nSELECT EmpID, Name, Salary, Department\nFROM Employees\nWHERE Department = 'Sales';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate or replace the view 'UkCustomers' to also include the 'Email' column.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE OR REPLACE VIEW UkCustomers AS\nSELECT CustomerID, CustomerName, City, Email\nFROM Customers\nWHERE Country = 'UK';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'Top10Products' that shows the 10 most expensive products.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW Top10Products AS\nSELECT ProductName, Price\nFROM Products\nORDER BY Price DESC\nLIMIT 10;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'SalesManagerView' that only shows employees who are managers.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW SalesManagerView AS\nSELECT e.Name, d.DeptName\nFROM Employees e\nJOIN Departments d ON e.DeptID = d.DeptID\nWHERE e.EmpID IN (SELECT DISTINCT ManagerID FROM Employees);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a view 'EmployeeNameOnly' that hides all other employee information.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE VIEW EmployeeNameOnly AS\nSELECT Name\nFROM Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete the view named 'SalesEmployees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW SalesEmployees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the command to remove the 'HighValueProducts' view?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW HighValueProducts;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the 'CustomerEmails' view?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW CustomerEmails;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete the view 'ActiveProjects'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW ActiveProjects;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'RecentOrders' view.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW RecentOrders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the view 'EmployeeContactInfo'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW EmployeeContactInfo;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the 'UkCustomers' view?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW UkCustomers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete the 'OutOfStockProducts' view.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW OutOfStockProducts;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'HighPriorityTasks' view.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW HighPriorityTasks;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the command to drop the 'PendingOrders' view?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW PendingOrders;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the 'EmployeeDepartments' view?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW EmployeeDepartments;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete the 'OrderDetailsView' view.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW OrderDetailsView;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'ProductSupplierView' view.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW ProductSupplierView;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the 'EmployeeManagerView'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW EmployeeManagerView;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the command to drop 'CustomerOrderHistory'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW CustomerOrderHistory;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the view 'DepartmentSalarySummary'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW DepartmentSalarySummary;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete the 'ProductTotalRevenue' view.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW ProductTotalRevenue;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'CustomerTotalSpent' view.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW CustomerTotalSpent;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the 'CategoryProductCount' view?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW CategoryProductCount;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'OrderSummary' view.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW OrderSummary;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop a view only if it exists? (e.g., 'SalesEmployees')\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW IF EXISTS SalesEmployees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the command to safely drop 'OldDataView' only if it's present?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW IF EXISTS OldDataView;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the view 'V_TEST' if it exists.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW IF EXISTS V_TEST;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop 'Top10Products' view?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW Top10Products;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'EmployeeNameOnly' view if it exists.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP VIEW IF EXISTS EmployeeNameOnly;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create an index on the 'LastName' column in the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Employees_LastName ON Employees (LastName);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on the 'Email' column in 'Customers' to speed up lookups.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Customers_Email ON Customers (Email);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a unique index on the 'Email' column in 'Employees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE UNIQUE INDEX UQ_Employees_Email ON Employees (Email);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a unique index on the 'SKU' column in the 'Products' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE UNIQUE INDEX UQ_Products_SKU ON Products (SKU);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on 'OrderDate' in the 'Orders' table to make date range queries faster.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Orders_OrderDate ON Orders (OrderDate);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create an index on the 'DepartmentID' foreign key column in 'Employees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Employees_DeptID ON Employees (DeptID);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on the 'CustomerID' foreign key in the 'Orders' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Orders_CustomerID ON Orders (CustomerID);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on 'ProductID' in the 'OrderItems' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_OrderItems_ProductID ON OrderItems (ProductID);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a composite index (multiple columns) on 'LastName' and 'FirstName' in 'Employees'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Employees_Name ON Employees (LastName, FirstName);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a composite index on 'Category' and 'Price' in the 'Products' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Products_CategoryPrice ON Products (Category, Price);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a unique composite index on 'OrderID' and 'ProductID' in 'OrderItems'. (Note: a PK already does this).\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- This is often redundant if a PRIMARY KEY is already on these columns.\nCREATE UNIQUE INDEX UQ_OrderItems_OrderProduct ON OrderItems (OrderID, ProductID);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on 'City' in the 'Customers' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Customers_City ON Customers (City);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on 'Status' in the 'Orders' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Orders_Status ON Orders (Status);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on 'ManagerID' in the 'Employees' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Employees_ManagerID ON Employees (ManagerID);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a unique index on 'PhoneNumber' in 'Suppliers'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE UNIQUE INDEX UQ_Suppliers_Phone ON Suppliers (PhoneNumber);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on 'Email' but only include non-null values. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Customers_Email_NotNull ON Customers (Email) WHERE Email IS NOT NULL;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a filtered index for 'Active' orders only. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Orders_Active ON Orders (OrderDate) WHERE Status = 'Active';\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on 'Price' in 'Products', sorting in descending order.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Products_Price_Desc ON Products (Price DESC);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on 'Category' and 'Price' (descending).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Products_CategoryPriceDesc ON Products (Category, Price DESC);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on the 'Username' column in 'Users', converting it to lowercase. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Users_Username_Lower ON Users (LOWER(Username));\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on the 'Email' column in 'Customers' (ascending).\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Customers_Email_Asc ON Customers (Email ASC);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a unique index on 'LicensePlate' in the 'Vehicles' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE UNIQUE INDEX UQ_Vehicles_LicensePlate ON Vehicles (LicensePlate);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a composite index on 'Make' and 'Model' in the 'Vehicles' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Vehicles_MakeModel ON Vehicles (Make, Model);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate an index on 'Country' and 'City' in the 'Customers' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\nCREATE INDEX IDX_Customers_CountryCity ON Customers (Country, City);\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the index named 'IDX_Employees_LastName' from the 'Employees' table?\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Standard SQL / PostgreSQL / SQL Server\nDROP INDEX IDX_Employees_LastName;\n\n-- MySQL\n-- ALTER TABLE Employees DROP INDEX IDX_Employees_LastName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nWhat is the command to remove the 'IDX_Customers_Email' index?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Customers_Email;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the unique index 'UQ_Employees_Email'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX UQ_Employees_Email;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the index 'UQ_Products_SKU' from the 'Products' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Standard SQL / PostgreSQL / SQL Server\nDROP INDEX UQ_Products_SKU;\n\n-- MySQL\n-- ALTER TABLE Products DROP INDEX UQ_Products_SKU;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I delete the index 'IDX_Orders_OrderDate'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Orders_OrderDate;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the index 'IDX_Employees_DeptID' from the 'Employees' table.\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- Standard SQL / PostgreSQL / SQL Server\nDROP INDEX IDX_Employees_DeptID;\n\n-- MySQL\n-- ALTER TABLE Employees DROP INDEX IDX_Employees_DeptID;\n```\n<end_Two_turn>"}
{"text": "<start_of_turn>user\nHow do I drop the index 'IDX_Orders_CustomerID'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Orders_CustomerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDelete the index 'IDX_OrderItems_ProductID'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_OrderItems_ProductID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I remove the composite index 'IDX_Employees_Name'?\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Employees_Name;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'IDX_Products_CategoryPrice' index.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Products_CategoryPrice;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop an index only if it exists? (e.g., 'IDX_Employees_LastName') (PostgreSQL/SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IF EXISTS IDX_Employees_LastName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nSafely drop the index 'IDX_Customers_Email' if it exists.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IF EXISTS IDX_Customers_Email;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the index 'IDX_Customers_City' from the 'Customers' table. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Customers\nDROP INDEX IDX_Customers_City;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'IDX_Orders_Status' index from the 'Orders' table. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Orders\nDROP INDEX IDX_Orders_Status;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'IDX_Employees_ManagerID' index.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Employees_ManagerID;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'UQ_Suppliers_Phone' index.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX UQ_Suppliers_Phone;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the filtered index 'IDX_Customers_Email_NotNull'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Customers_Email_NotNull;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the index 'IDX_Products_Price_Desc'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Products_Price_Desc;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the functional index 'IDX_Users_Username_Lower'.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Users_Username_Lower;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'UQ_Vehicles_LicensePlate' index.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX UQ_Vehicles_LicensePlate;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the 'IDX_Vehicles_MakeModel' index.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Vehicles_MakeModel;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nRemove the 'IDX_Customers_CountryCity' index.\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Customers_CountryCity;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop an index in SQL Server? (e.g., 'IDX_Employees_LastName' on table 'Employees')\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Employees_LastName ON Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop an index in PostgreSQL? (e.g., 'IDX_Employees_LastName')\n<end_of_turn>\n<start_of_turn>model\n```sql\nDROP INDEX IDX_Employees_LastName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop an index in MySQL? (e.g., 'IDX_Employees_LastName' on table 'Employees')\n<end_of_turn>\n<start_of_turn>model\n```sql\nALTER TABLE Employees\nDROP INDEX IDX_Employees_LastName;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to log a message before a new employee is inserted. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_before_employee_insert\nBEFORE INSERT ON Employees\nFOR EACH ROW\nBEGIN\n  -- In a real trigger, you'd insert into an audit table.\n  SET @log_message = CONCAT('Preparing to insert employee: ', NEW.Name);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger that automatically sets the 'CreatedAt' timestamp when a new user is inserted. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_set_created_at\nBEFORE INSERT ON Users\nFOR EACH ROW\nBEGIN\n  SET NEW.CreatedAt = NOW();\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to prevent an employee's salary from being reduced? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_prevent_salary_reduction\nBEFORE UPDATE ON Employees\nFOR EACH ROW\nBEGIN\n  IF NEW.Salary < OLD.Salary THEN\n    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Error: Salary cannot be reduced.';\n  END IF;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to log the old salary to an 'Audit' table after an update. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_audit_salary_update\nAFTER UPDATE ON Employees\nFOR EACH ROW\nBEGIN\n  IF OLD.Salary <> NEW.Salary THEN\n    INSERT INTO SalaryAudit (EmpID, OldSalary, NewSalary, ChangeDate)\n    VALUES (OLD.EmpID, OLD.Salary, NEW.Salary, NOW());\n  END IF;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to save a copy of an employee's record to 'EmployeesArchive' after they are deleted. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_archive_employee\nAFTER DELETE ON Employees\nFOR EACH ROW\nBEGIN\n  INSERT INTO EmployeesArchive (EmpID, Name, Department, Salary)\n  VALUES (OLD.EmpID, OLD.Name, OLD.Department, OLD.Salary);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to validate email formats before inserting a new customer? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_validate_email\nBEFORE INSERT ON Customers\nFOR EACH ROW\nBEGIN\n  IF NEW.Email NOT LIKE '%@%.%' THEN\n    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid email format.';\n  END IF;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to update a 'LastModified' timestamp on a product whenever it's updated. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_product_last_modified\nBEFORE UPDATE ON Products\nFOR EACH ROW\nBEGIN\n  SET NEW.LastModified = NOW();\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to prevent deleting a 'Project' if it's marked as 'Active'? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_prevent_active_project_delete\nBEFORE DELETE ON Projects\nFOR EACH ROW\nBEGIN\n  IF OLD.Status = 'Active' THEN\n    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Cannot delete an active project.';\n  END IF;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger that increments a 'TotalProducts' count in a 'Categories' table after a new product is added. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_update_category_count\nAFTER INSERT ON Products\nFOR EACH ROW\nBEGIN\n  UPDATE Categories\n  SET TotalProducts = TotalProducts + 1\n  WHERE CategoryID = NEW.CategoryID;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger that decrements 'TotalProducts' count after a product is deleted. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_decrease_category_count\nAFTER DELETE ON Products\nFOR EACH ROW\nBEGIN\n  UPDATE Categories\n  SET TotalProducts = TotalProducts - 1\n  WHERE CategoryID = OLD.CategoryID;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set the 'SKU' to uppercase before inserting a new product. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_uppercase_sku\nBEFORE INSERT ON Products\nFOR EACH ROW\nBEGIN\n  SET NEW.SKU = UPPER(NEW.SKU);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set the 'SKU' to uppercase before updating a product. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_uppercase_sku_update\nBEFORE UPDATE ON Products\nFOR EACH ROW\nBEGIN\n  SET NEW.SKU = UPPER(NEW.SKU);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I prevent a product's price from being increased by more than 50% at a time? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_check_price_increase\nBEFORE UPDATE ON Products\nFOR EACH ROW\nBEGIN\n  IF NEW.Price > (OLD.Price * 1.50) THEN\n    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Price increase cannot be more than 50%.';\n  END IF;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to ensure 'Stock' cannot be set to a negative number. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_check_stock_positive\nBEFORE INSERT ON Products\nFOR EACH ROW\nBEGIN\n  IF NEW.Stock < 0 THEN\n    SET NEW.Stock = 0;\n  END IF;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to check 'Stock' on update as well. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_check_stock_positive_update\nBEFORE UPDATE ON Products\nFOR EACH ROW\nBEGIN\n  IF NEW.Stock < 0 THEN\n    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Stock cannot be negative.';\n  END IF;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I log all deleted orders to an 'OrdersAudit' table? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_audit_deleted_orders\nAFTER DELETE ON Orders\nFOR EACH ROW\nBEGIN\n  INSERT INTO OrdersAudit (OrderID, CustomerID, TotalAmount, Action, Timestamp)\n  VALUES (OLD.OrderID, OLD.CustomerID, OLD.TotalAmount, 'DELETE', NOW());\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to prevent 'Username' from being updated. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_prevent_username_change\nBEFORE UPDATE ON Users\nFOR EACH ROW\nBEGIN\n  IF NEW.Username <> OLD.Username THEN\n    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Username cannot be changed.';\n  END IF;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set 'JoinDate' to the current date for new customers. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_set_join_date\nBEFORE INSERT ON Customers\nFOR EACH ROW\nBEGIN\n  SET NEW.JoinDate = CURDATE();\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I log an 'AFTER INSERT' event on the 'Employees' table? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_log_new_employee\nAFTER INSERT ON Employees\nFOR EACH ROW\nBEGIN\n  INSERT INTO AuditLog (TableName, RecordID, Action, Timestamp)\n  VALUES ('Employees', NEW.EmpID, 'INSERT', NOW());\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to log an 'AFTER UPDATE' event on the 'Employees' table. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_log_update_employee\nAFTER UPDATE ON Employees\nFOR EACH ROW\nBEGIN\n  INSERT INTO AuditLog (TableName, RecordID, Action, Timestamp)\n  VALUES ('Employees', NEW.EmpID, 'UPDATE', NOW());\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to log a message before an employee is inserted? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_employee_insert() RETURNS TRIGGER AS $$\nBEGIN\n  -- In a real trigger, you'd insert into an audit table.\n  RAISE NOTICE 'Preparing to insert employee: %', NEW.Name;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_before_employee_insert\nBEFORE INSERT ON Employees\nFOR EACH ROW\nEXECUTE FUNCTION fn_log_employee_insert();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger that automatically sets the 'CreatedAt' timestamp when a new user is inserted. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_set_created_at() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.CreatedAt := NOW();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_set_created_at\nBEFORE INSERT ON Users\nFOR EACH ROW\nEXECUTE FUNCTION fn_set_created_at();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to prevent an employee's salary from being reduced? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_prevent_salary_reduction() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.Salary < OLD.Salary THEN\n    RAISE EXCEPTION 'Error: Salary cannot be reduced.';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_prevent_salary_reduction\nBEFORE UPDATE ON Employees\nFOR EACH ROW\nEXECUTE FUNCTION fn_prevent_salary_reduction();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to log the old salary to an 'Audit' table after an update. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_audit_salary_update() RETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.Salary IS DISTINCT FROM NEW.Salary THEN\n    INSERT INTO SalaryAudit (EmpID, OldSalary, NewSalary, ChangeDate)\n    VALUES (OLD.EmpID, OLD.Salary, NEW.Salary, NOW());\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_audit_salary_update\nAFTER UPDATE ON Employees\nFOR EACH ROW\nEXECUTE FUNCTION fn_audit_salary_update();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to save a copy of an employee's record to 'EmployeesArchive' after they are deleted. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_archive_employee() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO EmployeesArchive (EmpID, Name, Department, Salary)\n  VALUES (OLD.EmpID, OLD.Name, OLD.Department, OLD.Salary);\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_archive_employee\nAFTER DELETE ON Employees\nFOR EACH ROW\nEXECUTE FUNCTION fn_archive_employee();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to validate email formats before inserting a new customer? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_validate_email() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.Email NOT LIKE '%@%.%' THEN\n    RAISE EXCEPTION 'Invalid email format: %', NEW.Email;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_validate_email\nBEFORE INSERT ON Customers\nFOR EACH ROW\nEXECUTE FUNCTION fn_validate_email();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to update a 'LastModified' timestamp on a product whenever it's updated. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_product_last_modified() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.LastModified := NOW();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_product_last_modified\nBEFORE UPDATE ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_product_last_modified();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to prevent deleting a 'Project' if it's marked as 'Active'? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_prevent_active_project_delete() RETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.Status = 'Active' THEN\n    RAISE EXCEPTION 'Cannot delete an active project.';\n  END IF;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_prevent_active_project_delete\nBEFORE DELETE ON Projects\nFOR EACH ROW\nEXECUTE FUNCTION fn_prevent_active_project_delete();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger that increments 'TotalProducts' in 'Categories' after a new product is added. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_update_category_count() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE Categories\n  SET TotalProducts = TotalProducts + 1\n  WHERE CategoryID = NEW.CategoryID;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_category_count\nAFTER INSERT ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_update_category_count();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger that decrements 'TotalProducts' count after a product is deleted. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_decrease_category_count() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE Categories\n  SET TotalProducts = TotalProducts - 1\n  WHERE CategoryID = OLD.CategoryID;\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_decrease_category_count\nAFTER DELETE ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_decrease_category_count();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set the 'SKU' to uppercase before inserting a new product. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_uppercase_sku() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.SKU := UPPER(NEW.SKU);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_uppercase_sku\nBEFORE INSERT ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_uppercase_sku();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set the 'SKU' to uppercase before updating a product. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_uppercase_sku_update() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.SKU := UPPER(NEW.SKU);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_uppercase_sku_update\nBEFORE UPDATE ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_uppercase_sku_update();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I prevent a product's price from being increased by more than 50% at a time? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_check_price_increase() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.Price > (OLD.Price * 1.50) THEN\n    RAISE EXCEPTION 'Price increase cannot be more than 50%.';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_price_increase\nBEFORE UPDATE ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_check_price_increase();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to ensure 'Stock' cannot be set to a negative number. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_check_stock_positive() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.Stock < 0 THEN\n    NEW.Stock := 0;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_stock_positive\nBEFORE INSERT ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_check_stock_positive();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to check 'Stock' on update as well. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_check_stock_positive_update() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.Stock < 0 THEN\n    RAISE EXCEPTION 'Stock cannot be negative.';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_stock_positive_update\nBEFORE UPDATE ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_check_stock_positive_update();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I log all deleted orders to an 'OrdersAudit' table? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_audit_deleted_orders() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO OrdersAudit (OrderID, CustomerID, TotalAmount, Action, Timestamp)\n  VALUES (OLD.OrderID, OLD.CustomerID, OLD.TotalAmount, 'DELETE', NOW());\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_audit_deleted_orders\nAFTER DELETE ON Orders\nFOR EACH ROW\nEXECUTE FUNCTION fn_audit_deleted_orders();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to prevent 'Username' from being updated. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_prevent_username_change() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.Username IS DISTINCT FROM OLD.Username THEN\n    RAISE EXCEPTION 'Username cannot be changed.';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_prevent_username_change\nBEFORE UPDATE ON Users\nFOR EACH ROW\nEXECUTE FUNCTION fn_prevent_username_change();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set 'JoinDate' to the current date for new customers. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_set_join_date() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.JoinDate := CURRENT_DATE;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_set_join_date\nBEFORE INSERT ON Customers\nFOR EACH ROW\nEXECUTE FUNCTION fn_set_join_date();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I log an 'AFTER INSERT' event on the 'Employees' table? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_new_employee() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO AuditLog (TableName, RecordID, Action, Timestamp)\n  VALUES ('Employees', NEW.EmpID, 'INSERT', NOW());\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_new_employee\nAFTER INSERT ON Employees\nFOR EACH ROW\nEXECUTE FUNCTION fn_log_new_employee();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to log an 'AFTER UPDATE' event on the 'Employees' table. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_update_employee() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO AuditLog (TableName, RecordID, Action, Timestamp)\n  VALUES ('Employees', NEW.EmpID, 'UPDATE', NOW());\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_update_employee\nAFTER UPDATE ON Employees\nFOR EACH ROW\nEXECUTE FUNCTION fn_log_update_employee();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to log a message before an employee is inserted? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_before_employee_insert\nON Employees\nINSTEAD OF INSERT\nAS\nBEGIN\n  -- 'INSTEAD OF' is often used for 'BEFORE' validation\n  PRINT 'Preparing to insert employee...';\n  INSERT INTO Employees (EmpID, Name, Department, Salary)\n  SELECT EmpID, Name, Department, Salary FROM inserted;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger that automatically sets the 'CreatedAt' timestamp when a new user is inserted. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\n-- This is often best done with a DEFAULT constraint, but here is a trigger:\nCREATE TRIGGER trg_set_created_at\nON Users\nAFTER INSERT\nAS\nBEGIN\n  UPDATE Users\n  SET CreatedAt = GETDATE()\n  WHERE UserID IN (SELECT UserID FROM inserted);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to prevent an employee's salary from being reduced? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_prevent_salary_reduction\nON Employees\nFOR UPDATE\nAS\nBEGIN\n  IF EXISTS (\n    SELECT 1 \n    FROM inserted i\n    JOIN deleted d ON i.EmpID = d.EmpID\n    WHERE i.Salary < d.Salary\n  )\n  BEGIN\n    RAISERROR ('Error: Salary cannot be reduced.', 16, 1);\n    ROLLBACK TRANSACTION;\n  END;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to log the old salary to an 'Audit' table after an update. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_audit_salary_update\nON Employees\nAFTER UPDATE\nAS\nBEGIN\n  INSERT INTO SalaryAudit (EmpID, OldSalary, NewSalary, ChangeDate)\n  SELECT \n    i.EmpID, \n    d.Salary, \n    i.Salary, \n    GETDATE()\n  FROM inserted i\n  JOIN deleted d ON i.EmpID = d.EmpID\n  WHERE i.Salary <> d.Salary;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to save a copy of an employee's record to 'EmployeesArchive' after they are deleted. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_archive_employee\nON Employees\nAFTER DELETE\nAS\nBEGIN\n  INSERT INTO EmployeesArchive (EmpID, Name, Department, Salary)\n  SELECT \n    d.EmpID, \n    d.Name, \n    d.Department, \n    d.Salary\n  FROM deleted d;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to validate email formats before inserting a new customer? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_validate_email\nON Customers\nINSTEAD OF INSERT\nAS\nBEGIN\n  IF EXISTS (SELECT 1 FROM inserted WHERE Email NOT LIKE '%@%.%')\n  BEGIN\n    RAISERROR ('Invalid email format.', 16, 1);\n    ROLLBACK TRANSACTION;\n  END\n  ELSE\n  BEGIN\n    INSERT INTO Customers (CustomerID, CustomerName, Email)\n    SELECT CustomerID, CustomerName, Email FROM inserted;\n  END;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to update a 'LastModified' timestamp on a product whenever it's updated. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_product_last_modified\nON Products\nAFTER UPDATE\nAS\nBEGIN\n  UPDATE Products\n  SET LastModified = GETDATE()\n  WHERE ProductID IN (SELECT ProductID FROM inserted);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to prevent deleting a 'Project' if it's marked as 'Active'? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_prevent_active_project_delete\nON Projects\nFOR DELETE\nAS\nBEGIN\n  IF EXISTS (SELECT 1 FROM deleted WHERE Status = 'Active')\n  BEGIN\n    RAISERROR ('Cannot delete an active project.', 16, 1);\n    ROLLBACK TRANSACTION;\n  END;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger that increments 'TotalProducts' in 'Categories' after a new product is added. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_update_category_count\nON Products\nAFTER INSERT\nAS\nBEGIN\n  UPDATE Categories\n  SET TotalProducts = TotalProducts + (SELECT COUNT(*) FROM inserted i WHERE i.CategoryID = Categories.CategoryID)\n  WHERE CategoryID IN (SELECT CategoryID FROM inserted);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger that decrements 'TotalProducts' count after a product is deleted. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_decrease_category_count\nON Products\nAFTER DELETE\nAS\nBEGIN\n  UPDATE Categories\n  SET TotalProducts = TotalProducts - (SELECT COUNT(*) FROM deleted d WHERE d.CategoryID = Categories.CategoryID)\n  WHERE CategoryID IN (SELECT CategoryID FROM deleted);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set the 'SKU' to uppercase before inserting a new product. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_uppercase_sku\nON Products\nINSTEAD OF INSERT\nAS\nBEGIN\n  INSERT INTO Products (ProductID, ProductName, SKU)\n  SELECT ProductID, ProductName, UPPER(SKU) \n  FROM inserted;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set the 'SKU' to uppercase before updating a product. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_uppercase_sku_update\nON Products\nAFTER UPDATE\nAS\nBEGIN\n  -- This updates *after* the insert, a BEFORE trigger is harder\n  UPDATE Products\n  SET SKU = UPPER(Products.SKU)\n  FROM inserted i\n  WHERE Products.ProductID = i.ProductID AND i.SKU <> UPPER(i.SKU);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I prevent a product's price from being increased by more than 50% at a time? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_check_price_increase\nON Products\nFOR UPDATE\nAS\nBEGIN\n  IF EXISTS (\n    SELECT 1 \n    FROM inserted i\n    JOIN deleted d ON i.ProductID = d.ProductID\n    WHERE i.Price > (d.Price * 1.50)\n  )\n  BEGIN\n    RAISERROR ('Price increase cannot be more than 50%.', 16, 1);\n    ROLLBACK TRANSACTION;\n  END;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to ensure 'Stock' cannot be set to a negative number. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_check_stock_positive\nON Products\nINSTEAD OF INSERT\nAS\nBEGIN\n  INSERT INTO Products (ProductID, ProductName, Stock)\n  SELECT ProductID, ProductName, CASE WHEN Stock < 0 THEN 0 ELSE Stock END\n  FROM inserted;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to check 'Stock' on update as well. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_check_stock_positive_update\nON Products\nFOR UPDATE\nAS\nBEGIN\n  IF EXISTS (SELECT 1 FROM inserted WHERE Stock < 0)\n  BEGIN\n    RAISERROR ('Stock cannot be negative.', 16, 1);\n    ROLLBACK TRANSACTION;\n  END;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I log all deleted orders to an 'OrdersAudit' table? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_audit_deleted_orders\nON Orders\nAFTER DELETE\nAS\nBEGIN\n  INSERT INTO OrdersAudit (OrderID, CustomerID, TotalAmount, Action, Timestamp)\n  SELECT \n    d.OrderID, \n    d.CustomerID, \n    d.TotalAmount, \n    'DELETE', \n    GETDATE()\n  FROM deleted d;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to prevent 'Username' from being updated. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_prevent_username_change\nON Users\nFOR UPDATE\nAS\nBEGIN\n  IF UPDATE(Username)\n  BEGIN\n    RAISERROR ('Username cannot be changed.', 16, 1);\n    ROLLBACK TRANSACTION;\n  END;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set 'JoinDate' to the current date for new customers. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\n-- A DEFAULT constraint is better, but here is the trigger:\nCREATE TRIGGER trg_set_join_date\nON Customers\nAFTER INSERT\nAS\nBEGIN\n  UPDATE Customers\n  SET JoinDate = GETDATE()\n  WHERE CustomerID IN (SELECT CustomerID FROM inserted);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I log an 'AFTER INSERT' event on the 'Employees' table? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_log_new_employee\nON Employees\nAFTER INSERT\nAS\nBEGIN\n  INSERT INTO AuditLog (TableName, RecordID, Action, Timestamp)\n  SELECT \n    'Employees', \n    i.EmpID, \n    'INSERT', \n    GETDATE()\n  FROM inserted i;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to log an 'AFTER UPDATE' event on the 'Employees' table. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_log_update_employee\nON Employees\nAFTER UPDATE\nAS\nBEGIN\n  INSERT INTO AuditLog (TableName, RecordID, Action, Timestamp)\n  SELECT \n    'Employees', \n    i.EmpID, \n    'UPDATE', \n    GETDATE()\n  FROM inserted i;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop a trigger named 'trg_before_employee_insert'? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nDROP TRIGGER IF EXISTS trg_before_employee_insert;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop a trigger named 'trg_prevent_salary_reduction' from the 'Employees' table? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nDROP TRIGGER IF EXISTS trg_prevent_salary_reduction ON Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I drop a trigger named 'trg_audit_salary_update' from the 'Employees' table? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nDROP TRIGGER IF EXISTS trg_audit_salary_update ON Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the trigger 'trg_set_created_at'. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nDROP TRIGGER IF EXISTS trg_set_created_at;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the trigger 'trg_archive_employee' from 'Employees'. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nDROP TRIGGER IF EXISTS trg_archive_employee ON Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nDrop the trigger 'trg_validate_email'. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nDROP TRIGGER IF EXISTS trg_validate_email ON Customers;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set a 'FullName' column from 'FirstName' and 'LastName' on insert. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_set_full_name_insert\nBEFORE INSERT ON Employees\nFOR EACH ROW\nBEGIN\n  SET NEW.FullName = CONCAT(NEW.FirstName, ' ', NEW.LastName);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to update 'FullName' when 'FirstName' or 'LastName' is updated. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_set_full_name_update\nBEFORE UPDATE ON Employees\nFOR EACH ROW\nBEGIN\n  SET NEW.FullName = CONCAT(NEW.FirstName, ' ', NEW.LastName);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to update a 'LastModified' timestamp on 'Customers'. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_customer_last_modified() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.LastModified := NOW();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_customer_last_modified\nBEFORE UPDATE ON Customers\nFOR EACH ROW\nEXECUTE FUNCTION fn_customer_last_modified();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'BEFORE DELETE' actions on the 'Projects' table. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_log_project_delete\nBEFORE DELETE ON Projects\nFOR EACH ROW\nBEGIN\n  INSERT INTO AuditLog (Action, RecordID, Message)\n  VALUES ('BEFORE DELETE', OLD.ProjectID, CONCAT('Attempting to delete project: ', OLD.ProjectName));\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'AFTER DELETE' actions on the 'Projects' table. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_project_delete_after() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO AuditLog (Action, RecordID, Message)\n  VALUES ('AFTER DELETE', OLD.ProjectID, 'Successfully deleted project.');\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_project_delete_after\nAFTER DELETE ON Projects\nFOR EACH ROW\nEXECUTE FUNCTION fn_log_project_delete_after();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'AFTER INSERT' on the 'Orders' table. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_log_new_order\nON Orders\nAFTER INSERT\nAS\nBEGIN\n  INSERT INTO AuditLog (Action, RecordID, Message)\n  SELECT \n    'INSERT', \n    i.OrderID, \n    CONCAT('New order placed by Customer: ', i.CustomerID)\n  FROM inserted i;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nPrevent insertion of 'OrderItems' if the product 'Stock' is 0. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_check_stock() RETURNS TRIGGER AS $$\nDECLARE\n  current_stock INT;\nBEGIN\n  SELECT Stock INTO current_stock FROM Products WHERE ProductID = NEW.ProductID;\n  IF current_stock < NEW.Quantity THEN\n    RAISE EXCEPTION 'Not enough stock. Available: %', current_stock;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_stock_before_insert\nBEFORE INSERT ON OrderItems\nFOR EACH ROW\nEXECUTE FUNCTION fn_check_stock();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to automatically update the 'Stock' in 'Products' after an 'OrderItems' row is inserted. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_update_stock_after_order\nAFTER INSERT ON OrderItems\nFOR EACH ROW\nBEGIN\n  UPDATE Products\n  SET Stock = Stock - NEW.Quantity\n  WHERE ProductID = NEW.ProductID;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to add stock back if an 'Order' is 'Cancelled'. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax (This is complex, as it must read OrderItems)\nCREATE TRIGGER trg_restock_on_cancel\nAFTER UPDATE ON Orders\nFOR EACH ROW\nBEGIN\n  IF NEW.Status = 'Cancelled' AND OLD.Status <> 'Cancelled' THEN\n    UPDATE Products p\n    JOIN OrderItems oi ON p.ProductID = oi.ProductID\n    SET p.Stock = p.Stock + oi.Quantity\n    WHERE oi.OrderID = NEW.OrderID;\n  END IF;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to add stock back if an 'OrderItems' row is deleted. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_restock_on_item_delete\nAFTER DELETE ON OrderItems\nFOR EACH ROW\nBEGIN\n  UPDATE Products\n  SET Stock = Stock + OLD.Quantity\n  WHERE ProductID = OLD.ProductID;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to prevent 'Orders' from being inserted on a weekend? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_check_weekday() RETURNS TRIGGER AS $$\nBEGIN\n  IF EXTRACT(ISODOW FROM NEW.OrderDate) IN (6, 7) THEN\n    RAISE EXCEPTION 'Orders cannot be placed on weekends.';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_weekday_order\nBEFORE INSERT ON Orders\nFOR EACH ROW\nEXECUTE FUNCTION fn_check_weekday();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to prevent logging in 'AuditLog' from firing itself. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_changes() RETURNS TRIGGER AS $$\nBEGIN\n  -- Check for a session variable to prevent recursion\n  IF current_setting('my_app.disable_triggers', 't') = 'true' THEN\n    RETURN NEW;\n  END IF;\n  -- ... do logging ...\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to trim whitespace from 'FirstName' and 'LastName' before insert. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_trim_names\nBEFORE INSERT ON Employees\nFOR EACH ROW\nBEGIN\n  SET NEW.FirstName = TRIM(NEW.FirstName);\n  SET NEW.LastName = TRIM(NEW.LastName);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to trim names on update as well. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_trim_names_update\nBEFORE UPDATE ON Employees\nFOR EACH ROW\nBEGIN\n  SET NEW.FirstName = TRIM(NEW.FirstName);\n  SET NEW.LastName = TRIM(NEW.LastName);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger to prevent duplicate emails from being inserted (case-insensitive)? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_check_duplicate_email() RETURNS TRIGGER AS $$\nBEGIN\n  IF EXISTS (SELECT 1 FROM Users WHERE LOWER(Email) = LOWER(NEW.Email)) THEN\n    RAISE EXCEPTION 'Email already exists: %', NEW.Email;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_duplicate_email\nBEFORE INSERT ON Users\nFOR EACH ROW\nEXECUTE FUNCTION fn_check_duplicate_email();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set 'Email' to lowercase before insert. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_lowercase_email() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.Email := LOWER(NEW.Email);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_lowercase_email\nBEFORE INSERT ON Users\nFOR EACH ROW\nEXECUTE FUNCTION fn_lowercase_email();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to set 'Email' to lowercase on update. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_lowercase_email_update() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.Email := LOWER(NEW.Email);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_lowercase_email_update\nBEFORE UPDATE ON Users\nFOR EACH ROW\nEXECUTE FUNCTION fn_lowercase_email_update();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I log 'BEFORE INSERT' on 'Customers'? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_log_customer_insert\nBEFORE INSERT ON Customers\nFOR EACH ROW\nBEGIN\n  INSERT INTO AuditLog (Action, Message) \n  VALUES ('BEFORE INSERT', CONCAT('Attempting to add customer: ', NEW.CustomerName));\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I log 'AFTER INSERT' on 'Customers'? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_log_customer_insert_after\nAFTER INSERT ON Customers\nFOR EACH ROW\nBEGIN\n  INSERT INTO AuditLog (Action, Message)\n  VALUES ('AFTER INSERT', CONCAT('Added customer ID: ', NEW.CustomerID));\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'BEFORE UPDATE' on 'Customers'. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_log_customer_update\nBEFORE UPDATE ON Customers\nFOR EACH ROW\nBEGIN\n  INSERT INTO AuditLog (Action, Message)\n  VALUES ('BEFORE UPDATE', CONCAT('Attempting to update customer ID: ', OLD.CustomerID));\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'AFTER UPDATE' on 'Customers'. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_log_customer_update_after\nAFTER UPDATE ON Customers\nFOR EACH ROW\nBEGIN\n  INSERT INTO AuditLog (Action, Message)\n  VALUES ('AFTER UPDATE', CONCAT('Updated customer ID: ', NEW.CustomerID));\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'BEFORE DELETE' on 'Customers'. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_log_customer_delete\nBEFORE DELETE ON Customers\nFOR EACH ROW\nBEGIN\n  INSERT INTO AuditLog (Action, Message)\n  VALUES ('BEFORE DELETE', CONCAT('Attempting to delete customer: ', OLD.CustomerName));\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'AFTER DELETE' on 'Customers'. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_log_customer_delete_after\nAFTER DELETE ON Customers\nFOR EACH ROW\nBEGIN\n  INSERT INTO AuditLog (Action, Message)\n  VALUES ('AFTER DELETE', CONCAT('Deleted customer: ', OLD.CustomerName));\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'BEFORE INSERT' on 'Products'. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_product_insert() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO AuditLog (Action, Message) VALUES ('BEFORE INSERT', 'Adding product');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_product_insert\nBEFORE INSERT ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_log_product_insert();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'AFTER INSERT' on 'Products'. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_product_insert_after() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO AuditLog (Action, Message) VALUES ('AFTER INSERT', 'Added product');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_product_insert_after\nAFTER INSERT ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_log_product_insert_after();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'BEFORE UPDATE' on 'Products'. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_product_update() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO AuditLog (Action, Message) VALUES ('BEFORE UPDATE', 'Updating product');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_product_update\nBEFORE UPDATE ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_log_product_update();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'AFTER UPDATE' on 'Products'. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_product_update_after() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO AuditLog (Action, Message) VALUES ('AFTER UPDATE', 'Updated product');\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_product_update_after\nAFTER UPDATE ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_log_product_update_after();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'BEFORE DELETE' on 'Products'. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_product_delete() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO AuditLog (Action, Message) VALUES ('BEFORE DELETE', 'Deleting product');\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_product_delete\nBEFORE DELETE ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_log_product_delete();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'AFTER DELETE' on 'Products'. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_product_delete_after() RETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO AuditLog (Action, Message) VALUES ('AFTER DELETE', 'Deleted product');\n  RETURN OLD;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_product_delete_after\nAFTER DELETE ON Products\nFOR EACH ROW\nEXECUTE FUNCTION fn_log_product_delete_after();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'AFTER INSERT' on 'Users'. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_log_user_insert\nON Users\nAFTER INSERT\nAS\nBEGIN\n  INSERT INTO AuditLog (Action, Message) \n  SELECT 'AFTER INSERT', 'Added user' FROM inserted;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'AFTER UPDATE' on 'Users'. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_log_user_update\nON Users\nAFTER UPDATE\nAS\nBEGIN\n  INSERT INTO AuditLog (Action, Message) \n  SELECT 'AFTER UPDATE', 'Updated user' FROM inserted;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nLog 'AFTER DELETE' on 'Users'. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_log_user_delete\nON Users\nAFTER DELETE\nAS\nBEGIN\n  INSERT INTO AuditLog (Action, Message) \n  SELECT 'AFTER DELETE', 'Deleted user' FROM deleted;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me an 'INSTEAD OF INSERT' trigger. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_instead_of_insert_demo\nON Employees\nINSTEAD OF INSERT\nAS\nBEGIN\n  PRINT 'INSTEAD OF trigger fired. Original insert is skipped.';\n  -- You would add custom logic here, like inserting into a different table.\n  INSERT INTO Employees (EmpID, Name) \n  SELECT EmpID, Name FROM inserted WHERE Name <> 'Invalid';\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me an 'INSTEAD OF UPDATE' trigger. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_instead_of_update_demo\nON Employees\nINSTEAD OF UPDATE\nAS\nBEGIN\n  PRINT 'INSTEAD OF UPDATE trigger fired. Original update is skipped.';\n  -- Example: Only allow salary increases\n  UPDATE e\n  SET e.Salary = i.Salary\n  FROM Employees e\n  JOIN inserted i ON e.EmpID = i.EmpID\n  JOIN deleted d ON e.EmpID = d.EmpID\n  WHERE i.Salary >= d.Salary;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nShow me an 'INSTEAD OF DELETE' trigger. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\n-- This is often used for 'soft deletes'\nCREATE TRIGGER trg_instead_of_delete_demo\nON Employees\nINSTEAD OF DELETE\nAS\nBEGIN\n  PRINT 'INSTEAD OF DELETE fired. Performing soft delete.';\n  UPDATE Employees\n  SET IsActive = 0\n  WHERE EmpID IN (SELECT EmpID FROM deleted);\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I create a trigger that cascades a 'TotalAmount' from 'OrderItems' to 'Orders'? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_update_order_total() RETURNS TRIGGER AS $$\nBEGIN\n  UPDATE Orders\n  SET TotalAmount = (SELECT SUM(Quantity * UnitPrice) FROM OrderItems WHERE OrderID = COALESCE(NEW.OrderID, OLD.OrderID))\n  WHERE OrderID = COALESCE(NEW.OrderID, OLD.OrderID);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_order_total\nAFTER INSERT OR UPDATE OR DELETE ON OrderItems\nFOR EACH ROW\nEXECUTE FUNCTION fn_update_order_total();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to prevent 'Salary' from being NULL. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_prevent_null_salary\nBEFORE INSERT ON Employees\nFOR EACH ROW\nBEGIN\n  IF NEW.Salary IS NULL THEN\n    SET NEW.Salary = 0; -- Or SIGNAL an error\n  END IF;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to log changes only if the 'Status' column was updated. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_log_status_change\nON Orders\nAFTER UPDATE\nAS\nBEGIN\n  IF UPDATE(Status) -- Checks if the 'Status' column was part of the UPDATE\n  BEGIN\n    INSERT INTO AuditLog (Action, Message)\n    SELECT 'UPDATE', 'Status changed' FROM inserted;\n  END;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to log changes only if the 'Status' column was updated. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_log_status_change() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.Status IS DISTINCT FROM OLD.Status THEN\n     INSERT INTO AuditLog (Action, Message) VALUES ('UPDATE', 'Status changed');\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_log_status_change\nAFTER UPDATE ON Orders\nFOR EACH ROW\nEXECUTE FUNCTION fn_log_status_change();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I disable a trigger? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nDISABLE TRIGGER trg_prevent_salary_reduction ON Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I enable a trigger? (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nENABLE TRIGGER trg_prevent_salary_reduction ON Employees;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I disable a trigger? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nALTER TABLE Employees DISABLE TRIGGER trg_prevent_salary_reduction;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I enable a trigger? (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nALTER TABLE Employees ENABLE TRIGGER trg_prevent_salary_reduction;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I disable a trigger? (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\n-- You cannot disable a single trigger. You can drop and recreate it.\n-- Or, you can set a session variable that the trigger checks.\nSET @disable_triggers = 1;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I check for 'inserted' and 'deleted' tables in SQL Server?\n<end_of_turn>\n<start_of_turn>model\nIn SQL Server triggers, `inserted` is a special in-memory table holding the new or updated rows. `deleted` is a table holding the old or deleted rows. You join them on the primary key for updates.\n<end_of_turn>"}
{"text": "<start_of_turn>user\nHow do I check 'NEW' and 'OLD' in PostgreSQL/MySQL?\n<end_of_turn>\n<start_of_turn>model\nIn PostgreSQL and MySQL `FOR EACH ROW` triggers, `NEW` is a record variable holding the new row data (for INSERT/UPDATE), and `OLD` is a record variable holding the old row data (for UPDATE/DELETE).\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to prevent insertion if 'FirstName' or 'LastName' is NULL. (MySQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- MySQL Syntax\nCREATE TRIGGER trg_check_name_null\nBEFORE INSERT ON Employees\nFOR EACH ROW\nBEGIN\n  IF NEW.FirstName IS NULL OR NEW.LastName IS NULL THEN\n    SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'First and Last name must not be null.';\n  END IF;\nEND;\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to prevent insertion if 'FirstName' or 'LastName' is NULL. (PostgreSQL)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- PostgreSQL Syntax\nCREATE FUNCTION fn_check_name_null() RETURNS TRIGGER AS $$\nBEGIN\n  IF NEW.FirstName IS NULL OR NEW.LastName IS NULL THEN\n    RAISE EXCEPTION 'First and Last name must not be null.';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_check_name_null\nBEFORE INSERT ON Employees\nFOR EACH ROW\nEXECUTE FUNCTION fn_check_name_null();\n```\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCreate a trigger to prevent insertion if 'FirstName' or 'LastName' is NULL. (SQL Server)\n<end_of_turn>\n<start_of_turn>model\n```sql\n-- T-SQL (SQL Server) Syntax\nCREATE TRIGGER trg_check_name_null\nON Employees\nINSTEAD OF INSERT\nAS\nBEGIN\n  IF EXISTS (SELECT 1 FROM inserted WHERE FirstName IS NULL OR LastName IS NULL)\n  BEGIN\n    RAISERROR ('First and Last name must not be null.', 16, 1);\n    ROLLBACK TRANSACTION;\n  END\n  ELSE\n  BEGIN\n    INSERT INTO Employees (EmpID, FirstName, LastName) \n    SELECT EmpID, FirstName, LastName FROM inserted;\n  END;\nEND;\n```\n<end_of_turn>"}